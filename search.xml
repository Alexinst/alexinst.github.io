<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo部署到Github出错</title>
    <url>/Hexo/Hexo-delopy-to-github/</url>
    <content><![CDATA[<p><strong>简述</strong>: 将本地Hexo博客部署到Github Pages时，Git Bash出现报错：无法读取Github用户。在repo的url链接中加入用户名和密码，即可解决问题。</p>
<span id="more"></span>
<br />

<h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1 问题"></a>1 问题</h1><p>　　搭建Hexo博客，按照网上教程，在<code>hexo d</code>这一步出现如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: HttpRequestException encountered.</span><br><span class="line">   ��������ʱ�����</span><br><span class="line">bash: /dev/tty: No such device or address</span><br><span class="line">error: failed to execute prompt script (exit code 1)</span><br><span class="line">fatal: could not read Username for &#x27;https://github.com&#x27;: No error</span><br><span class="line">FATAL Something&#x27;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: fatal: HttpRequestException encountered.</span><br><span class="line">   ��������ʱ������</span><br><span class="line">bash: /dev/tty: No such device or address</span><br><span class="line">error: failed to execute prompt script (exit code 1)</span><br><span class="line">fatal: could not read Username for &#x27;https://github.com&#x27;: No error</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt;</span><br><span class="line">    at emitTwo (events.js:106:13)</span><br><span class="line">    at ChildProcess.emit (events.js:191:7)</span><br><span class="line">    at ChildProcess.cp.emit</span><br><span class="line">    at maybeClose</span><br><span class="line">    at Process.ChildProcess._handle.onexit (internal/child_process.js:226:5)</span><br></pre></td></tr></table></figure>

<h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2 解决办法"></a>2 解决办法</h1><p>　　编辑博客文件下的<code>_config.yml</code>。</p>
<p>　　找到<code>#Deployment</code>，修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo:  https://&lt;用户名&gt;:&lt;密码&gt;@github.com/ares-x/ares-x.github.io.git </span><br><span class="line">    branch: master</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>「Network」127.0.0.1 与 0.0.0.0</title>
    <url>/Network/127-0-0-1-and-0-0-0-0/</url>
    <content><![CDATA[<p><strong>简述：</strong>我对 <code>127.0.0.1</code> 和 <code>0.0.0.0</code> 这两个地址的概念一直都，好像了解，但却说不清楚。最近写博客的冲动比较强烈，遂查阅诸多资料，作解惑与收录。</p>
<br />

<span id="more"></span>



<h1 id="1-127-0-0-1"><a href="#1-127-0-0-1" class="headerlink" title="1 127.0.0.1"></a>1 127.0.0.1</h1><p><code>127.0.0.1</code> 是 <code>IPv4</code> 的 <strong>loopback 地址</strong>。<code>localhost</code> 这个主机名称一般会解析为 <code>127.0.0.1</code> 。</p>
<ul>
<li><p>所谓 <code>loopback</code>（环回，无助于理解的翻译） 机制，就是<strong>不借由本机网络接口（<code>network interface</code>）和本机接入的网络，实现（仅限）在本机中的网络服务</strong>。</p>
</li>
<li><p>loopback 地址是一个接口（<code>interface</code>），基于软件实现，与硬件没有关联，也并没有实际接入外部网络。使用 loopback 网络接口会忽略本地的网络接口硬件。</p>
</li>
<li><p><code>127.0.0.1</code> 指向本机，通过在浏览器地址栏输入 <code>127.0.0.1</code> 及某一端口号， 可与 监听这一地址和该端口的本机程序进行连接。</p>
</li>
</ul>
<blockquote>
<p>If you enter an IP address (or corresponding domain name) in your browser, the router will forward your request to the internet and to the correct server. This means that if you enter 172.217.0.0, you will reach the Google homepage. However, the situation is different with 127.0.0.1 because requests to this address will not be forwarded to the internet. TCP/IP recognizes from the first block (127) that you don’t want to access the internet, you are calling yourself instead. This then triggers the <strong>loopback.</strong></p>
</blockquote>
<ul>
<li>实际上，<code>IPv4</code> loopback 地址是 <code>127.0.0.0/8</code>，也就是形式为 <code>127.xxx.xxx.xxx</code> 的所有地址（除了 <code>127.255.255.255</code>），总数超过1600万。这意味着，在浏览器地址栏输入这1600多万 <code>IPv4</code> 地址的任一个以及相应端口，都能连接到监听程序。</li>
</ul>
<p>如图所示，输入 <code>127.0.0.1:4000</code>、<code>127.1.1.1:4000</code>、<code>127.255.255.1:4000</code>三个不同的地址，均能跳转至 <strong>Hexo</strong> 首页。</p>
<p><img src="https://res.cloudinary.com/hexo-pics/image/upload/v1568964370/hexo-2019/09/loopback1.png" alt="loopback1"></p>
<p><img src="https://res.cloudinary.com/hexo-pics/image/upload/v1568964370/hexo-2019/09/loopback2.png" alt="loopback2"></p>
<p><img src="https://res.cloudinary.com/hexo-pics/image/upload/v1568964370/hexo-2019/09/loopback3.png" alt="loopback3"><br /></p>
<h1 id="2-0-0-0-0"><a href="#2-0-0-0-0" class="headerlink" title="2 0.0.0.0"></a>2 0.0.0.0</h1><p>在 <code>IPv4</code> 中，<code>0.0.0.0</code> 是一个<strong>不可路由</strong>（<code>non-routable</code>）的地址，用于指向一个无效、不适用或者未知的目标。在不同情况中，这一地址具有不同的含义。</p>
<ol>
<li>提到主机地址<ul>
<li>在配置服务器时， 可以泛指所有 <code>IPv4</code> 地址，比如绑定监听 <code>socket</code>。</li>
<li>当某主机未被分配一个 <code>IPv4</code> 地址时，该主机可以将 <code>0.0.0.0</code> 声明为它的地址。比如在通过 <code>DHCP</code> 获取地址时，主机向所在子网发送一个 <code>DHCP discover</code> 的链路层帧（<code>Frame</code>），帧中的 <code>IPv4</code> 数据报的源 <code>IPv4</code> 地址就是 <code>0.0.0.0</code>，因为该主机还未分配地址。</li>
</ul>
</li>
<li>提到路由表（<code>routing table</code>）<ul>
<li><code>0.0.0.0/0</code> 作为 默认路由（<code>default route</code>）的 目的地址（<code>Destination</code> ）字段。（这里需要对 <code>CIDR </code>有基本的了解）因为 <code>CIDR</code> 的最长前缀匹配（<code>longest prefix match</code>）规则，而<code>0.0.0.0/0</code> 的子网掩码长度为0，所以<code>0.0.0.0/0</code> 将是路由表中的最后匹配，即默认路由。</li>
<li><code>0.0.0.0</code>作为路由表中规则的网关（<code>Gateway</code>）字段。没有指定去往目的子网的相应网关，也就是说目的地址在同一网段，通信时不需要经过网关。</li>
</ul>
</li>
</ol>
<br />



<h1 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h1><ul>
<li><a href="https://www.ionos.com/digitalguide/server/know-how/localhost/"><strong>Localhost (127.0.0.1) - IONOS</strong></a></li>
<li><a href="https://en.wikipedia.org/wiki/0.0.0.0">0.0.0.0 - wikipedia</a></li>
<li><a href="https://superuser.com/questions/949428/whats-the-difference-between-127-0-0-1-and-0-0-0-0">What’s the difference between 127.0.0.1 and 0.0.0.0? - Superuser</a></li>
<li><a href="https://www.certificationkits.com/cisco-certification/ccna-articles/cisco-ccna-intro-to-routing-basics/cisco-ccna-default-gateway-a-default-routes/">Default Gateway &amp; Default Routes - Cisco CCNA</a></li>
<li><a href="https://blog.csdn.net/kikajack/article/details/80457841">Linux 路由表详解及 route 命令详解 - CSDN</a></li>
<li><a href="https://en.wikipedia.org/wiki/Loopback">Loopback - Wikipedia</a></li>
</ul>
<br />

<p><strong>以上！</strong></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>TCP/IP</tag>
        <tag>loopback</tag>
        <tag>route</tag>
      </tags>
  </entry>
  <entry>
    <title>「Debian」Debian 使用 apt 安装软件时提示插入光盘</title>
    <url>/Linux/apt-get-install-error-media-change/</url>
    <content><![CDATA[<p><strong>简述</strong>：<code>apt</code> 是 <code>Debian</code> 的安装包管理工具。</p>
<span id="more"></span>
<br />

<h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1 问题"></a>1 问题</h1><p>在VMware中成功安装Debian 9.2，进入终端运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>结果出现如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Media change: please insert the disc labeled</span><br><span class="line"> &#x27;Debian GNU/Linux......&#x27;</span><br><span class="line">in the drive &#x27;/media/cdrom/&#x27; and press enter</span><br></pre></td></tr></table></figure>

<br />



<h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2 解决办法"></a>2 解决办法</h1><p>打开并修改文件 <code>sources.list</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>找到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb cdrom:[Debian GNU/Linux ......] .......</span><br></pre></td></tr></table></figure>

<p>将其注释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># deb cdrom:[Debian GNU/Linux ......] .......            </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure>





<br />

<p><strong>以上</strong></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Debian</tag>
        <tag>apt</tag>
        <tag>insert_disc</tag>
      </tags>
  </entry>
  <entry>
    <title>「Linux」增删用户以及赋予 sudo 权限</title>
    <url>/Linux/add-check-and-delete-user-on-linux/</url>
    <content><![CDATA[<p><strong>简述</strong> ：<code>Linux</code>日常使用不建议用<code>root</code>登录，因为<code>root</code>具有全部权限。为此，需要添加一个普通用户，而为了正常使用，还需要赋予其<code>sudo</code>权限。</p>
<span id="more"></span>

<br />

<h1 id="1-添加普通用户并赋予-sudo-权限"><a href="#1-添加普通用户并赋予-sudo-权限" class="headerlink" title="1 添加普通用户并赋予 sudo 权限"></a>1 添加普通用户并赋予 sudo 权限</h1><h2 id="1-1-创建普通用户帐号"><a href="#1-1-创建普通用户帐号" class="headerlink" title="1.1 创建普通用户帐号"></a>1.1 创建普通用户帐号</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo adduser USERNAME</span><br></pre></td></tr></table></figure>

<p><strong>全文<code>USERNAME</code> 指代用户名，例如 Alex、Sam 等等。</strong></p>
<p>为运行创建新用户的命令，当前 user 必须是<code>root</code>或者具有<code>sudo</code>权限的普通 user。</p>
<p>创建过程中，需要输入用户密码，其他信息的输入可选择跳过。</p>
<h2 id="1-2-将用户添加至-sudo-group"><a href="#1-2-将用户添加至-sudo-group" class="headerlink" title="1.2 将用户添加至 sudo group"></a>1.2 将用户添加至 <code>sudo</code> group</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -aG sudo USERNAME</span><br></pre></td></tr></table></figure>

<p><code>usermod</code> 手册：<a href="https://manpages.ubuntu.com/manpages/cosmic/en/man8/usermod.8.html">Here</a></p>
<br />

<h1 id="2-测试用户权限"><a href="#2-测试用户权限" class="headerlink" title="2 测试用户权限"></a>2 测试用户权限</h1><p>切换至新用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ su - USERNAME</span><br></pre></td></tr></table></figure>

<p>测试权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo whoami</span><br></pre></td></tr></table></figure>

<p>输出应为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root</span><br></pre></td></tr></table></figure>

<br />

<h1 id="3-修改密码"><a href="#3-修改密码" class="headerlink" title="3 修改密码"></a>3 修改密码</h1><h2 id="3-1-修改自己的密码"><a href="#3-1-修改自己的密码" class="headerlink" title="3.1 修改自己的密码"></a>3.1 修改自己的密码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ passwd</span><br></pre></td></tr></table></figure>

<h2 id="3-2-修改他人的密码"><a href="#3-2-修改他人的密码" class="headerlink" title="3.2 修改他人的密码"></a>3.2 修改他人的密码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo passwd USERNAME</span><br></pre></td></tr></table></figure>

<p>修改<strong>其他用户</strong>的密码，你必须是<code>root</code>用户或者具有<code>sudo</code>权限 。</p>
<br />

<h1 id="4-移除用户的-sudo-权限"><a href="#4-移除用户的-sudo-权限" class="headerlink" title="4 移除用户的 sudo 权限"></a>4 移除用户的 sudo 权限</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo deluser USERNAME sudo</span><br></pre></td></tr></table></figure>

<p>验证用户是否已从<code>sudo</code>组删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo -lU USERNAME</span><br></pre></td></tr></table></figure>

<p><code>deluser</code>手册：<a href="https://manpages.ubuntu.com/manpages/bionic/en/man8/deluser.8.html">Here</a>；<code>sudo</code>手册：<a href="https://manpages.ubuntu.com/manpages/bionic/en/man8/sudo.8.html">Here</a></p>
<br />



<h1 id="5-删除用户（慎重）"><a href="#5-删除用户（慎重）" class="headerlink" title="5 删除用户（慎重）"></a>5 删除用户（慎重）</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo deluser --remove-home USERNAME</span><br></pre></td></tr></table></figure>

<p><code>--remove-home</code>：删除用户时移除其<code>home</code>目录。不加此选项，<code>home</code>目录不会被删除。</p>
<br />



<h1 id="6-查看所有用户和组"><a href="#6-查看所有用户和组" class="headerlink" title="6 查看所有用户和组"></a>6 查看所有用户和组</h1><h2 id="6-1-查看所有用户"><a href="#6-1-查看所有用户" class="headerlink" title="6.1 查看所有用户"></a>6.1 查看所有用户</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /etc/group</span><br></pre></td></tr></table></figure>

<h2 id="6-2-查看所有组"><a href="#6-2-查看所有组" class="headerlink" title="6.2 查看所有组"></a>6.2 查看所有组</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /etc/passwd</span><br></pre></td></tr></table></figure>

<h2 id="6-3-查看当前用户所在组"><a href="#6-3-查看当前用户所在组" class="headerlink" title="6.3 查看当前用户所在组"></a>6.3 查看当前用户所在组</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ groups</span><br></pre></td></tr></table></figure>

<br />

<h1 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h1><p><a href="https://linux.cn/article-8404-1.html">深入理解 sudo 与 su 之间的区别</a></p>
<p><a href="https://linuxize.com/post/how-to-create-a-sudo-user-on-ubuntu/">How To Create a Sudo User on Ubuntu</a></p>
<p><a href="http://blog.itpub.net/31559985/viewspace-2638312/">一起学习在 Ubuntu 上授予和移除 sudo 权限</a></p>
<br />

<p><strong>以上！</strong></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>user</tag>
        <tag>sudo</tag>
      </tags>
  </entry>
  <entry>
    <title>「Android」Context，Application 和 Activity</title>
    <url>/Android/Context-Application-and-Activity/</url>
    <content><![CDATA[<p><strong>简述</strong>：<code>Context</code> 在 <code>Android</code> 开发中无处不在，可以说是最重要的概念。对 <code>Context</code> 的错误使用，很容易造成 <code>Android App</code> 的内存泄漏。</p>
<span id="more"></span>

<br />

<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><ol>
<li><code>Application</code> 和 <code>Activity</code> 都<strong>间接继承</strong>自 <code>Context</code> 。</li>
<li>所谓 <code>Application Context</code> ，就是指 <code>Application</code>。同样的，<code>Activity Context</code> 也就是指 <code>Activity</code>。</li>
<li>本文把等同的事物（比如 <code>Activity Context</code> 和 <code>Activity</code>）当作不同来讲，逻辑上似乎有些奇怪，但这主要是为了强调它（<code>Activity Context</code>）一方面提供了应用级和系统级的接口，另一方面（<code>Activity</code>）也是显示的主体。</li>
</ol>
<br />



<h1 id="2-Context"><a href="#2-Context" class="headerlink" title="2 Context"></a>2 <a href="https://developer.android.com/reference/android/content/Context#getApplicationContext()">Context</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.object</span><br><span class="line">  ↳ android.content.Context</span><br></pre></td></tr></table></figure>

<ol>
<li><p>是什么</p>
<blockquote>
<p>Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc. </p>
<p><code>Context</code> 是访问应用程序全局信息的接口，是一个由<code>Android</code> 系统提供实现（类 <code>ContextImpl</code>）的抽象类。它允许访问应用程序特有的资源（<code>resource</code>）和类（<code>class</code>），以及向上调用（<code>up-call</code>）应用级操作，如启动 <code>Activity</code>、<code>Broadcast</code> 和接收 <code>Intent</code> 等。 </p>
</blockquote>
</li>
<li><p>能做什么</p>
<ul>
<li>创建 <code>View</code>（比如 <code>TextView</code> 、<code>Button</code>、<code>ImageView</code> 等）</li>
<li>启动 <code>Activity</code>、<code>Service</code> </li>
<li>发送和接收广播（<code>Broadcast</code>）</li>
<li>。。。。。。</li>
</ul>
</li>
<li><p>实现</p>
<p><code>Context</code> 只是一个抽象类，其实现是继承<code>Context</code> 的 类 <code>ContextImpl</code>。</p>
</li>
</ol>
<br />



<h1 id="3-Activity-和-Application"><a href="#3-Activity-和-Application" class="headerlink" title="3 Activity 和 Application"></a>3 <a href="https://developer.android.com/reference/android/app/Activity">Activity</a> 和 <a href="https://developer.android.com/reference/android/app/Application">Application</a></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.object</span><br><span class="line">  ↳ android.content.Context</span><br><span class="line">      ↳ android.context.ContextWrapper</span><br><span class="line">          ↳ android.view.ContextThemeWrapper</span><br><span class="line">             *↳ android.app.Activity </span><br><span class="line">         *↳ android.app.Application</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>Activity</code> 和 <code>Application</code> 间接继承了 <code>Context</code>，那这两者是什么，之间又有什么区别呢？</p>
<h2 id="3-1-是什么"><a href="#3-1-是什么" class="headerlink" title="3.1 是什么"></a>3.1 是什么</h2><ol>
<li><code>Activity</code> 是与用户交互的入口点。它表示拥有界面的单个屏幕。例如，电子邮件应用可能有一个显示新电子邮件列表的 <code>Activity</code>、一个用于撰写电子邮件的 <code>Activity</code> 以及一个用于阅读电子邮件的 <code>Activity</code>。尽管这些 <code>Activity</code> 通过协作在电子邮件应用中形成一种紧密结合的用户体验，但每个 <code>Activity</code> 都独立于其他 <code>Activity</code> 而存在。因此，其他应用可以启动其中任何一个 <code>Activity</code>（如果电子邮件应用允许）。例如，相机应用可以启动电子邮件应用内用于撰写新电子邮件的 <code>Activity</code>，以便用户共享图片。<code>Activity</code> 有助于完成系统和应用程序之间的以下重要交互：<ul>
<li>追踪用户当前关心的内容（屏幕上显示的内容），以确保系统继续运行托管 <code>Activity</code> 的进程。</li>
<li>了解先前使用的进程包含用户可能返回的内容（已停止的 <code>Activity</code>），从而更优先保留这些进程。</li>
<li>帮助应用处理终止其进程的情况，以便用户可以返回已恢复其先前状态的 <code>Activity</code>。</li>
<li>提供一种途径，让应用实现彼此之间的用户流，并让系统协调这些用户流。（此处最经典的示例是共享。）</li>
</ul>
</li>
<li><code>Application</code> 或其子类是保存应用全局信息的类。当应用程序的进程启动时，第一个实例化的类就是 <code>Application</code>。<code>Application</code> 是一个单例（<code>singleton</code>）的类，即一个运行的应用只有 <code>Application</code> 或其子类的一个实例。<br>不能在 <code>Application</code> 中保存可变的共享数据，因为你不知道它会被谁改变。更好的选择是保存在 文件、<code>SharedPreferences</code> 或 <code>SQLite</code> 中。</li>
</ol>
<h2 id="3-2-区别"><a href="#3-2-区别" class="headerlink" title="3.2 区别"></a>3.2 区别</h2><ol start="2">
<li><p>有不同的生命周期。<code>Application Context</code> 存在于应用程序的运行期间，而 <code>Activity Context</code> 则与 <code>Activity </code> 的实例”同生共死“。</p>
</li>
<li><p>有不完全相同的应用场景。</p>
<table>
<thead>
<tr>
<th></th>
<th align="center">Application</th>
<th align="center">Activity</th>
</tr>
</thead>
<tbody><tr>
<td>启动 Activity / Start an activity</td>
<td align="center">✘</td>
<td align="center">✔</td>
</tr>
<tr>
<td>显示对话框 / Show a dialog</td>
<td align="center">✘</td>
<td align="center">✔</td>
</tr>
<tr>
<td>生成布局 / Layout inflation</td>
<td align="center">✘</td>
<td align="center">✔</td>
</tr>
<tr>
<td>加载资源 / Load resource values</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td>启动 Service / Start a service</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td>与 Service 绑定 / Bild to a service</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td>发送 Broadcast / Send a broadcast</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td>注册 Broadcast 接收器 / Register a broadcast receiver</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
</tbody></table>
<p>显然，<code>Activity Context</code> 能做到的比 <code>Application Context</code> 更多。</p>
</li>
</ol>
<br />



<h1 id="4-获取-Context"><a href="#4-获取-Context" class="headerlink" title="4 获取 Context"></a>4 获取 Context</h1><h2 id="4-1-方法"><a href="#4-1-方法" class="headerlink" title="4.1 方法"></a>4.1 方法</h2><ol>
<li><p><a href="https://developer.android.com/reference/android/content/Context#getApplicationContext()"><code>Context.getApplicationContext()</code></a>：返回当前进程的唯一、全局的 <code>Application Context</code>，它的生命周期与当前 <code>Context</code> 并不相干。</p>
</li>
<li><p><a href="https://developer.android.com/reference/android/app/Activity#getApplication()"><code>Activity.getApplication()</code></a>:  返回该 <code>Activity</code> 的 <code>Application</code> ，和 <code>getApplicationContext()</code> 返回的是同一个对象。</p>
</li>
<li><p><a href="https://developer.android.com/reference/android/view/View#getContext()"><code>View.getContext()</code></a>：返回一个 <code>Context</code> 引用，指向 <code>View</code> 运行依靠的 <code>Context</code>，通常就是当前正在显示的 <code>Activity</code> 实例。</p>
</li>
<li><p><code>Activity.this</code>：适用于在 <code>Activity</code> 内的匿名内部类 访问 其外部的 <code>Activity</code>。</p>
</li>
<li><p><a href="https://stackoverflow.com/questions/9605459/android-why-must-use-getbasecontext-instead-of-this"><code>ContextWrapper.getBaseContext()</code></a>：返回 <code>base Context</code>。</p>
</li>
</ol>
<h2 id="4-2-选用"><a href="#4-2-选用" class="headerlink" title="4.2 选用"></a>4.2 选用</h2><ol>
<li>避免使用 <code>getBaseContext()</code>。因为你并不知道返回的是哪个<code>Context</code>。</li>
<li>与 <code>UI</code> 相关的场景，使用 <code>Activity Context</code>；除此之外，可以使用 <code>Application Context</code>。</li>
<li>将一个 <code>Context</code> 传到 <code>Activity</code> 的范围之外，选择 <code>Application Context</code> 能够很简单地避免内存泄漏，减少很多考虑。</li>
<li>最重要的一点，确保不要将短暂存在的 <code>Context</code> 传递给长时间存在的对象，比如将 <code>Activity Context</code> 传给一个长时间在后台运行的 <code>Service</code>。</li>
</ol>
<br />



<h1 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h1><ul>
<li><a href="https://developer.android.com/reference/android/content/Context#getApplicationContext()">Context - Android</a></li>
<li><a href="https://developer.android.com/reference/android/app/Application">Application - Android</a></li>
<li><a href="https://developer.android.com/reference/android/app/Activity">Activity - Android</a></li>
<li><a href="https://developer.android.com/reference/android/view/View">View - Android</a></li>
<li><a href="https://developer.android.com/guide/components/fundamentals">应用基础知识 - Android</a></li>
<li><a href="https://github.com/codepath/android_guides/wiki/Understanding-the-Android-Application-Class">Understanding the Android Application Class - CodePath</a></li>
<li><a href="https://www.zhihu.com/question/34007989">Android 中用 getApplicationContext() 会不会避免某些内存泄漏问题 - ZhiHu</a> </li>
<li><a href="https://zhuanlan.zhihu.com/p/27163977">如何理解Context? - ZhiHu</a></li>
<li><a href="https://medium.com/@ali.muzaffar/which-context-should-i-use-in-android-e3133d00772c">Which Context should I use in Android? - Medium</a></li>
<li><a href="https://blog.mindorks.com/understanding-context-in-android-application-330913e32514">Understanding Context In Android Application - Mindorks</a></li>
<li><a href="https://www.freecodecamp.org/news/mastering-android-context-7055c8478a22/">Mastering Android context - FreeCodeCamp</a></li>
<li><a href="https://guides.codepath.com/android/Using-Context#avoiding-memory-leaks">Using Context - CodePath</a> </li>
<li><a href="https://stackoverflow.com/questions/987072/using-application-context-everywhere">Using Application context everywhere? - StackOverFlow</a></li>
<li><a href="https://stackoverflow.com/questions/9605459/android-why-must-use-getbasecontext-instead-of-this">Android: why must use getBaseContext() instead of this</a></li>
</ul>
<br />





<p><strong>以上！</strong></p>
<br />]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Context</tag>
        <tag>Application</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title>避免访问 Google 时出现的人机验证 reCaptcha</title>
    <url>/Experience/avoid-recaptcha-of-google/</url>
    <content><![CDATA[<p><strong>简述</strong>：<code>DigitalOcean</code>也许资格太老，福利太好，被人滥用，导致现在开出<code>VPS</code>的<code>IP</code>可能存在问题。具体表现为，每次清空<code>cookie</code>，再次使用<code>Google</code>或<code>Youtube</code>就会出现人机验证<code>reCaptcha</code>。</p>
<span id="more"></span>
<br />

<h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1 问题"></a>1 问题</h1><p>　　我也用过好几家云服务商的<code>VPS</code>，诸如<code>DigitalOcean</code>、<code>VirMach</code>、<code>Free-www</code>、<code>CenterHop</code>等。</p>
<p>　　对于我，至今出现<code>Google</code>的人机验证<code>reCaptcha</code>这问题，都是在使用<code>DO</code>家<code>VPS</code>搭建的扶墙服务的情况下。很显然，<code>DO</code>家的<code>IP</code>因为<code>VPS</code>被滥用，问题挺大的。</p>
<p><img src="https://res.cloudinary.com/hexo-pics/image/upload/v1529297410/hexo-2018/06/recaptcha.gif" alt="reCpatcha"></p>
<p>　　这个人机验证是真的烦。</p>
<br />

<h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2 解决办法"></a>2 解决办法</h1><p>　　在通过如<code>V2ray</code>使用<code>Google</code>时，如果出现验证码，那么页面下方会告知此时访问<code>Google</code>的<code>IP</code>地址，你就能看到具体是<code>IPv4</code>被封还是<code>IPv6</code>被封啦。</p>
<h2 id="禁用IPv6"><a href="#禁用IPv6" class="headerlink" title="禁用IPv6"></a>禁用IPv6</h2><p>　　如果是<code>IPv6</code>地址存在问题，那就禁用<code>IPv6</code>，只使用<code>IPv4</code>访问网络。</p>
<p>　　编辑<code>/etc/sysctl.conf</code>，在文件末尾加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># disable ipv6</span><br><span class="line">net.ipv6.conf.all.disable_ipv6=1</span><br><span class="line">net.ipv6.conf.default.disable_ipv6=1</span><br><span class="line">net.ipv6.conf.lo.disable_ipv6=1</span><br></pre></td></tr></table></figure>

<h2 id="强制IPv4"><a href="#强制IPv4" class="headerlink" title="强制IPv4"></a>强制IPv4</h2><p>　　如果是<code>IPv4</code>地址存在问题，那就只使用<code>IPv6</code>访问网络。当然，鉴于国内目前除了教育网，<code>IPv6</code>协议尚未普及，所以这种情况可能就比较尴尬了。</p>
<p>　　方法是，在<code>VPS</code>的<code>hosts</code>文件中，指定<code>Google</code>等的<code>IPv6</code>地址。编辑<code>/etc/hosts</code>，加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2607:f8b0:4005:801::200e google.com</span><br><span class="line">2607:f8b0:4005:801::200e www.google.com</span><br><span class="line">2607:f8b0:4007:805::100f scholar.google.cn</span><br><span class="line">2607:f8b0:4007:805::100f scholar.google.com</span><br><span class="line">2607:f8b0:4007:805::100f scholar.google.com.hk</span><br><span class="line">2607:f8b0:4007:805::100f scholar.l.google.com</span><br></pre></td></tr></table></figure>

<p>如上<code>IPv6</code>地址可能已失效，请参考<a href="https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/hosts">lennylxx/ipv6-hosts</a>中提供的最新IPv6地址。</p>
<h1 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h1><ul>
<li><a href="https://www.polarxiong.com/archives/%E9%80%9A%E8%BF%87VPS%E4%BD%BF%E7%94%A8VPN%E6%88%96ShadowSocks%E8%AE%BF%E9%97%AEGoogle%E6%88%96Google-Schoolar%E5%87%BA%E7%8E%B0%E9%AA%8C%E8%AF%81%E7%A0%81%E7%AD%89%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html">通过VPS使用VPN或ShadowSocks访问Google或Google Schoolar出现验证码等的解决方法</a></li>
</ul>
<br />
**以上！**
<br />]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>google</tag>
        <tag>recaptcha</tag>
        <tag>proxy</tag>
        <tag>vps</tag>
        <tag>digitalocean</tag>
      </tags>
  </entry>
  <entry>
    <title>「SQL」2. SQL格式规范、基本命令与范例</title>
    <url>/SQL/basic-instructions-of-sql/</url>
    <content><![CDATA[<p><strong>简述</strong>：这里只记录<code>SQL</code>的部分基本指令，包括<code>SELECT FROM</code>，<code>WHERE</code>，<code>GROUP BY</code>，<code>ORDER BY</code>。</p>
<span id="more"></span>

<br />

<h1 id="1-SQL要点"><a href="#1-SQL要点" class="headerlink" title="1 SQL要点"></a>1 SQL要点</h1><h2 id="1-1-注释"><a href="#1-1-注释" class="headerlink" title="1.1 注释"></a>1.1 注释</h2><p><code>SQL</code>语句中的单行注释使用<code>--</code>，多行注释采用<code> /*…*/</code></p>
<h2 id="1-2-代码规范"><a href="#1-2-代码规范" class="headerlink" title="1.2 代码规范"></a>1.2 代码规范</h2><p>   <a href="https://zhuanlan.zhihu.com/p/27466166">SQL编程格式的优化建议</a><br>   <a href="https://www.dsqlstyle.guide/">SQL Style Guide</a></p>
<h2 id="1-3-执行顺序"><a href="#1-3-执行顺序" class="headerlink" title="1.3 执行顺序"></a>1.3 执行顺序</h2><p><code>SQL</code> 语句有一个让大部分人都感到困惑的特性，就是：<code>SQL</code> 语句的执行顺序跟其语句的语法顺序并不一致。<code>SQL</code> 语句的语法顺序是：</p>
<ul>
<li><code>SELECT[DISTINCT]</code></li>
<li><code>FROM</code></li>
<li><code>WHERE</code></li>
<li><code>GROUP BY</code></li>
<li><code>HAVING</code></li>
<li><code>UNION</code></li>
<li><code>ORDER BY</code></li>
</ul>
<p>为了方便理解，上面并没有把所有的 <code>SQL</code> 语法结构都列出来，但是已经足以说明 <code>SQL</code> 语句的语法顺序和其执行顺序完全不一样，就以上述语句为例，其执行顺序为：</p>
<ul>
<li><code>FROM</code></li>
<li><code>WHERE</code></li>
<li><code>GROUP BY</code></li>
<li><code>HAVING</code></li>
<li><code>SELECT</code></li>
<li><code>DISTINCT</code></li>
<li><code>UNION</code></li>
<li><code>ORDER BY</code></li>
</ul>
<p>​    摘自：<a href="http://blog.jobbole.com/55086/">十步完全理解 SQL</a></p>
<br />

<h1 id="2-查询语句-SELECT-FROM"><a href="#2-查询语句-SELECT-FROM" class="headerlink" title="2 查询语句 SELECT FROM"></a>2 查询语句 SELECT FROM</h1><h2 id="2-1-语句解释"><a href="#2-1-语句解释" class="headerlink" title="2.1 语句解释"></a>2.1 语句解释</h2><p>从表中选择数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    attribute_name, ...</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    table_name</span><br></pre></td></tr></table></figure>
<h2 id="2-2-查重语句"><a href="#2-2-查重语句" class="headerlink" title="2.2 查重语句"></a>2.2 查重语句</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    attribute_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    table_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    attribute_name</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">    <span class="built_in">COUNT</span>(attribute_name) <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-前-N-个语句"><a href="#2-3-前-N-个语句" class="headerlink" title="2.3 前 N 个语句"></a>2.3 前 N 个语句</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> </span><br><span class="line">    attribute_name <span class="keyword">DESC</span></span><br><span class="line">LIMIT </span><br><span class="line">    n </span><br><span class="line"><span class="keyword">OFFSET</span> </span><br><span class="line">    n</span><br></pre></td></tr></table></figure>

<h2 id="2-4-CASE…END-判断语句"><a href="#2-4-CASE…END-判断语句" class="headerlink" title="2.4 CASE…END 判断语句"></a>2.4 CASE…END 判断语句</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span> </span><br><span class="line">    <span class="keyword">WHEN</span> 条件<span class="number">1</span> <span class="keyword">THEN</span> 结果<span class="number">1</span></span><br><span class="line">    <span class="keyword">WHEN</span> 条件<span class="number">2</span> <span class="keyword">THEN</span> 结果<span class="number">2</span></span><br><span class="line">    <span class="keyword">WHEN</span> 条件<span class="number">3</span> <span class="keyword">THEN</span> 结果<span class="number">3</span></span><br><span class="line">    .........</span><br><span class="line">    <span class="keyword">WHEN</span> 条件N <span class="keyword">THEN</span> 结果N</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<br />

<h1 id="3-筛选语句-WHERE"><a href="#3-筛选语句-WHERE" class="headerlink" title="3 筛选语句 WHERE"></a>3 筛选语句 WHERE</h1><h2 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    attribute_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    table_name</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    attribute_name operator <span class="keyword">value</span></span><br></pre></td></tr></table></figure>
<p>属性名不要求相同。</p>
<h2 id="3-2-运算符-通配符-操作符"><a href="#3-2-运算符-通配符-操作符" class="headerlink" title="3.2 运算符/通配符/操作符"></a>3.2 运算符/通配符/操作符</h2><table>
<thead>
<tr>
<th align="left">operator</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">=</td>
<td align="left">等于</td>
</tr>
<tr>
<td align="left">&lt;&gt;</td>
<td align="left">不等于</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">大于</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">小于</td>
</tr>
<tr>
<td align="left">&gt;=</td>
<td align="left">大于等于</td>
</tr>
<tr>
<td align="left">&lt;=</td>
<td align="left">小于等于</td>
</tr>
<tr>
<td align="left">BETWEEN</td>
<td align="left">在某个范围内</td>
</tr>
<tr>
<td align="left">LIKE</td>
<td align="left">搜索某种模式</td>
</tr>
<tr>
<td align="left"><br /></td>
<td align="left"></td>
</tr>
</tbody></table>
<h1 id="4-分组语句-GROUP-BY"><a href="#4-分组语句-GROUP-BY" class="headerlink" title="4 分组语句 GROUP BY"></a>4 分组语句 GROUP BY</h1><h2 id="4-1-语句解释"><a href="#4-1-语句解释" class="headerlink" title="4.1 语句解释"></a>4.1 语句解释</h2><p><code>GROUP BY</code>语句根据一个或多个列对结果集进行分组。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    attribute_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    table_name</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    attribute_name operator <span class="keyword">value</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">    attribute_name</span><br></pre></td></tr></table></figure>
<p>属性名不要求相同。</p>
<br />

<h2 id="4-2-HAVING子句"><a href="#4-2-HAVING子句" class="headerlink" title="4.2 HAVING子句"></a>4.2 HAVING子句</h2><p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。<br>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    attribute_name, aggregate_function(attribute_name)</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    table_name</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    attribute_name operator <span class="keyword">value</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">    attribute_name</span><br><span class="line"><span class="keyword">HAVING</span> </span><br><span class="line">    aggregate_function(attribute_name) operator <span class="keyword">value</span></span><br></pre></td></tr></table></figure>
<br />

<h1 id="5-排序语句-ORDER-BY"><a href="#5-排序语句-ORDER-BY" class="headerlink" title="5 排序语句 ORDER BY"></a>5 排序语句 ORDER BY</h1><p><code>ORDER BY</code>语句用于根据指定的列对结果集进行排序。默认按照升序，添加<code>DESC</code>关键字可改成降序。</p>
<h2 id="5-1-正序、逆序"><a href="#5-1-正序、逆序" class="headerlink" title="5.1 正序、逆序"></a>5.1 正序、逆序</h2><p><code>SQL</code>默认按照升序（<code>ASC</code>），添加<code>DESC</code>关键字可改成降序。</p>
<br />

<h1 id="6-简单实操"><a href="#6-简单实操" class="headerlink" title="6 简单实操"></a>6 简单实操</h1><h2 id="6-1-查找重复的电子邮箱（难度：简单）"><a href="#6-1-查找重复的电子邮箱（难度：简单）" class="headerlink" title="6.1 查找重复的电子邮箱（难度：简单）"></a>6.1 查找重复的电子邮箱（难度：简单）</h2><ol>
<li>创建表，表名 <code>accounts</code>，再添加 <code>records</code>。 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> email (</span><br><span class="line">ID <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">Email <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> email <span class="keyword">VALUES</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;a@b.com&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> email <span class="keyword">VALUES</span>(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;c@d.com&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> email <span class="keyword">VALUES</span>(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;a@b.com&#x27;</span>);</span><br></pre></td></tr></table></figure>
 Yeah，这就成了。<br> <img src="https://img-blog.csdnimg.cn/2019040219403986.png" alt="在这里插入图片描述"></li>
<li>查重 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    Email </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    accounts</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    Email</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">    <span class="built_in">COUNT</span>(Email)<span class="operator">&gt;</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
 查找结果：<br> <img src="https://img-blog.csdnimg.cn/20190402194001508.png" alt="在这里插入图片描述"></li>
</ol>
<br />

<h2 id="6-2-查找大国"><a href="#6-2-查找大国" class="headerlink" title="6.2 查找大国"></a>6.2 查找大国</h2><ol>
<li>建表，表名 <code>world</code>，再添加 <code>records</code> 。 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> World (</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">continent <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">area <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">population <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">gdp <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> World</span><br><span class="line">  <span class="keyword">VALUES</span>(<span class="string">&#x27;Afghanistan&#x27;</span>,<span class="string">&#x27;Asia&#x27;</span>,<span class="number">652230</span>,<span class="number">25500100</span>,<span class="number">20343000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> World </span><br><span class="line">  <span class="keyword">VALUES</span>(<span class="string">&#x27;Albania&#x27;</span>,<span class="string">&#x27;Europe&#x27;</span>,<span class="number">28748</span>,<span class="number">2831741</span>,<span class="number">12960000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> World </span><br><span class="line">  <span class="keyword">VALUES</span>(<span class="string">&#x27;Algeria&#x27;</span>,<span class="string">&#x27;Africa&#x27;</span>,<span class="number">2381741</span>,<span class="number">37100000</span>,<span class="number">188681000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> World</span><br><span class="line">  <span class="keyword">VALUES</span>(<span class="string">&#x27;Andorra&#x27;</span>,<span class="string">&#x27;Europe&#x27;</span>,<span class="number">468</span>,<span class="number">78115</span>,<span class="number">3712000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> World</span><br><span class="line">  <span class="keyword">VALUES</span>(<span class="string">&#x27;Angola&#x27;</span>,<span class="string">&#x27;Africa&#x27;</span>,<span class="number">1246700</span>,<span class="number">20609294</span>,<span class="number">100990000</span>);</span><br></pre></td></tr></table></figure></li>
<li>查找大国（条件：国家的面积超过300万平方公里，或者(人口超过2500万并且 <code>gdp</code> 超过2000万)） <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name, population, area</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    world</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    area <span class="operator">&gt;</span> <span class="number">3000000</span> <span class="keyword">OR</span> (population <span class="operator">&gt;</span> <span class="number">25000000</span> <span class="keyword">and</span> GDP <span class="operator">&gt;</span> <span class="number">20000000</span>);</span><br></pre></td></tr></table></figure>
 Here we go!<br> <img src="https://img-blog.csdnimg.cn/20190402194829347.png" alt="在这里插入图片描述"></li>
</ol>
<br />

<h1 id="7系列"><a href="#7系列" class="headerlink" title="7系列"></a>7系列</h1><ol>
<li><a href="/SQL/installation-and-simple-instructions-of-sql/" title="「SQL」1. 安装 MySQL">「SQL」1. 安装 MySQL</a></li>
<li><a href="/SQL/basic-instructions-of-sql/" title="「SQL」2. SQL格式规范、基本命令与范例">「SQL」2. SQL格式规范、基本命令与范例</a> </li>
<li><a href="/SQL/data-types-of-MySQL/" title="「SQL」3. MySQL 的数据类型">「SQL」3. MySQL 的数据类型</a></li>
</ol>
<br />

<p><strong>以上！</strong></p>
<br />

]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>MySQL</tag>
        <tag>instructions</tag>
      </tags>
  </entry>
  <entry>
    <title>「TensorFlow」2. 编译 TensorFlow C++</title>
    <url>/TensorFlow/build-tensorflow-cpp/</url>
    <content><![CDATA[<p><strong>简述</strong>：编译 <code>TensorFlow C++</code> 很费劲，需要一颗向死之心。虽然成功编译已经是半个月前的事，但我拖到现在才整理成稿。</p>
<span id="more"></span>

<br />



<p>系统环境：</p>
<ul>
<li><code>OS</code>：<code>Ubuntu 14.04.6 LTS x64 (trusty)</code></li>
<li><code>RAM</code>：<code>64 GB</code></li>
<li><code>GPU</code>：<code>NVIDIA GTX TITAN x 4</code></li>
<li><code>CUDA Toolkit</code>：10.0</li>
<li><code>cuDNN</code>：7.4.2</li>
</ul>
<p>安装版本：</p>
<ul>
<li><code>bazel</code>：0.21.0</li>
<li><code>TensorFlow</code>：1.13.1</li>
</ul>
<br />



<h1 id="1-安装-bazel"><a href="#1-安装-bazel" class="headerlink" title="1 安装 bazel"></a>1 安装 bazel</h1><p>幸好 <code>bazel 0.21.0</code>  支持 <code>Ubuntu 14.04</code> ，不然就只能砸电脑了，虽然没钱赔！</p>
<p><a href="https://docs.bazel.build/versions/0.21.0/install-ubuntu.html">官方步骤</a>：</p>
<ol>
<li><p>安装依赖： <code>pkg-config</code>, <code>zip</code>, <code>g++</code>, <code>zlib1g-dev</code>, <code>unzip</code>, 和 <code>python</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install pkg-config zip g++ zlib1g-dev unzip python</span><br></pre></td></tr></table></figure></li>
<li><p>下载安装脚本，这是<a href="https://github.com/bazelbuild/bazel/releases">bazel 发布页面</a>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /tmp</span><br><span class="line">$ wget https://github.com/bazelbuild/bazel/releases/download/0.21.0/bazel-0.21.0-installer-linux-x86_64.sh</span><br></pre></td></tr></table></figure></li>
<li><p>运行脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chmod +x bazel-0.21.0-installer-linux-x86_64.sh</span><br><span class="line">$ ./bazel-0.21.0-installer-linux-x86_64.sh --user</span><br></pre></td></tr></table></figure>

<p>使用 <code>--user</code> 会将 <code>bazel</code> 安装在 <code>$HOME/bin</code> 路径下，并将配置文件 <code>.bazelrc</code> 设置在 <code>$HOME</code> 路径下。</p>
</li>
<li><p>配置环境变量</p>
<p>如果你有使用 <code>--user</code>，则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;# bazel path</span></span><br><span class="line"><span class="string">export PATH=&quot;</span><span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin<span class="string">&quot;&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line">$ <span class="built_in">source</span> ~/.bashrc       </span><br></pre></td></tr></table></figure>

<p>官方教程只设置了临时环境变量，但我习惯一步到位。</p>
</li>
<li><p>验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bazel version</span><br><span class="line">WARNING: --batch mode is deprecated. Please instead explicitly shut down your Bazel server using the <span class="built_in">command</span> <span class="string">&quot;bazel shutdown&quot;</span>.</span><br><span class="line">INFO: Invocation ID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</span><br><span class="line">Build label: 0.21.0</span><br><span class="line">..................................................</span><br></pre></td></tr></table></figure></li>
</ol>
<br />



<h1 id="2-环境初始化"><a href="#2-环境初始化" class="headerlink" title="2 环境初始化"></a>2 环境初始化</h1><ol>
<li><p>拉取 TensorFlow</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir ~/Programs</span><br><span class="line">$ <span class="built_in">cd</span> Programs/</span><br><span class="line">$ git <span class="built_in">clone</span> -b r1.13 https://github.com/tensorflow/tensorflow.git TensorFlow/</span><br></pre></td></tr></table></figure></li>
<li><p>运行环境初始化脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> TensorFlow/tensorflow/contrib/makefile</span><br><span class="line">$ chmod +x build_all_linux.sh</span><br><span class="line">$ ./build_all_linux.sh</span><br></pre></td></tr></table></figure></li>
</ol>
<br />



<h1 id="3-编译-TensorFlow"><a href="#3-编译-TensorFlow" class="headerlink" title="3 编译 TensorFlow"></a>3 编译 TensorFlow</h1><ol>
<li><p>配置编译要求</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/Programs/TensorFlow</span><br><span class="line">$ ./configure</span><br><span class="line">WARNING: Duplicate rc file: /home/ttt/Programs/tensorflow-r1.13-4/.tf_configure.bazelrc is <span class="built_in">read</span> multiple <span class="built_in">times</span>, most recently imported from /home/ttt/.bazelrc</span><br><span class="line">WARNING: --batch mode is deprecated. Please instead explicitly shut down your Bazel server using the <span class="built_in">command</span> <span class="string">&quot;bazel shutdown&quot;</span>.</span><br><span class="line">INFO: Invocation ID: a16de493-8f9e-46f8-96bc-0903f0e36c3b</span><br><span class="line">You have bazel 0.21.0 installed.</span><br><span class="line">Please specify the location of python. [Default is /usr/bin/python]: /home/ttt/miniconda3/bin/python</span><br><span class="line"></span><br><span class="line">Found possible Python library paths:</span><br><span class="line">  /home/ttt/miniconda3/lib/python3.6/site-packages</span><br><span class="line">Please input the desired Python library path to use.  Default is [/home/ttt/miniconda3/lib/python3.6/site-packages]</span><br><span class="line"></span><br><span class="line">Do you wish to build TensorFlow with XLA JIT support? [Y/n]: y</span><br><span class="line">XLA JIT support will be enabled <span class="keyword">for</span> TensorFlow.</span><br><span class="line"></span><br><span class="line">Do you wish to build TensorFlow with OpenCL SYCL support? [y/N]: n</span><br><span class="line">No OpenCL SYCL support will be enabled <span class="keyword">for</span> TensorFlow.</span><br><span class="line"></span><br><span class="line">Do you wish to build TensorFlow with ROCm support? [y/N]: n</span><br><span class="line">No ROCm support will be enabled <span class="keyword">for</span> TensorFlow.</span><br><span class="line"></span><br><span class="line">Do you wish to build TensorFlow with CUDA support? [y/N]: y</span><br><span class="line">CUDA support will be enabled <span class="keyword">for</span> TensorFlow.</span><br><span class="line"></span><br><span class="line">Please specify the CUDA SDK version you want to use. [Leave empty to default to CUDA 10.0]: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Please specify the location <span class="built_in">where</span> CUDA 10.0 toolkit is installed. Refer to README.md <span class="keyword">for</span> more details. [Default is /usr/<span class="built_in">local</span>/cuda]: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Please specify the cuDNN version you want to use. [Leave empty to default to cuDNN 7]: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Please specify the location <span class="built_in">where</span> cuDNN 7 library is installed. Refer to README.md <span class="keyword">for</span> more details. [Default is /usr/<span class="built_in">local</span>/cuda]: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Do you wish to build TensorFlow with TensorRT support? [y/N]: n</span><br><span class="line">No TensorRT support will be enabled <span class="keyword">for</span> TensorFlow.</span><br><span class="line"></span><br><span class="line">Please specify the locally installed NCCL version you want to use. [Default is to use https://github.com/nvidia/nccl]: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Please specify a list of comma-separated Cuda compute capabilities you want to build with.</span><br><span class="line">You can find the compute capability of your device at: https://developer.nvidia.com/cuda-gpus.</span><br><span class="line">Please note that each additional compute capability significantly increases your build time and binary size. [Default is: 6.1,6.1,6.1,6.1]: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Do you want to use clang as CUDA compiler? [y/N]: n</span><br><span class="line">nvcc will be used as CUDA compiler.</span><br><span class="line"></span><br><span class="line">Please specify <span class="built_in">which</span> gcc should be used by nvcc as the host compiler. [Default is /usr/bin/gcc]: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Do you wish to build TensorFlow with MPI support? [y/N]: n</span><br><span class="line">No MPI support will be enabled <span class="keyword">for</span> TensorFlow.</span><br><span class="line"></span><br><span class="line">Please specify optimization flags to use during compilation when bazel option <span class="string">&quot;--config=opt&quot;</span> is specified [Default is -march=native -Wno-sign-compare]: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Would you like to interactively configure ./WORKSPACE <span class="keyword">for</span> Android builds? [y/N]: n</span><br><span class="line">Not configuring the WORKSPACE <span class="keyword">for</span> Android builds.</span><br><span class="line"></span><br><span class="line">Preconfigured Bazel build configs. You can use any of the below by adding <span class="string">&quot;--config=&lt;&gt;&quot;</span> to your build <span class="built_in">command</span>. See .bazelrc <span class="keyword">for</span> more details.</span><br><span class="line">	--config=mkl         	<span class="comment"># Build with MKL support.</span></span><br><span class="line">	--config=monolithic  	<span class="comment"># Config for mostly static monolithic build.</span></span><br><span class="line">	--config=gdr         	<span class="comment"># Build with GDR support.</span></span><br><span class="line">	--config=verbs       	<span class="comment"># Build with libverbs support.</span></span><br><span class="line">	--config=ngraph      	<span class="comment"># Build with Intel nGraph support.</span></span><br><span class="line">	--config=dynamic_kernels	<span class="comment"># (Experimental) Build kernels into separate shared objects.</span></span><br><span class="line">Preconfigured Bazel build configs to DISABLE default on features:</span><br><span class="line">	--config=noaws       	<span class="comment"># Disable AWS S3 filesystem support.</span></span><br><span class="line">	--config=nogcp       	<span class="comment"># Disable GCP support.</span></span><br><span class="line">	--config=nohdfs      	<span class="comment"># Disable HDFS support.</span></span><br><span class="line">	--config=noignite    	<span class="comment"># Disable Apacha Ignite support.</span></span><br><span class="line">	--config=nokafka     	<span class="comment"># Disable Apache Kafka support.</span></span><br><span class="line">	--config=nonccl      	<span class="comment"># Disable NVIDIA NCCL support.</span></span><br><span class="line">Configuration finished</span><br></pre></td></tr></table></figure></li>
<li><p>编译 <code>TensorFlow C++</code> 库</p>
<ul>
<li><p><code>CPU</code> 版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bazel build --config=opt //tensorflow:libtensorflow_cc.so</span><br></pre></td></tr></table></figure></li>
<li><p><code>GPU</code> 版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bazel build --config=opt --config=cuda //tensorflow:libtensorflow_cc.so</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<br />



<h1 id="4-测试环境"><a href="#4-测试环境" class="headerlink" title="4 测试环境"></a>4 测试环境</h1><ol>
<li><p>新建目录及文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir -p ~/Projects/demo</span><br><span class="line">$ <span class="built_in">cd</span> ~/Projects/demo</span><br><span class="line">$ mkdir build src</span><br><span class="line">$ touch CMakeLists.txt src/main.cpp</span><br></pre></td></tr></table></figure></li>
<li><p>编写测试代码 <code>main.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tensorflow/core/platform/env.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tensorflow/core/public/session.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tensorflow;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Session* session;</span><br><span class="line">    Status status = <span class="built_in">NewSession</span>(<span class="built_in">SessionOptions</span>(), &amp;session);</span><br><span class="line">    <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Session successfully created.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写 <code>CMakeLists.txt</code></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(PROGRAMS_DIR /home/ttt/Programs)</span><br><span class="line"><span class="keyword">set</span>(TENSORFLOW_DIR <span class="variable">$&#123;PROGRAMS_DIR&#125;</span>/TensorFlow)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;TENSORFLOW_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;TENSORFLOW_DIR&#125;</span>/bazel-genfiles)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;TENSORFLOW_DIR&#125;</span>/tensorflow/contrib/makefile/downloads/absl)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;TENSORFLOW_DIR&#125;</span>/tensorflow/contrib/makefile/downloads/eigen)</span><br><span class="line"></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;TENSORFLOW_DIR&#125;</span>/bazel-bin/tensorflow)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(demo main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(LaneNet tensorflow_cc tensorflow_framework)</span><br></pre></td></tr></table></figure></li>
<li><p>目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── build</span><br><span class="line">| </span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">|</span><br><span class="line">├── src</span><br><span class="line">| └── main.cpp</span><br></pre></td></tr></table></figure></li>
<li><p>编译并运行测试程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/Programs/demo/build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake ..</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">..................................................</span><br><span class="line">Session successfully created.</span><br></pre></td></tr></table></figure></li>
</ol>
<br />

<h1 id="5-疑难杂症"><a href="#5-疑难杂症" class="headerlink" title="5 疑难杂症"></a>5 疑难杂症</h1><ol>
<li><p><code>bazel</code> 版本问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR:/home/ttt/.cache/bazel/_bazel_ttt/12fb0bc5892f7f0d9058b186b377c0bf/external/local_config_cc/BUILD:57:1: in cc_toolchain rule @local_config_cc//:cc-compiler-k8: Error while selecting cc_toolchain: Toolchain identifier &#x27;local&#x27; was not found, valid identifiers are [local_linux, local_darwin, local_windows]</span><br></pre></td></tr></table></figure>

<p>解决办法：<code>bazel</code> 0.19.1 -&gt; 0.21.0</p>
</li>
<li><p><code>eigen</code> 版本问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/tensorflow/include/third_party/eigen3/unsupported/Eigen/CXX11/Tensor:1:42: </span><br><span class="line">fatal error: unsupported/Eigen/CXX11/Tensor: 没有那个文件或目录</span><br><span class="line"> <span class="comment">#include &quot;unsupported/Eigen/CXX11/Tensor&quot;</span></span><br></pre></td></tr></table></figure>

<p>解决办法：更新 <code>eigen</code> 至 3.3，且添加到 <code>CMakeLists.txt</code> 的搜索目录</p>
</li>
<li><p>找不到 <code>abseil-cpp</code> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/tensorflow/include/tensorflow/core/lib/core/stringpiece.h:29:38: fatal error: absl/strings/string_view.h: 没有那个文件或目录</span><br><span class="line"> <span class="comment">#include &quot;absl/strings/string_view.h&quot;</span></span><br></pre></td></tr></table></figure>

<p> 解决办法（<a href="https://www.cnblogs.com/buyizhiyou/p/10405634.html">来源</a>）：下载 <code>abseil-cpp</code> 并添加到 <code>CMakeLists.txt</code> 的搜索目录</p>
</li>
<li><p><code>CMakeLists.txt</code> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home/ttt/Programs/tensorflow-r1.13-3/tensorflow/core/framework/tensor_shape.h:22:48: fatal error: tensorflow/core/framework/types.pb.h: 没有那个文件或目录</span><br><span class="line"> <span class="comment">#include &quot;tensorflow/core/framework/types.pb.h&quot;</span></span><br></pre></td></tr></table></figure>

<p>解决办法：<code>include_directories($&#123;TENSORFLOW_DIR&#125;/bazel-genfiles)</code></p>
</li>
</ol>
<br />



<h1 id="6-参考"><a href="#6-参考" class="headerlink" title="6 参考"></a>6 参考</h1><ul>
<li><a href="https://docs.bazel.build/versions/1.1.0/install-ubuntu.html#install-on-ubuntu">Installing Bazel on Ubuntu - bazel</a></li>
<li><a href="https://blog.csdn.net/MOU_IT/article/details/87976152#5%E3%80%81%E9%85%8D%E7%BD%AETensorFlow%E7%9A%84%E4%BE%9D%E8%B5%96%EF%BC%9Aprotobuf%E5%92%8Ceigen">Ubuntu安装TensorFlow C++ - GitHub</a></li>
<li><a href="https://github.com/hemajun815/tutorial/blob/master/tensorflow/compilling-tensorflow-source-code-into-C%2B%2B-library-file.md#%E6%96%B9%E5%BC%8F%E4%BA%8C">将Tensorflow源码编译成C++库文件 - hemajun815</a></li>
<li><a href="http://www.liuxiao.org/2018/08/ubuntu-tensorflow-c-%E4%BB%8E%E8%AE%AD%E7%BB%83%E5%88%B0%E9%A2%84%E6%B5%8B1%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">Tensorflow C++ 从训练到部署(1)：环境搭建</a></li>
<li><a href="https://medium.com/@tomdeore/standalone-c-build-tensorflow-opencv-6dc9d8a1412d">Standalone C++ Build — TF + OpenCV - Medium</a></li>
<li><a href="https://medium.com/@fanzongshaoxing/use-tensorflow-c-api-with-opencv3-bacb83ca5683">Use TensorFlow C++ API with OpenCV3 - Medium</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1006107">Tensorflow c++ 实践及各种坑</a></li>
</ul>
<br />



<h1 id="7-系列"><a href="#7-系列" class="headerlink" title="7 系列"></a>7 系列</h1><ol>
<li><a href="/TensorFlow/installation-of-cuda-toolkit-and-cudnn/" title="「TensorFlow」1. 安装 CUDA 和 cuDNN">「TensorFlow」1. 安装 CUDA 和 cuDNN</a></li>
<li><a href="/TensorFlow/build-tensorflow-cpp/" title="「TensorFlow」2. 编译 TensorFlow C++">「TensorFlow」2. 编译 TensorFlow C++</a></li>
</ol>
<br />

<p><strong>以上！</strong></p>
<br />]]></content>
      <categories>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
        <tag>bazel</tag>
        <tag>build</tag>
        <tag>manual</tag>
      </tags>
  </entry>
  <entry>
    <title>「PyQt5」1. QtWidgets 模块中 Class 的通用函数/方法</title>
    <url>/Python/PyQt5/common-methods-of-pyqt/</url>
    <content><![CDATA[<p><strong>简述</strong>：<code>PyQt5</code> 是 <code>Python</code> 和 <code>Qt</code> 库的融合，用来开发 GUI 应用程序。本文记录了一些 <code>PyQt5.QtWidgets</code> 中部分 <code>Class</code> 的少数函数/方法。</p>
<span id="more"></span>
<br />

<h1 id="1-学习文档"><a href="#1-学习文档" class="headerlink" title="1 学习文档"></a>1 学习文档</h1><ul>
<li><a href="http://code.py40.com/pyqt5/14.html">PyQt5中文教程</a>：这是<a href="https://pythonspot.com/en/pyqt5/">PyQt5 Tutorials</a>的翻译，可用于入门。但只是初级的教程，而且使用的图床大概是QQ相册，许多图片无法显示。</li>
<li><a href="https://doc.qt.io/qtforpython/index.html">Qt for Python</a>: 顾名思义，这是Python的PyQt5官方文档，但对于类的函数或方法的解释太简单，有些鸡肋。</li>
<li><a href="https://doc.qt.io/qt-5/qtmodules.html">Qt Documentation for C++</a>：这是用于C++的PyQt5.11文档，文字解释很具体，但并不能直接应用于Python。</li>
</ul>
<br />

<h1 id="2-QtWidgets"><a href="#2-QtWidgets" class="headerlink" title="2 QtWidgets"></a>2 QtWidgets</h1><p>　　<code>QtWidgets</code>模块提供了一套创造经典桌面风格的用户界面的<code>UI Class</code>，包含有：</p>
<ul>
<li><code>QWidget</code>：</li>
<li><code>QPushButton</code>：按键</li>
<li><code>QComboBox</code>：多选框</li>
<li><code>QLabel</code>：标签</li>
<li><code>QLineEdit</code>、<code>QTextEdit</code>：单行文本框和多行文本框</li>
<li>……</li>
</ul>
<h2 id="2-1-控件Text"><a href="#2-1-控件Text" class="headerlink" title="2.1 控件Text"></a>2.1 控件Text</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;CONTORL_NAME&gt;.setText(<span class="string">&#x27;...&#x27;</span>)  <span class="comment"># 设置控件Text</span></span><br><span class="line">text = &lt;CONTORL_NAME&gt;.Text()   <span class="comment"># 提取控件Text</span></span><br></pre></td></tr></table></figure>

<p>　　<code>&lt;CONTROL_NAME&gt;</code>指的是控件<code>Class</code>的<code>Instance</code>名。</p>
<h2 id="2-2-控件可用性"><a href="#2-2-控件可用性" class="headerlink" title="2.2 控件可用性"></a>2.2 控件可用性</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;CONTROL_NAME&gt;.setEnabled(<span class="literal">True</span>)</span><br><span class="line">&lt;CONTROL_NAME&gt;.setEnabled(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-3-Text在控件中的位置"><a href="#2-3-Text在控件中的位置" class="headerlink" title="2.3 Text在控件中的位置"></a>2.3 Text在控件中的位置</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> Qt</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">window</span>(<span class="params">QWidget</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initUI</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.lbl = QLabel()</span><br><span class="line">        <span class="built_in">set</span>.lbl.setAlignment(Qt.AlignCenter)</span><br><span class="line">        <span class="comment"># or set.lbl.setStyleSheet(&quot;qproperty-alignment: &#x27;AlignCenter&#x27;;&quot;)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>　　以<code>QLabel</code>为例，方法<code>setAlignment</code>的参数可以有：</p>
<ul>
<li><code>Qt.AlignLeft</code></li>
<li><code>Qt.AlignCenter</code></li>
<li><code>Qt.AlignRight</code></li>
<li><code>Qt.AlignTop</code>：顶部</li>
<li><code>Qt.AlignBottom</code>：底部</li>
<li>……</li>
</ul>
<br />
**以上！**
<br />

  

  

  

  

  

]]></content>
      <categories>
        <category>Python</category>
        <category>PyQt5</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pyqt5</tag>
        <tag>common methods</tag>
        <tag>gui</tag>
      </tags>
  </entry>
  <entry>
    <title>「Hexo」Hexo 开启阅读计数功能</title>
    <url>/Manual/counting-function-of-hexo/</url>
    <content><![CDATA[<p><strong>简述</strong>：本文简练描述 <code>Hexo</code> 博客如何开启自带的阅读计数功能。</p>
<span id="more"></span>
<br />

<h1 id="1-leancloud配置"><a href="#1-leancloud配置" class="headerlink" title="1 leancloud配置"></a>1 leancloud配置</h1><h2 id="1-1-第一步"><a href="#1-1-第一步" class="headerlink" title="1.1 第一步"></a>1.1 第一步</h2><p>先注册。</p>
<h2 id="1-2-第二步"><a href="#1-2-第二步" class="headerlink" title="1.2 第二步"></a>1.2 第二步</h2><p>创建应用，名字随意，计价方案为<strong>开发版</strong>。<br><img src="https://res.cloudinary.com/hexo-pics/image/upload/v1536494010/hexo-2018/09/create_app.png" alt="create an app"></p>
<h2 id="1-3-第三步"><a href="#1-3-第三步" class="headerlink" title="1.3 第三步"></a>1.3 第三步</h2><p>创建Class，名字<strong>必须</strong>为<code>Counter</code>，默认ACL权限设置为<strong>无限制</strong>。<br><img src="https://res.cloudinary.com/hexo-pics/image/upload/v1536494010/hexo-2018/09/create_class.png" alt="create a class"></p>
<h2 id="1-4-第四步"><a href="#1-4-第四步" class="headerlink" title="1.4 第四步"></a>1.4 第四步</h2><p>在<strong>设置</strong>中获取<code>appid</code>和<code>appkey</code>，之后跳到**<a href="#conf">NexT配置</a>**。<br><img src="https://res.cloudinary.com/hexo-pics/image/upload/v1536494010/hexo-2018/09/app_id_and_key.png" alt="appid and appkey"></p>
<br />

<h1 id="2-NexT配置"><a href="#2-NexT配置" class="headerlink" title="2 NexT配置"></a>2 NexT配置</h1><p>打开<code>NexT</code>主题目录下的<code>_config.yml</code>，找到<code>leancloud_visitors</code>位置，并如下修改之。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show number of visitors to each article.</span></span><br><span class="line"><span class="comment"># You can visit https://leancloud.cn get AppID and AppKey.</span></span><br><span class="line"><span class="attr">leancloud_visitors:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">app_id:</span> <span class="string">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span> <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line">  <span class="attr">app_key:</span> <span class="string">xxxxxxxxxxxxxxxxxxxxxxxxxxxx</span> <span class="comment">#&lt;app_key&gt;</span></span><br><span class="line">  <span class="comment"># Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security</span></span><br><span class="line">  <span class="comment"># If you don&#x27;t care about security in lc counter and just want to use it directly</span></span><br><span class="line">  <span class="comment"># (without hexo-leancloud-counter-security plugin), set the `security` to `false`.</span></span><br><span class="line">  <span class="attr">security:</span> <span class="literal">false</span>  <span class="comment"># 如果设置了web安全域名，此处须改为 true。</span></span><br><span class="line">  <span class="attr">betterPerformance:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<br />

<h1 id="3-设置web安全域名（非必须）"><a href="#3-设置web安全域名（非必须）" class="headerlink" title="3 设置web安全域名（非必须）"></a>3 设置web安全域名（非必须）</h1><p>在<code>设置-&gt;安全中心</code>中，<code>web安全域名</code>处填写博客域名。<br><img src="https://res.cloudinary.com/hexo-pics/image/upload/v1536494010/hexo-2018/09/web_secure_domain.png" alt="web secure domain"></p>
<p>如果打开浏览器调试模式（<code>F12</code>），出现<code>403</code>错误，则意味着域名填写出错。<br><img src="https://res.cloudinary.com/hexo-pics/image/upload/v1536495903/hexo-2018/09/broswer_403.png" alt="brower 403"></p>
<p>那就只有两个办法：</p>
<ul>
<li>死磕</li>
<li>放弃设置web安全域名</li>
</ul>
<p>我选择第二个办法，毕竟第一个办法失败了，毕竟只是个小破站。所以，在<code>NexT</code>主题的<code>_config.yml</code>中将<code>leancloud_visitors</code>的<code>security</code>设置为<code>false</code>。</p>
<br />



<p><strong>以上！</strong></p>
]]></content>
      <categories>
        <category>Manual</category>
      </categories>
      <tags>
        <tag>Hexo - counting_function -</tag>
      </tags>
  </entry>
  <entry>
    <title>「C++」数据类型 char 转化为 string</title>
    <url>/C/convert-from-char-to-string/</url>
    <content><![CDATA[<p><strong>简述</strong>：<code>C++</code>中数据类型<code>char</code>和<code>string</code>都可以存放字符，所以存在将<code>char</code>类型转化为类型<code>string</code>的需求。</p>
<span id="more"></span>
<br />

<h1 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h1><p>　　话不多说，先上代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span>  <span class="comment">//stringstream出处</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    std::string str;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line"></span><br><span class="line">    ss &lt;&lt; c;</span><br><span class="line">    str = ss.<span class="built_in">str</span>();</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这里借助<code>stringstream</code>，存储变量<code>c</code>中的值，再赋给变量<code>str</code>，完成转化。</p>
<p>　　以上！</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>conversion</tag>
        <tag>char</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>「SQL」3. MySQL 的数据类型</title>
    <url>/SQL/data-types-of-MySQL/</url>
    <content><![CDATA[<p><strong>简述</strong>：<code>MySQL</code>的数据类型可以分为三类：文本、数字和日期/时间类型。</p>
<span id="more"></span>

<br />



<h1 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1 数据类型"></a>1 数据类型</h1><p>在 <code>MySQL</code> 中，有三种主要的类型：文本、数字和日期/时间类型。</p>
<h2 id="1-1-Text-类型"><a href="#1-1-Text-类型" class="headerlink" title="1.1 Text 类型"></a>1.1 Text 类型</h2><table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>CHAR(size)</code></td>
<td align="left">固定长度（可包含字母、数字以及特殊字符），<code>size</code>指字符串的长度，最大为 255。</td>
</tr>
<tr>
<td align="left"><code>VARCHAR(size)</code></td>
<td align="left">可变长度。<code>size</code>指字符串的长度，最大为 255。如果大于 255，则被转换为<code>TEXT</code>类型。</td>
</tr>
<tr>
<td align="left"><code>TINYTEXT</code></td>
<td align="left">可变长度，最多 255 个字符。</td>
</tr>
<tr>
<td align="left"><code>TEXT</code></td>
<td align="left">可变长度，最多 65,535 个字符。</td>
</tr>
<tr>
<td align="left"><code>MEDIUMTEXT</code></td>
<td align="left">可变长度，最多 16,777,215 个字符。</td>
</tr>
<tr>
<td align="left"><code>LONGTEXT</code></td>
<td align="left">可变长度，最多 4,294,967,295 个字符。</td>
</tr>
<tr>
<td align="left"><code>BLOB</code></td>
<td align="left"><code>BLOBs(Binary Large Objects)</code>，存放最多 65,535 <code>bytes</code>的数据。</td>
</tr>
<tr>
<td align="left"><code>MEDIUMBLOB</code></td>
<td align="left">存放最多 16,777,215 <code>bytes</code>的数据。</td>
</tr>
<tr>
<td align="left"><code>LONGBLOB</code></td>
<td align="left">存放最多 4,294,967,295 <code>bytes</code>的数据。</td>
</tr>
<tr>
<td align="left"><a href="https://www.yiibai.com/mysql/enum.html">ENUM(x,y,z,etc.)</a></td>
<td align="left">枚举列表，可在 <code>ENUM</code> 列表中列出最大 65535 个值（字符串）。如果列表中不存在插入的值，则插入空值。<br><strong>注释</strong>：这些值是按照输入的顺序存储的。格式：<code>ENUM(&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;)</code></td>
</tr>
</tbody></table>
<blockquote>
<p>An <code>ENUM</code> is a string object with a value chosen from a list of permitted values that are enumerated explicitly in the column specification at table creation time.</p>
</blockquote>
<h2 id="1-2-整型类型"><a href="#1-2-整型类型" class="headerlink" title="1.2 整型类型"></a>1.2 整型类型</h2><table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="center">字节数</th>
<th align="left">有符号</th>
<th>无符号</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>TINYINT</code></td>
<td align="center">1</td>
<td align="left">-128 ～127</td>
<td>0 ～ 255</td>
</tr>
<tr>
<td align="left"><code>SMALLINT</code></td>
<td align="center">2</td>
<td align="left">-32768 ～ 32767</td>
<td>0 ～ 65535</td>
</tr>
<tr>
<td align="left"><code>MEDIUMINT</code></td>
<td align="center">3</td>
<td align="left">-8388608 ～ 8388607</td>
<td>0 ～ 16777215</td>
</tr>
<tr>
<td align="left"><code>INT</code></td>
<td align="center">4</td>
<td align="left">-2147483648 ～ 2147483647</td>
<td>0 ～ 4294967295</td>
</tr>
<tr>
<td align="left"><code>BIGINT</code></td>
<td align="center">8</td>
<td align="left">-9223372036854775808 ～ 9223372036854775807</td>
<td>0 ～ 18446744073709551615</td>
</tr>
</tbody></table>
<p>整数类型拥有额外的选项 <code>UNSIGNED</code>。</p>
<h2 id="1-3-浮点数类型"><a href="#1-3-浮点数类型" class="headerlink" title="1.3 浮点数类型"></a>1.3 浮点数类型</h2><table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="center">字节数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>FLOAT(M,D)</code></td>
<td align="center">4</td>
<td align="left"><code>M</code> 代表显示长度，<code>D</code> 代表小数位数，这两个参数都不是必需参数，默认为10, 2，小数精度可以达到24位</td>
</tr>
<tr>
<td align="left"><code>DOUBLE(M,D)</code></td>
<td align="center">8</td>
<td align="left"><code>M</code>和<code>D</code>默认为16, 4，小数精度可以达到53位。</td>
</tr>
<tr>
<td align="left"><code>DECIMAL(M,D)</code></td>
<td align="center"></td>
<td align="left">作为字符串存储，是非压缩的无符号浮点数。 每一位十进制数都对应一个字节。</td>
</tr>
</tbody></table>
<p><code>DECIMAL</code> 和 <code>FLOAT</code>/<code>DOUBLE</code>的区别，主要有两点：</p>
<ul>
<li><code>FLOAT</code>/<code>DOUBLE</code>在<code>db</code>中存储的是近似值，而<code>DECIMAL</code> 则是以字符串形式进行保存的；</li>
<li><code>DECIMAL(M,D)</code>的规则和<code>FLOAT</code>/<code>DOUBLE</code>相同，但<code>FLOAT</code>/<code>DOUBLE</code>在不指定M、D时默认按照实际精度来处理,而<code>DECIMAL</code> 在不指定M、D时默认为<code>DECIMAL (10, 0)</code>。</li>
</ul>
<h2 id="1-4-Date-类型"><a href="#1-4-Date-类型" class="headerlink" title="1.4 Date 类型"></a>1.4 Date 类型</h2><table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="center">字节数</th>
<th align="center">格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>DATE()</code></td>
<td align="center">3</td>
<td align="center">YYYY-MM-DD</td>
<td>支持的范围是  1000-01-01 ~ 9999-12-31</td>
</tr>
<tr>
<td align="left"><code>TIME()</code></td>
<td align="center">3</td>
<td align="center">HH:MM:SS</td>
<td>支持的范围是  -838:59:59 ~ 838:59:59</td>
</tr>
<tr>
<td align="left"><code>YEAR()</code></td>
<td align="center">1</td>
<td align="center">YY / YYYY</td>
<td>2 /4 位格式的年份。4 位：1901 ～ 2155；2 位：70 ～ 69（1970 ～2069）。</td>
</tr>
<tr>
<td align="left"><code>DATETIME()</code></td>
<td align="center">8</td>
<td align="center">YYYY-MM-DD HH:MM:SS</td>
<td>范围是 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td>
</tr>
<tr>
<td align="left"><code>TIMESTAMP()</code></td>
<td align="center">4</td>
<td align="center">YYYY-MM-DD HH:MM:SS</td>
<td>时间戳。<code>TIMESTAMP</code> 值使用 <code>Unix</code> 纪元(1970-01-01 00:00:00 UTC) 至今的描述来存储。范围是 1970-01-01 00:00:01 UTC 到 2038-01-09 03:14:07 UTC</td>
</tr>
</tbody></table>
<p><code>DATETIME</code> 和 <code>TIMESTAMP</code>两种类型的区别：</p>
<ul>
<li><code>DATETIME</code> 与<code>TIMESTAMP</code>能存储的时间范围也不同，<code>DATETIME</code> 的存储范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59，<code>TIMESTAMP</code>存储的时间范围为19700101080001 ~ 20380119111407</li>
<li><code>DATETIME</code>默认值为空；<code>TIMESTAMP</code>默认值不为空，当插入值为<code>null</code>时，<code>MySQL</code>会取当前时间</li>
<li><code>DATETIME</code> 存储的时间与时区无关，<code>TIMESTAMP</code>存储的时间及显示的时间都依赖于当前时区</li>
<li><code>TIMESTAMP</code> 也接受不同的格式，比如 <ul>
<li>YYYY-MM-DD HH:MM:SS</li>
<li>YY-MM-DD HH:MM:SS</li>
<li>YYYY-MM-DD </li>
<li>YY-MM-DD</li>
</ul>
</li>
</ul>
<br />



<h1 id="2-系列"><a href="#2-系列" class="headerlink" title="2 系列"></a>2 系列</h1><ol>
<li><a href="/SQL/installation-and-simple-instructions-of-sql/" title="「SQL」1. 安装 MySQL">「SQL」1. 安装 MySQL</a></li>
<li><a href="/SQL/basic-instructions-of-sql/" title="「SQL」2. SQL格式规范、基本命令与范例">「SQL」2. SQL格式规范、基本命令与范例</a> </li>
<li><a href="/SQL/data-types-of-MySQL/" title="「SQL」3. MySQL 的数据类型">「SQL」3. MySQL 的数据类型</a></li>
</ol>
<br />

<p><strong>以上！</strong></p>
<br />

]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>MySQL</tag>
        <tag>data types</tag>
      </tags>
  </entry>
  <entry>
    <title>「OS」进程和线程的区别</title>
    <url>/OS/differences-of-process-and-thread/</url>
    <content><![CDATA[<p><strong>简述：</strong>进程和线程是一对朦朦胧胧的概念。</p>
<span id="more"></span>

<br />



<h1 id="1-本质描述"><a href="#1-本质描述" class="headerlink" title="1 本质描述"></a>1 本质描述</h1><p><strong>进程（Process）和线程（Thread）都是一个时间段的描述，是 CPU 工作时间段的描述。</strong></p>
<ul>
<li><p>进程是 程序执行时间总和 = CPU 加载执行环境 -&gt; CPU 执行程序 -&gt; CPU 保存执行环境。</p>
</li>
<li><p>线程是 程序模块执行时间总和 = CPU 加载执行环境（共享进程的）-&gt; CPU 执行程序模块-&gt; CPU 保存执行环境（共享进程的）</p>
</li>
</ul>
<p>进程和线程都是描述 CPU 工作的时间段，线程是更细小的时间段。</p>
<br />



<h1 id="2-具体区别"><a href="#2-具体区别" class="headerlink" title="2 具体区别"></a>2 具体区别</h1><ul>
<li><strong>两者关系</strong>：一个进程可以包含多个线程，线程在进程下运行。</li>
<li><strong>同侪关系</strong>：<ul>
<li>进程间不会相互影响，一个线程崩溃将导致整个进程挂掉。</li>
<li>进程之间是一种树的层级关系，P0 分出 P1 等等。而线程是一种平级的关系。</li>
</ul>
</li>
<li><strong>数据共享</strong>：<ul>
<li>进程有自己的内存，通过分页将虚拟地址空间映射到物理地址空间来存储数据。不同进程间<strong>数据共享很复杂</strong>，需要借助进程间通信机制（如管道，消息队列，<code>Socket</code>，共享内存和信号量等）</li>
<li>同一进程下，不同线程间数据<strong>共享地址空间</strong>（如段、数据段、用户 ID 和组 ID、文件描述符表、当前工作目录等）。</li>
</ul>
</li>
<li><strong>资源消耗</strong>：进程要比线程消耗更多的计算机资源。</li>
<li><strong>上下文切换</strong>：对于操作系统内核而言，进程的上下文切换（<code>context switch</code>）时间消耗比线程的上下文切换更长（heavier）。</li>
</ul>
<br />



<h1 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h1><ul>
<li><a href="https://www.zhihu.com/question/25532384/answer/81152571">线程和进程的区别是什么？ - ZhiHu</a></li>
<li><a href="https://www.quora.com/What-is-the-difference-between-a-process-and-a-thread#">What is the difference between a process and a thread? - Quora</a></li>
</ul>
<br />

<p>以上！</p>
<br />]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>process</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title>「NodeJs」Win7 下安装 NodeJs</title>
    <url>/Manual/fix-nodejs-setup-error-on-win7/</url>
    <content><![CDATA[<p><strong>简述</strong>：<code>win7</code>系统下安装<code>NodeJs</code>莫名失败（Node.js Setup Wizard ended prematurely），我经过搜索和尝试，最后终于安装成功。为此耗费了足足五个小时的时间。。。</p>
<span id="more"></span>
<br/>

<h1 id="1-报错信息"><a href="#1-报错信息" class="headerlink" title="1 报错信息"></a>1 报错信息</h1><p><img src="https://res.cloudinary.com/hexo-pics/image/upload/v1538398125/hexo-2018/10/roll_back.png" alt="roll back"><br><img src="https://res.cloudinary.com/hexo-pics/image/upload/v1538398125/hexo-2018/10/wizard_ended.png" alt="wizard ended"></p>
<p>　　在快要安装成功时，出现回滚。我的天，真是夭寿！</p>
<p>　　这番报错，毫无有价值的参考信息。<br><br/></p>
<h1 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2 解决方法"></a>2 解决方法</h1><h2 id="2-1-下载Windows-Binary版本"><a href="#2-1-下载Windows-Binary版本" class="headerlink" title="2.1 下载Windows Binary版本"></a>2.1 下载Windows Binary版本</h2><p>　　下载地址：<a href="https://nodejs.org/dist/v8.12.0/node-v8.12.0-win-x64.zip">node-v8.12.0-win-x64</a></p>
<p>　　8.12.0 版本是<code>LTS（Long-term Support）</code>稳定版本。</p>
<h2 id="2-2-设置环境变量"><a href="#2-2-设置环境变量" class="headerlink" title="2.2 设置环境变量"></a>2.2 设置环境变量</h2><ol>
<li>选择合适位置放置解压后的Nodejs文件夹</li>
<li>右击<code>我的电脑</code>， 选择<code>属性</code>。</li>
<li>点击位于左侧的<code>高级系统设置</code>。</li>
<li>在跳出的对话框中，点击右下角的<code>环境变量</code>。</li>
<li>设置两个环境变量。示例：D:\nodejs， D:\nodejs\node_modules。</li>
</ol>
<h2 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h2><p>　　按住<code>win</code>+<code>R</code>，在<code>运行</code>对话框中输入<code>cmd</code>，回车。</p>
<p>　　在<code>命令行窗口</code>中分次输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line"></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p>　　响应分别为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8.12.0</span><br><span class="line"></span><br><span class="line">6.4.1</span><br></pre></td></tr></table></figure>

<p>　　至此，若响应如上，则宣告安装成功。</p>
<p>　　若不是，那就。。。</p>
<br />



<p><strong>以上</strong></p>
]]></content>
      <categories>
        <category>Manual</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>win7</tag>
      </tags>
  </entry>
  <entry>
    <title>「SQL」1. 安装 MySQL</title>
    <url>/SQL/installation-and-simple-instructions-of-sql/</url>
    <content><![CDATA[<p><strong>简述</strong>：四月份开始学习<code>SQL</code>，一个新坑的开始，填不完的坑。直到现在才整理了一篇博文，因为坑太多了。。。</p>
<span id="more"></span>
<br />



<p><code>OS</code>：<code>Windows 10 v1903 (18362)</code></p>
<h1 id="1-软件安装及初始化"><a href="#1-软件安装及初始化" class="headerlink" title="1 软件安装及初始化"></a>1 软件安装及初始化</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载地址：<a href="https://dev.mysql.com/downloads/mysql/">MySQL Community Server</a><br>步骤：</p>
<ol>
<li><p>对压缩包解压缩，并放到某个本地位置，如<code>D:\Program Files\MySQL</code></p>
</li>
<li><p>进入 <code>D:\Program Files\MySQL</code>（这里修改为自己的安装目录），新建文件 <code>my.ini</code>。打开并输入再保存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysql]</span><br><span class="line"># 设置 mysql 客户端默认字符集</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"># 设置 3306 端口</span><br><span class="line">port=3306</span><br><span class="line"># 设置 mysql 的安装目录</span><br><span class="line">basedir=D:\\Program Files\\MySQL</span><br><span class="line"></span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=20</span><br><span class="line"></span><br><span class="line"># 服务端使用的字符集默认为 8 比特编码的 latin1 字符集</span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line"></span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br></pre></td></tr></table></figure></li>
<li><p><strong>以管理员打开命令行窗口（CMD）。</strong></p>
</li>
<li><p>切换路径至 <code>D:\Program Files\MySQL\bin</code></p>
</li>
<li><p>初始化数据库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqld --defaults-file=D:\Program Files\MySQL\my.ini --initialize --console</span><br></pre></td></tr></table></figure>
<p>执行完成后，会输出 <code>root</code> 用户的初始默认密码，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2018-04-20T02:35:05.464644Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: BAsCY5ws,hjt</span><br></pre></td></tr></table></figure>
<p><code>BAsCY5ws,hjt</code> 就是初始密码，后续登录需要用到。</p>
</li>
<li><p>安装：<code>mysqld install</code>。</p>
</li>
<li><p>启动：<code>net start mysql</code>。</p>
</li>
<li><p>（不需要执行）停止：<code>net stop mysql</code>。</p>
</li>
</ol>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>命令行窗口目录： <code>D:\Program Files\MySQL\bin</code></p>
<ol>
<li><p>登录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>输入之前记下的 <code>temporary password</code>，回车之后就登录了。</p>
</li>
<li><p><strong>修改密码（超难）</strong>：</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> password <span class="keyword">for</span> root<span class="variable">@localhost</span><span class="operator">=</span><span class="string">&#x27;xxxxxxx&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p> **不要忘记结尾的 <code>;</code>**。<br> 网上TMD教程没几个对的，比如 <code>set password for &#39;root&#39;@&#39;localhost&#39; = password(&#39;xxxxxxx&#39;)</code>。</p>
</li>
<li><p>显示已有的数据库：<code>mysql&gt; show databases;</code>。</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> databases;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> Database           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> information_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> performance_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sys                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.08</span> sec)</span><br></pre></td></tr></table></figure></li>
<li><p>新建数据库：<code>mysql&gt; create database test;</code>。</p>
</li>
<li><p>使用数据库：<code>mysql&gt; use test;</code>。</p>
</li>
</ol>
<br />



<h1 id="2-参考"><a href="#2-参考" class="headerlink" title="2 参考"></a>2 参考</h1><ul>
<li><a href="https://www.runoob.com/mysql/mysql-install.html">MySQL 安装 - 菜鸟教程</a></li>
</ul>
<br />



<h1 id="3-数据库基础知识"><a href="#3-数据库基础知识" class="headerlink" title="3 数据库基础知识"></a>3 数据库基础知识</h1><h2 id="3-1-数据库定义"><a href="#3-1-数据库定义" class="headerlink" title="3.1 数据库定义"></a>3.1 数据库定义</h2><p>数据库 ( <code>Database</code> ) 是按照数据结构来组织、存储和管理数据的仓库。<br>每个数据库都有一个或多个不同的 <code>API</code> 用于创建，访问，管理，搜索和复制所保存的数据。</p>
<h2 id="3-2-关系型数据库"><a href="#3-2-关系型数据库" class="headerlink" title="3.2 关系型数据库"></a>3.2 关系型数据库</h2><p>所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。关系数据库管理系统 ( <code>Relational Database Management System</code>, <code>RDMS</code> ) 的特点：</p>
<ol>
<li>数据以表格的形式出现</li>
<li>每行为各种记录名称</li>
<li>每列为记录名称所对应的数据域</li>
<li>许多的行和列组成一张表单</li>
<li>若干的表单组成 <code>database</code></li>
</ol>
<h2 id="3-3-行-row"><a href="#3-3-行-row" class="headerlink" title="3.3 行 (row)"></a>3.3 行 (row)</h2><blockquote>
<p>行：一行（=元组，或记录）是一组相关的数据，例如某个用户的年龄，出生日期，手机号码等数据。`</p>
</blockquote>
<h2 id="3-4-列-column"><a href="#3-4-列-column" class="headerlink" title="3.4 列 (column)"></a>3.4 列 (column)</h2><blockquote>
<p>列: 一列(数据元素) 包含了相同的数据, 例如学号。`</p>
</blockquote>
<h2 id="3-5-主键-primary-key"><a href="#3-5-主键-primary-key" class="headerlink" title="3.5 主键 (primary key)"></a>3.5 主键 (primary key)</h2><blockquote>
<p>主键：<strong>主键唯一</strong>。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</p>
</blockquote>
<h2 id="3-6-外键-foreign-key"><a href="#3-6-外键-foreign-key" class="headerlink" title="3.6 外键 (foreign key)"></a>3.6 外键 (foreign key)</h2><blockquote>
<p>外键：用于关联两个表。</p>
</blockquote>
<br />

<h1 id="4-MySQL数据库管理系统"><a href="#4-MySQL数据库管理系统" class="headerlink" title="4 MySQL数据库管理系统"></a>4 MySQL数据库管理系统</h1><h2 id="4-1-数据库"><a href="#4-1-数据库" class="headerlink" title="4.1 数据库"></a>4.1 数据库</h2><blockquote>
<p>数据库: 数据库是一些关联表的集合。</p>
</blockquote>
<h2 id="4-2-数据表"><a href="#4-2-数据表" class="headerlink" title="4.2 数据表"></a>4.2 数据表</h2><blockquote>
<p>数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</p>
</blockquote>
<h2 id="4-3-视图"><a href="#4-3-视图" class="headerlink" title="4.3 视图"></a>4.3 视图</h2><blockquote>
<p>虚拟的表。本身不存储数据，而是按指定的方式进行查询。</p>
</blockquote>
<h2 id="4-4-存储过程"><a href="#4-4-存储过程" class="headerlink" title="4.4 存储过程"></a>4.4 存储过程</h2><blockquote>
<p>为以后的使用而保存的一条或多条MySQL语句的集合。</p>
</blockquote>
<br />

<h1 id="5-系列"><a href="#5-系列" class="headerlink" title="5 系列"></a>5 系列</h1><ol>
<li><a href="/SQL/installation-and-simple-instructions-of-sql/" title="「SQL」1. 安装 MySQL">「SQL」1. 安装 MySQL</a></li>
<li><a href="/SQL/basic-instructions-of-sql/" title="「SQL」2. SQL格式规范、基本命令与范例">「SQL」2. SQL格式规范、基本命令与范例</a> </li>
<li><a href="/SQL/data-types-of-MySQL/" title="「SQL」3. MySQL 的数据类型">「SQL」3. MySQL 的数据类型</a></li>
</ol>
<br />

<p><strong>以上！</strong></p>
<br />]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>MySQL</tag>
        <tag>setup</tag>
      </tags>
  </entry>
  <entry>
    <title>「TensorFlow」1. 安装 CUDA 和 cuDNN</title>
    <url>/TensorFlow/installation-of-cuda-toolkit-and-cudnn/</url>
    <content><![CDATA[<p><strong>简述：</strong>为了编译 <code>TensorFlow C++</code>，再次踩进 <code>CUDA</code> 之坑。这是一条不归路，但还是必须做个整理记录，因为这也许不是最后一次。</p>
<span id="more"></span>
<br />


<p>系统环境：</p>
<ul>
<li><code>OS</code>：<code>Ubuntu 14.04.6 LTS x64 (trusty)</code></li>
<li><code>RAM</code>：<code>64 GB</code></li>
<li><code>GPU</code>：<code>GTX TITAN x 4</code></li>
</ul>
<p>安装版本：</p>
<ul>
<li><code>CUDA Toolkit</code>：10.0 </li>
<li><code>cuDNN</code>：7.4.2</li>
</ul>
<br />

<h1 id="1-更新驱动"><a href="#1-更新驱动" class="headerlink" title="1 更新驱动"></a>1 更新驱动</h1><ol>
<li>打开 ”附加驱动“ (<code>Ubuntu 14.04 LTS</code>)<ul>
<li><code>Ubuntu-desktop</code> + <code>Ubuntu</code> 主题：按 <code>Win</code> 键，搜索”附加驱动“</li>
<li><code>Ubuntu-desktop</code> + <code>Gnome </code>主题 ：左上角”应用程序“ -&gt; 系统工具 -&gt; 首选项 -&gt; 附加驱动</li>
</ul>
</li>
<li>选择驱动程序：<ul>
<li>选择 ”使用 NVIDIA binary driver - version 410.56 来自 nvidia-410 (开源) ”</li>
<li>点击右下角“应用更改”</li>
<li>等待完成驱动更新</li>
</ul>
</li>
</ol>
<p><img src="https://res.cloudinary.com/hexo-pics/image/upload/v1571749948/hexo-2019/10/update_nvidia_driver.png" alt="update nvidia driver"></p>
<br />



<h1 id="2-默认安装位置"><a href="#2-默认安装位置" class="headerlink" title="2 默认安装位置"></a>2 默认安装位置</h1><table>
<thead>
<tr>
<th>Component</th>
<th>默认安装位置</th>
</tr>
</thead>
<tbody><tr>
<td><code>CUDA Toolkit</code></td>
<td><code>/usr/local/cuda-10.0</code></td>
</tr>
<tr>
<td><code>CUDA Samples</code></td>
<td><code>$(HOME)/NVIDIA_CUDA-10.0_Samples</code></td>
</tr>
<tr>
<td><code>cuDNN</code></td>
<td><code>/usr/lib/x86_64-linux-gnu</code>  &amp;  <code>/usr/include</code></td>
</tr>
</tbody></table>
<br />

<h1 id="3-安装-CUDA"><a href="#3-安装-CUDA" class="headerlink" title="3 安装 CUDA"></a>3 安装 CUDA</h1><ol>
<li><p>验证是否安装 <code>gcc</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc --version</span><br></pre></td></tr></table></figure>

<p>如果输出如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command <span class="string">&#x27;gcc&#x27;</span> not found, but can be installed with:</span><br><span class="line">sudo apt install gcc</span><br></pre></td></tr></table></figure>

<p>则意味着当前主机尚未安装 <code>gcc</code>，需运行以下指令进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install build-essential manpages-dev</span><br></pre></td></tr></table></figure></li>
<li><p>下载</p>
<p>下载地址：<a href="https://developer.nvidia.com/cuda-10.0-download-archive">CUDA 10.0</a></p>
<p><img src="https://res.cloudinary.com/hexo-pics/image/upload/v1571749947/hexo-2019/10/cuda_download.png" alt="download cuda"></p>
</li>
<li><p>安装</p>
<ul>
<li><p>首先，停用 <code>gdm</code>（<code>Ubuntu</code> 桌面环境），在命令行界面（ <code>Ctrl + Alt + F1 ~ F6</code> ）或者远程连接（ <code>SSH</code> ）的命令行界面下进行指令输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo service gdm stop</span><br></pre></td></tr></table></figure></li>
<li><p>随后，安装 <code>CUDA</code> 以及补丁包，按照命令行提示进行操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo sh cuda_10.0.xxx_xxx.xx_linux.run</span><br><span class="line">$ sudo sh cuda_10.0.xxx.x_linux.run</span><br></pre></td></tr></table></figure></li>
<li><p>最后，恢复桌面环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo service gdm start</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>验证是否安装成功，共有三种方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nvcc -V</span><br></pre></td></tr></table></figure>
<p>输出应为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2018 NVIDIA Corporation</span><br><span class="line">Built on Sat_Aug_25_21:08:01_CDT_2018</span><br><span class="line">Cuda compilation tools, release 10.0, V10.0.130</span><br></pre></td></tr></table></figure>
<br />
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /proc/driver/nvidia/version</span><br></pre></td></tr></table></figure>
输出应为：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NVRM version: NVIDIA UNIX x86_64 Kernel Module  418.56  Fri Mar 15 12:59:26 CDT 2019</span><br><span class="line">GCC version:  gcc version 4.8.4 (Ubuntu 4.8.4-2ubuntu1~14.04.4) </span><br></pre></td></tr></table></figure>
<br />

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /usr/<span class="built_in">local</span>/cuda/version.txt</span><br></pre></td></tr></table></figure>
<p>输出应为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CUDA Version 10.0.130</span><br></pre></td></tr></table></figure></li>
<li><p>系统重启</p>
<p>若出现异常，<a href="#Q&A">这里</a>也许能有相似的情况。</p>
</li>
<li><p>检查<br>检查设备文件 <code>/dev/nvidia*</code> 是否存在，且文件权限是否正确 (666)。通常情况下，这些文件会被需要用到 NVIDIA 驱动的应用程序 (如 <code>CUDA</code> 应用或 <code>X server</code>) 经由调用 <code>nvidia-modprobe</code>自动生成。</p>
<p>但你也可以通过下面的脚本程序，手动创建这些文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">/sbin/modprobe nvidia</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$?&quot;</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># Count the number of NVIDIA controllers found.</span></span><br><span class="line">  NVDEVS=`lspci | grep -i NVIDIA`</span><br><span class="line">  N3D=`<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$NVDEVS</span>&quot;</span> | grep <span class="string">&quot;3D controller&quot;</span> | wc -l`</span><br><span class="line">  NVGA=`<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$NVDEVS</span>&quot;</span> | grep <span class="string">&quot;VGA compatible controller&quot;</span> | wc -l`</span><br><span class="line"></span><br><span class="line">  N=`expr <span class="variable">$N3D</span> + <span class="variable">$NVGA</span> - 1`</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> `seq 0 <span class="variable">$N</span>`; <span class="keyword">do</span></span><br><span class="line">    mknod -m 666 /dev/nvidia<span class="variable">$i</span> c 195 <span class="variable">$i</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">  mknod -m 666 /dev/nvidiactl c 195 255</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">/sbin/modprobe nvidia-uvm</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$?&quot;</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># Find out the major device number used by the nvidia-uvm driver</span></span><br><span class="line">  D=`grep nvidia-uvm /proc/devices | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br><span class="line"></span><br><span class="line">  mknod -m 666 /dev/nvidia-uvm c <span class="variable">$D</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/cuda-10.1/bin:/usr/<span class="built_in">local</span>/cuda-10.0/NsightCompute-2019.1<span class="variable">$&#123;PATH:+:<span class="variable">$&#123;PATH&#125;</span>&#125;</span></span><br><span class="line">$ <span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/cuda-10.0/lib64\</span><br><span class="line">                         <span class="variable">$&#123;LD_LIBRARY_PATH:+:<span class="variable">$&#123;LD_LIBRARY_PATH&#125;</span>&#125;</span></span><br></pre></td></tr></table></figure>

<p>这样设置是临时性的，你可以将之复制到 <code>~/.bashrc</code> 中，以达到永久设置的目的。</p>
<br /></li>
</ol>
<h1 id="4-安装-cuDNN"><a href="#4-安装-cuDNN" class="headerlink" title="4 安装 cuDNN"></a>4 安装 cuDNN</h1><ol>
<li><p>下载 </p>
<p>下载地址：<a href="https://developer.nvidia.com/rdp/cudnn-archive">cuDNN 所有版本</a></p>
<p>找到 <code>Download cuDNN v7.4.2 (Dec 14, 2018), fro CUDA 10.0</code>，下载三个 <code>DEB</code> 文件（<code>cuDNN Runtime Library</code>、<code>cuDNN Developer Library</code>、 <code>cuDNN Code Samples and User Guide</code>）</p>
<p><img src="https://res.cloudinary.com/hexo-pics/image/upload/v1571749949/hexo-2019/10/cudnn_download.png" alt="download cudnn"></p>
</li>
<li><p>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dpkg -i libcudnn7_7.4.2.xx-1+cuda10.0_amd64.deb  // 运行时库</span><br><span class="line">$ sudo dpkg -i libcudnn7-dev_7.4.2.xx-1+cuda10.0_amd64.deb  // 开发者库</span><br><span class="line">$ sudo dpkg -i libcudnn7-doc_7.4.2.24-1+cuda10.0_amd64.deb  // 代码案例和用户指南</span><br></pre></td></tr></table></figure></li>
<li><p>验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ grep -i cudnn_major -A 2 /usr/include/cudnn.h</span><br></pre></td></tr></table></figure>
<p>输出应为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define CUDNN_MAJOR 7</span></span><br><span class="line"><span class="comment">#define CUDNN_MINOR 4</span></span><br><span class="line"><span class="comment">#define CUDNN_PATCHLEVEL 2</span></span><br><span class="line">--</span><br><span class="line"><span class="comment">#define CUDNN_VERSION (CUDNN_MAJOR * 1000 + CUDNN_MINOR * 100 + CUDNN_PATCHLEVEL)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &quot;driver_types.h&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<br />

<h1 id="5-问题与解决"><a href="#5-问题与解决" class="headerlink" title="5 问题与解决 "></a>5 问题与解决 <span id="Q&A"></span></h1><ul>
<li><p>无限重复登陆；重启后黑屏，左上角有一下划线不断闪烁：</p>
<p>解决方案：远程登录 (<code>SSH</code>) ，更新 <code>GPU</code> 驱动至更高版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh NAME@IP -p 22</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ubuntu-drivers devices</span></span><br><span class="line">== /sys/devices/pci0000:00/0000:00:03.0/0000:03:00.0/0000:04:10.0/0000:05:00.0 ==</span><br><span class="line">vendor   : NVIDIA Corporation</span><br><span class="line">modalias : pci:vxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">driver   : nvidia-418 - third-party free</span><br><span class="line">driver   : xserver-xorg-video-nouveau - distro free builtin</span><br><span class="line">driver   : nvidia-415 - third-party free</span><br><span class="line">driver   : nvidia-430 - third-party free recommended</span><br><span class="line">driver   : nvidia-384 - third-party non-free</span><br><span class="line">driver   : nvidia-410 - third-party free</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install nvidia-xxx</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo reboot</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动并登陆系统后只显示壁纸，无顶栏与左侧快捷栏</p>
<p>解决方案有两种：</p>
<ol>
<li>新建一个用户账号，注销当前账号，换用新账号登陆。原理未知。</li>
<li>换用系统主题 (<code>Ubuntu</code> -&gt; 其他)。在刚启动系统，进行账号登录时，在登录按钮左边有一个齿轮状的按钮，点击一下你就了解了。</li>
</ol>
</li>
</ul>
<br />

<h1 id="6-参考"><a href="#6-参考" class="headerlink" title="6 参考"></a>6 参考</h1><ul>
<li><a href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html">CUDA installation Guide Linux - NVIDIA</a></li>
<li><a href="https://docs.nvidia.com/deeplearning/sdk/cudnn-install/index.html">cuDNN install - NVIDIA</a></li>
<li><a href="https://linuxize.com/post/how-to-install-gcc-compiler-on-ubuntu-18-04/">install gcc - linuxize</a></li>
<li><a href="https://linuxconfig.org/how-to-install-the-nvidia-drivers-on-ubuntu-18-04-bionic-beaver-linux">install the nvidia drivers - linuxconfig</a></li>
</ul>
<br />



<h1 id="7-系列"><a href="#7-系列" class="headerlink" title="7 系列"></a>7 系列</h1><ol>
<li><a href="/TensorFlow/installation-of-cuda-toolkit-and-cudnn/" title="「TensorFlow」1. 安装 CUDA 和 cuDNN">「TensorFlow」1. 安装 CUDA 和 cuDNN</a></li>
<li><a href="/TensorFlow/build-tensorflow-cpp/" title="「TensorFlow」2. 编译 TensorFlow C++">「TensorFlow」2. 编译 TensorFlow C++</a></li>
</ol>
<br />

<p><strong>以上！</strong></p>
<br />]]></content>
      <categories>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
        <tag>CUDA</tag>
        <tag>cuDNN</tag>
      </tags>
  </entry>
  <entry>
    <title>「C++」string 成员函数</title>
    <url>/C/introduction-of-string/</url>
    <content><![CDATA[<p><strong>简述</strong>：C++ 类 <code>string</code> </p>
<span id="more"></span>
<br />

<h1 id="1-string简介"><a href="#1-string简介" class="headerlink" title="1 string简介"></a>1 string简介</h1><p>　　<code>&lt;string&gt;</code>是<code>C++</code>标准程序库中的一个头文件，定义了C++标准中的字符串的基本模板类<code>std::basic_string</code>及相关的模板类实例，这里不进行详细介绍。详细可查看相关 <a href="https://zh.wikipedia.org/wiki/String_(C%2B%2B%E6%A0%87%E5%87%86%E5%BA%93)">wiki百科</a> ，以及 <a href="http://www.cplusplus.com/reference/string/string/">cplusplus</a> 。</p>
<p>　　其中的<code>string</code>是以<code>char</code>作为模板参数的模板类实例，把字符串的内存管理责任由<code>string负责</code>而不是由用户负责，大大减轻了<code>C</code>语言风格的字符串的麻烦。</p>
<p>　　<code>std::basic_string</code>提供了大量的字符串操作函数，如比较、连接、搜索、替换、获得子串等。并可与<code>C</code>语言风格字符串双向转换。<code>std::basic_string</code>属于<code>C++ STL</code>容器类，用户自定义的类也可以作为它的模板参数，因此也适用<code>C++ STL Algorithm</code>库。<br><br /></p>
<h1 id="2-声明变量"><a href="#2-声明变量" class="headerlink" title="2 声明变量"></a>2 声明变量</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">    std::string str;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<br />

<h1 id="3-成员函数"><a href="#3-成员函数" class="headerlink" title="3 成员函数"></a>3 成员函数</h1><ul>
<li>构造与析构<ul>
<li><code>string::string</code>（构造）</li>
<li><code>string::~string</code>（析构）</li>
<li><strong><code>string::operator =</code></strong> - 赋值</li>
<li><code>string::assign</code> – 赋值</li>
<li><code>string::get_allocator</code> – 获得内存分配器</li>
</ul>
</li>
<li>字符访问<ul>
<li><code>string::at</code> – 访问特定字符，带边界检查</li>
<li><strong><code>string::operator []</code></strong> – 访问特定字符</li>
<li><code>string::front</code> – 访问第一个字符</li>
<li><code>string::back</code> – 访问最后一个字符</li>
<li><code>string::data</code> – 访问基础数组，<code>C++11</code>后与<code>c_str()</code>完全相同</li>
<li><code>string::c_str</code> – 返回对应于字符串内容的<code>C</code>风格零结尾的只读字符串</li>
<li><code>string::substr</code> – 以子串构造一个新串；参数为空时取全部源串</li>
</ul>
</li>
<li>迭代器<ul>
<li><strong><code>string::begin</code></strong> – 获得指向开始位置的迭代器</li>
<li><strong><code>string::end</code></strong> – 获得指向末尾的迭代器</li>
<li><code>string::rbegin</code> – 获得指向末尾的逆向迭代器</li>
<li><code>string::rend</code> – 获得指向开始位置的逆向迭代器</li>
<li><code>string::cbegin</code> – 获得指向开始位置的只读迭代器</li>
<li><code>string::cend</code> – 获得指向末尾的只读迭代器</li>
<li><code>string::crbegin</code> – 获得指向末尾的逆向只读迭代器</li>
<li><code>string::crend</code> – 获得指向开始位置的逆向只读迭代器</li>
</ul>
</li>
<li>容量<ul>
<li><code>string::empty</code> – 检查是否为空</li>
<li><code>string::size</code> – 返回数据的字符长度</li>
<li><strong><code>string::length</code></strong> – 返回数据的字符长度，与<code>size()</code>完全相同</li>
<li><code>string::max_size</code> – 返回可存储的最大的字节容量，在32位<code>Windows</code>上大概为 43 亿字节。</li>
<li><code>string::reserve</code> – 改变<code>string</code>的字符存储容量，实际获得的存储容量不小于<code>reserve</code>的参数值。</li>
<li><code>string::capacity</code> – 返回当前的字符存储容量</li>
<li><code>string::shrink_to_fit（C++11 新增）</code> – 降低内存容量到刚好</li>
</ul>
</li>
<li>修改器<ul>
<li><code>string::clear</code> – 清空内容</li>
<li><strong><code>string::insert</code></strong> – 插入字符或字符串。目标<code>string</code>中的插入位置可用整数值或迭代器表示。如果参数仅为一个迭代器，则在其所指位置插入0 值。</li>
<li><code>string::erase</code> – 删除 1 个或 1 段字符</li>
<li><strong><code>string::push_back</code></strong> – 追加 1 个字符</li>
<li><code>string::pop_back</code> – 删除最后 1 个字符，<code>C++11</code>标准引入</li>
<li><code>string::append</code> – 追加字符或字符串</li>
<li><strong><code>string::operator+=</code></strong> – 追加，只有一个参数——字符指针、字符或字符串；不像<code>append()</code>一样可以追加参数的子串或若干相同字符</li>
<li><code>string::copy</code> – 拷贝出一段字符到<code>C</code>风格字符数组；有溢出危险</li>
<li><code>string::resize</code> – 改变（增加或减少）字符串长度；如果增加了字符串长度，新字符缺省为<code>0</code>值</li>
<li><code>string::swap</code> – 与另一个<code>string</code>交换内容</li>
<li><code>string::replace</code> – 替换子串；如果替换源数据与被替换数据的长度不等，则结果字符串的长度发生改变</li>
</ul>
</li>
<li>搜索<ul>
<li><code>string::find</code> – 前向搜索特定子串的第一次出现</li>
<li><code>string::rfind</code> – 从尾部开始，后向搜索特定子串的第一次出现</li>
<li><code>string::find_first_of</code> – 搜索指定字符集合中任意字符在<code>*this</code>中的第一次出现</li>
<li><code>string::find_last_of</code> – 搜索指定字符集合中任意字符在<code>*this</code>中的最后一次出现</li>
<li><code>string::find_first_not_of</code> – <code>*this</code>中的不属于指定字符集合的首个字符</li>
<li><code>string::find_last_not_of</code> – <code>*this</code>中的不属于指定字符集合的末个字符</li>
<li><code>string::compare</code> – 与参数字符串比较</li>
</ul>
</li>
<li>常量值<ul>
<li><code>string::npos</code> – 表示“未找到”，值为<code>static const unsigned -1</code></li>
</ul>
</li>
<li>非成员的有关的全局函数<ul>
<li><code>std::operator+</code> – 字符串连接</li>
<li><code>std::operator!=</code> – 不等比较</li>
<li><code>std::operator==</code> – 相等比较</li>
<li><code>std::operator&lt;</code> – 小于比较</li>
<li><code>std::operator&lt;=</code> – 小于等于比较</li>
<li><code>std::operator&gt;</code> – 大于比较</li>
<li><code>std::operator&gt;=</code> – 大于等于比较</li>
<li><code>std::operator&lt;&lt;</code> – 字符串内容写到输出流中</li>
<li><code>std::operator&gt;&gt;</code> – 从输入流中读取一个字符串</li>
<li><code>std::getline</code> – 从<code>istream</code>中读入一行或一段字符到<code>string</code>中</li>
<li><code>std::swap</code> – 交换两个<code>string</code>的内容。是<code>std::swap</code>算法针对<code>std::basic_string</code>的特化版本</li>
<li><strong><code>std::stoi</code></strong> – 字符串转为整形</li>
<li><code>std::stol</code> – 字符串转为长整形</li>
<li><code>std::stoll</code> – 字符串转为长长整形</li>
<li><code>std::stoul</code> – 字符串转为无符号长整形</li>
<li><code>std::stoull</code> – 字符串转为无符号长长整形</li>
<li><code>std::stof</code> – 字符串转为单精度浮点形</li>
<li><code>std::stod</code> – 字符串转为双精度浮点形</li>
<li><code>std::stold</code> – 字符串转为长双精度浮点形</li>
<li><strong><code>std::to_string</code></strong> – 整型、无符号整型、浮点型转化为<code>string</code></li>
<li><code>std::to_wstring</code> – 整型、无符号整型、浮点型转化为<code>wstring</code></li>
<li><code>std::hash&lt;std::string&gt;</code> – 计算<code>hash</code>值</li>
<li><code>std::hash&lt;std::wstring&gt;</code> – 计算<code>hash</code>值</li>
<li><code>std::hash&lt;std::u16string&gt;</code> – 计算<code>hash</code>值</li>
<li><code>std::hash&lt;std::u32string&gt;</code> – 计算<code>hash</code>值</li>
</ul>
  <br/></li>
</ul>
<p>　　以上！</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>「Hexo」配置多终端推送文章</title>
    <url>/Manual/multiple-pc-configuration-of-hexo/</url>
    <content><![CDATA[<p><strong>简述</strong>：Hexo 博客系统很轻便，经常配合 Github Page 使用。多终端推送更新是个问题，不过网上的解决方法很多，也基本一致，窝也记录一下自己的操作过程。</p>
<span id="more"></span>

<br />

<h1 id="1-更新Repo"><a href="#1-更新Repo" class="headerlink" title="1 更新Repo"></a>1 更新Repo</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm audit</span></span><br></pre></td></tr></table></figure>

<p>根据终端提示内容，对 Repo 进行更新。在其他终端拉取仓库并进行简要配置后，就可以推送文章了。</p>
<p>当然，麻烦总是多过预期。不过，<code>warning</code>存在的意义就是被忽视，解决<code>error</code>就好了（</p>
<br />

<h1 id="2-第一终端配置"><a href="#2-第一终端配置" class="headerlink" title="2 第一终端配置"></a>2 第一终端配置</h1><p>本地 Hexo 对应文件夹其实就有<code>.gitignore</code>文件，可知 Hexo 也是支持将源文件存放到 Github 的。</p>
<p>注意事项：</p>
<ul>
<li>本地 <code>themes</code> 文件夹下有<code>git clone</code>下载的主题，需先将对应目录下的 <code>.git</code> 文件夹删除，并将 themes 剪切到别处。将 Hexo 文件夹 <code>add</code>-&gt;<code>commit</code>-&gt;<code>push</code>三连后，再将之剪切回来，另行 <code>add</code>-&gt;<code>commit</code>-&gt;<code>push</code> 操作三连。</li>
</ul>
<p>在 Hexo 对应目录下执行以下指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b hexo				// 新建并切换到分支 hexo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span>							</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;Hexo Source&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin git@github.com:USERNAME/USERNAME.github.io.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin hexo				// 推送到 Github Page 仓库的 hexo 分支</span></span><br></pre></td></tr></table></figure>

<br />

<h1 id="3-其他终端配置"><a href="#3-其他终端配置" class="headerlink" title="3 其他终端配置"></a>3 其他终端配置</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> -b hexo git@github.com:USERNAME/USERNAME.github.io.git DIRNAME/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> DIRNAME</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install						// 这里不需要 npm init</span></span><br></pre></td></tr></table></figure>

<br />

<h1 id="4-新增文章并推送（任意终端）"><a href="#4-新增文章并推送（任意终端）" class="headerlink" title="4 新增文章并推送（任意终端）"></a>4 新增文章并推送（任意终端）</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin hexo				// 拉取 Github 端的最新仓库，防止 commit 时出现冲突</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo new <span class="string">&quot;POST_NAME&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add <span class="built_in">source</span>/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;COMMIT_TITLE&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin hexo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo g -d</span></span><br></pre></td></tr></table></figure>



<p>参考自：</p>
<p><a href="https://resalee.github.io/2017/11/01/hexo-github-blog/">https://resalee.github.io/2017/11/01/hexo-github-blog/</a></p>
<p><a href="https://www.zhihu.com/question/21193762">https://www.zhihu.com/question/21193762</a></p>
<br />

<p>以上！     </p>
]]></content>
      <categories>
        <category>Manual</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>multiple-pc</tag>
      </tags>
  </entry>
  <entry>
    <title>「Linux」VPS 重启后未分配 IP</title>
    <url>/Linux/no-ip-after-rebooting/</url>
    <content><![CDATA[<p><strong>简述</strong>：VPS（Ubuntu OS）重启后出现未分配 IP 地址而无法连接的问题，具体现象为 <code>ifconfig</code> 命令未显示网络接口 eth0 的信息。解决办法为通过 VNC 登陆 VPS，调用 <code>ifconfig</code> 启用网络接口 eth0，再调用 <code>dhclient</code> 向 DHCP 服务器请求 IP。</p>
<span id="more"></span>

<br />

<h1 id="1-问题与解决"><a href="#1-问题与解决" class="headerlink" title="1 问题与解决"></a>1 问题与解决</h1><h2 id="1-1-问题描述"><a href="#1-1-问题描述" class="headerlink" title="1.1 问题描述"></a>1.1 问题描述</h2><p>VPS（Ubuntu OS）重启后出现未分配 IP 地址而无法连接的问题。具体现象为</p>
<p><code>cat /etc/network/interfaces</code> 的信息中包含网络接口 lo 与 eth0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">    address XXX.XXX.XXX.XXX</span><br><span class="line">    netmask 255.255.255.0</span><br><span class="line">    broadcast XXX.XXX.XXX.255</span><br><span class="line">    network XXX.XXX.XXX.0</span><br><span class="line">    gateway  XXX.XXX.XXX.1</span><br><span class="line"></span><br><span class="line">dns-nameserver 8.8.8.8</span><br></pre></td></tr></table></figure>

<p>但 <code>ifconfig</code> 命令只显示网络接口 lo 的信息，即 eth0 未激活。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">    inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">    inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">    loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">    RX packets 43  bytes 5520 (5.5 KB)</span><br><span class="line">    RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">    TX packets 43  bytes 5520 (5.5 KB)</span><br><span class="line">    TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<p>在本地 ping 远程 VPS，显示连接超时，也无法通过 SSH 登录 VPS。</p>
<h2 id="1-2-解决方案"><a href="#1-2-解决方案" class="headerlink" title="1.2 解决方案"></a>1.2 解决方案</h2><ol>
<li><p>激活网络接口 eth0。shell 命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ifconfig eth0 up</span></span><br></pre></td></tr></table></figure>

<p>网络接口的名字不一定是 eth0，可通过 <code>cat /etc/network/interfaces</code> 查看所有网络接口。</p>
</li>
<li><p>通过 DHCP 协议配置网络接口的参数。shell 命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo dhclient eth0</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看网络接口 eth0 的信息。shell 命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ifconfig eth0</span></span><br></pre></td></tr></table></figure></li>
</ol>
<br />

<h1 id="2-ifconfig"><a href="#2-ifconfig" class="headerlink" title="2 ifconfig"></a>2 ifconfig</h1><p><code>ifconfig</code> 是 interface configuration 的缩写，能够显示网络接口信息，配置网络接口。不给定参数的情况下，<code>ifconfig</code> 会显示当前启用的网络接口信息。</p>
<h2 id="2-1-语法"><a href="#2-1-语法" class="headerlink" title="2.1 语法"></a>2.1 语法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig [-v] [-a] [-s] [interface]</span><br><span class="line">ifconfig [-v] interface [aftype] options | address ...</span><br></pre></td></tr></table></figure>



<h2 id="2-2-用法"><a href="#2-2-用法" class="headerlink" title="2.2 用法"></a>2.2 用法</h2><table>
<thead>
<tr>
<th>写法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>ifconfig</code></td>
<td>显示可用网络接口的信息。</td>
</tr>
<tr>
<td><code>ifconfig -a</code></td>
<td>显示所有网络接口的信息。</td>
</tr>
<tr>
<td><code>ifconfig eth0</code></td>
<td>显示网络接口 eth0 的信息。</td>
</tr>
<tr>
<td><code>ifconfig eth0 up</code></td>
<td>启用网络接口 eth0。</td>
</tr>
<tr>
<td><code>ifconfig eth0 down</code></td>
<td>停用网络接口 eth0。</td>
</tr>
<tr>
<td><code>ifconfig eth0 172.16.25.125</code></td>
<td>设置网络接口 eth0 的 IP 地址。</td>
</tr>
<tr>
<td><code>ifconfig eth0 netmask 255.255.255.224</code></td>
<td>设置网络接口 eth0 的子网掩码。</td>
</tr>
<tr>
<td><code>ifconfig eth0 broadcast 172.16.25.63</code></td>
<td>设置网络接口 eth0 的广播地址。</td>
</tr>
<tr>
<td><code>ifconfig eth0 mtu 1000</code></td>
<td>设置网络接口 eth0 的 MTU（最大传输单元）。</td>
</tr>
</tbody></table>
<br />

<h1 id="3-dhclient"><a href="#3-dhclient" class="headerlink" title="3 dhclient"></a>3 dhclient</h1><p>dhclient 的全写是 Dynamic Host Configuration Protocol（DHCP） Client。</p>
<p>DHCP 协议用于让中央服务器给主机分配一个网络 IP 地址。</p>
<p>起初，主机设备的网络接口并未被分配一个 IP 地址，所以该主机无法连接。（可以通过 <code>ip address</code> 或 <code>ifconfig -a</code> 来验证这一点）。</p>
<p>调用 <code>dhclient</code>，能够向 DHCP 服务器请求一个 IP 地址。主机向本地网络中的广播地址发送一个 DHCP discovery message，（在路由器或网关）运行的 DHCP 服务器收到消息后向该主机发送一个 DHCP offer message，提供一个 IP 地址。</p>
<p><code>dhclient</code> 的配置文件是 <code>dhclient.conf</code>。</p>
<h2 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dhclient </span><br><span class="line">[ -4 | -6 ] [ -S ] [ -N [ -N...  ] ] [ -T [ -T...  ] ] </span><br><span class="line">[ -P [ -P...  ] ] -R ] [ -i ] [ -I ] [ -4o6 port ] </span><br><span class="line">[ -D LL|LLT ] [ -p port-number ] [ -d ] </span><br><span class="line">[ -df duid-lease-file ] [ -e VAR=value ] </span><br><span class="line">[ -q ] [ -1 ] [ -r | -x ] [ -lf lease-file ] </span><br><span class="line">[ -pf pid-file ] [ --no-pid ] [ -cf  config-file  ] </span><br><span class="line">[-sf  script-file ] [ -s server-addr ] [ -g relay ]</span><br><span class="line">[ -n ] [ -nw ] [ -w ] [ --dad-wait-time seconds ]</span><br><span class="line">[ --prefix-len-hint length ] [ --decline-wait-time seconds ] [ -v ] [ --version ]</span><br><span class="line">[ if0 [ ...ifN ] ]</span><br></pre></td></tr></table></figure>



<h2 id="3-2-选项"><a href="#3-2-选项" class="headerlink" title="3.2 选项"></a>3.2 选项</h2><table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-p</td>
<td>指定 DHCP 客户端监听的端口号（默认端口号 86）</td>
</tr>
<tr>
<td>-d</td>
<td>总是以前台方式运行程序</td>
</tr>
<tr>
<td>-q</td>
<td>安静模式，不打印任何错误的提示信息</td>
</tr>
<tr>
<td>-r</td>
<td>释放 IP 地址</td>
</tr>
<tr>
<td>-n</td>
<td>不配置任何接口</td>
</tr>
<tr>
<td>-x</td>
<td>停止正在运行的 DHCP 客户端，而不释放当前租约，杀死现有的 dhclient</td>
</tr>
<tr>
<td>-s</td>
<td>在获取 IP 地址之前指定 DHCP 服务器</td>
</tr>
<tr>
<td>-w</td>
<td>即使没有找到广播接口，也继续运行</td>
</tr>
</tbody></table>
<br />

<h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h1><ul>
<li><a href="https://blog.csdn.net/cmh477660693/article/details/52760236">ubuntu 下 eth0 网卡信息不见了 - CSDN</a></li>
<li><a href="https://www.howtoing.com/check-ip-address-on-linux">如何在 Linux 命令行上查看 IP 地址 - Howtoing</a></li>
<li><a href="https://www.tecmint.com/ifconfig-command-examples/">15 Useful “ifconfig” Commands to Configure Network Interface in Linux - Tecmint</a></li>
<li><a href="https://stackoverflow.com/questions/63961142/what-does-dhclient-do">What does dhclient do? - Stack Overflow</a></li>
</ul>
<br />

<p><strong>以上！</strong></p>
<br />]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>Internet</tag>
        <tag>DHCP</tag>
      </tags>
  </entry>
  <entry>
    <title>「Testing」测试框架 PowerMock 使用手册</title>
    <url>/Testing/powermock-api/</url>
    <content><![CDATA[<p><strong>简述</strong>：这篇文章主要是列出 Android 测试框架 <code>PowerMock</code> 的常用 <code>API</code> 和一些注解。其中某些 <code>API</code> 其实并没有用过，所以不能保证全文毫无错误。在此之前，建议先阅读一些入门文章，了解单元测试是什么和为什么做单元测试。</p>
<span id="more"></span>

<br />



<h1 id="1-注解"><a href="#1-注解" class="headerlink" title="1 注解"></a>1 注解</h1><h2 id="1-1-JUnit-RunWith"><a href="#1-1-JUnit-RunWith" class="headerlink" title="1.1 [JUnit] RunWith"></a>1.1 [JUnit] RunWith</h2><blockquote>
<p>When a class is annotated with <code>@RunWith</code> or extends a class annotated with <code>@RunWith</code>, JUnit will invoke the class it references to run the tests in that class instead of the runner built into JUnit. We added this feature late in development. While it seems powerful we expect the runner API to change as we learn how people really use it. Some of the classes that are currently internal will likely be refined and become public.</p>
</blockquote>
<p>简单地说，JUnit 会使用 <code>@RunWith</code> 中的 Runner 类，代替 JUnit 的内建 Runner 来运行测试。</p>
<p>参考</p>
<ul>
<li><a href="https://junit.org/junit4/javadoc/latest/org/junit/runner/RunWith.html">Annotation Type RunWith</a></li>
</ul>
<h2 id="1-2-PowerMock-PrepareForTest"><a href="#1-2-PowerMock-PrepareForTest" class="headerlink" title="1.2 [PowerMock] PrepareForTest"></a>1.2 [PowerMock] PrepareForTest</h2><blockquote>
<p>Tells PowerMock to prepare certain classes for testing. Classes needed to be defined using this annotation are typically those that needs to be byte-code manipulated. This includes final classes, classes with final, private, static or native methods that should be mocked and also classes that should be return a mock object upon instantiation.</p>
</blockquote>
<p>翻译过来，<code>PrepareForTest</code> 的作用就是提醒 <code>PowerMock</code> 对待测试的类做准备。这些待测试的类可以是：</p>
<ol>
<li><p>final 类</p>
</li>
<li><p>类中有需要 mock 的 final/private/static/native 方法</p>
</li>
<li><p>希望实例后返回的是某个类的 mock 对象</p>
</li>
</ol>
<p>参考</p>
<ul>
<li><a href="https://javadoc.io/doc/org.powermock/powermock-core/1.6.5/org/powermock/core/classloader/annotations/PrepareForTest.html">Annotation Type PrepareForTest</a></li>
</ul>
<h2 id="1-3-PowerMock-PowerMockIgnore"><a href="#1-3-PowerMock-PowerMockIgnore" class="headerlink" title="1.3 [PowerMock] PowerMockIgnore"></a>1.3 [PowerMock] PowerMockIgnore</h2><blockquote>
<p>This annotation tells PowerMock to defer the loading of classes with the names supplied to <a href="https://www.javadoc.io/static/org.powermock/powermock-core/1.7.1/org/powermock/core/classloader/annotations/PowerMockIgnore.html#value--"><code>value()</code></a> to the system classloader.</p>
<p>This is useful in situations when you have e.g. a test/assertion utility framework (such as something similar to Hamcrest) whose classes must be loaded by the same classloader as EasyMock, JUnit and PowerMock etc.</p>
<p>Note that the <a href="https://www.javadoc.io/static/org.powermock/powermock-core/1.7.1/org/powermock/core/classloader/annotations/PrepareForTest.html"><code>PrepareForTest</code></a> and <a href="https://www.javadoc.io/static/org.powermock/powermock-core/1.7.1/org/powermock/core/classloader/annotations/PrepareOnlyThisForTest.html"><code>PrepareOnlyThisForTest</code></a> will have precedence over this annotation. This annotation will have precedence over the <a href="https://www.javadoc.io/static/org.powermock/powermock-core/1.7.1/org/powermock/core/classloader/annotations/PrepareEverythingForTest.html"><code>PrepareEverythingForTest</code></a> annotation.</p>
</blockquote>
<p>PowerMock 会延迟 system classloader 对在 <code>PowerMockIgnore</code> 中的类的加载。如果测试框架的类需要由 JUnit/EasyMock/PowerMock 的类加载器来加载，就可以用上 <code>PowerMockIgnore</code> 了。</p>
<p>不过，<code>PrepareForTest</code> 和 <code>PrepareOnlyThisForTest</code> 的优先级比 <code>PowerMockIgnore</code> 高。</p>
<p>参考</p>
<ul>
<li><a href="https://www.javadoc.io/doc/org.powermock/powermock-core/1.7.1/org/powermock/core/classloader/annotations/PowerMockIgnore.html">Annotation Type PowerMockIgnore</a></li>
</ul>
<br />

<h1 id="2-构造对象"><a href="#2-构造对象" class="headerlink" title="2 构造对象"></a>2 构造对象</h1><h2 id="2-1-mock"><a href="#2-1-mock" class="headerlink" title="2.1 mock"></a>2.1 mock</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T object = PowerMockito.mock(Class&lt;? extends Object&gt; type);</span><br></pre></td></tr></table></figure>



<h2 id="2-2-spy"><a href="#2-2-spy" class="headerlink" title="2.2 spy"></a>2.2 spy</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T object = PowerMockito.spy(T object);</span><br></pre></td></tr></table></figure>



<p>参考</p>
<ul>
<li><p><a href="https://www.baeldung.com/mockito-spy">Mockito – Using Spies</a></p>
</li>
<li><p><a href="https://stackoverflow.com/questions/15052984/what-is-the-difference-between-mocking-and-spying-when-using-mockito">What is the difference between mocking and spying when using Mockito - StackOverflow</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/softidea/p/4204389.html">Mockito 的 mock 和 spy</a></p>
</li>
<li><p><a href="https://matthung0807.blogspot.com/2018/08/mockito-mockspy.html">Mockito Mock 與 Spy 的差別</a></p>
</li>
</ul>
<br />

<h1 id="3-访问-修改非公有成员"><a href="#3-访问-修改非公有成员" class="headerlink" title="3 访问/修改非公有成员"></a>3 访问/修改非公有成员</h1><h2 id="3-1-访问非-public-成员"><a href="#3-1-访问非-public-成员" class="headerlink" title="3.1 访问非 public 成员"></a>3.1 访问非 public 成员</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassName obj = Whitebox.getInternalState(Object object, String fieldName);</span><br></pre></td></tr></table></figure>

<p><strong>PS：假设类名为 Example，访问静态成员时，object 就是 Example.class。不止是访问非公有成员，其他与 static 有关的操作像是修改静态成员和调用静态方法等，object 都是 Example.class。</strong></p>
<h2 id="3-2-修改非-public-成员"><a href="#3-2-修改非-public-成员" class="headerlink" title="3.2 修改非 public 成员"></a>3.2 修改非 public 成员</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Whiterbox.setInternalState(Object object, String fieldName, Object value);</span><br></pre></td></tr></table></figure>




<br />

<h1 id="4-调用-执行方法"><a href="#4-调用-执行方法" class="headerlink" title="4 调用/执行方法"></a>4 调用/执行方法</h1><h2 id="4-1-public-方法"><a href="#4-1-public-方法" class="headerlink" title="4.1 public 方法"></a>4.1 public 方法</h2><p>直接调用就行了鸭！</p>
<h2 id="4-2-非-public-方法"><a href="#4-2-非-public-方法" class="headerlink" title="4.2 非 public 方法"></a>4.2 非 public 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有返回值</span></span><br><span class="line">ClassName toBeReturned = Whitebox.invokeMethod(Object object, String methodToExecute, Object... arguments);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无返回值</span></span><br><span class="line">Whitebox.invokeMethod(Object object, String methodToExecute, Object... arguments);</span><br></pre></td></tr></table></figure>



<h2 id="4-3-调用-mock-对象真正的方法"><a href="#4-3-调用-mock-对象真正的方法" class="headerlink" title="4.3 调用 mock 对象真正的方法"></a>4.3 调用 mock 对象真正的方法</h2><p><strong>PS：先设置，再调用。设置 != 调用。另外，对象是通过 mock 得到的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// public 方法</span></span><br><span class="line">Powermockito.doCallRealMethod().when(Object object).METHOD(Object... arguments);  <span class="comment">// 设置</span></span><br><span class="line">object.METHOD(Object... arguments);  <span class="comment">// 调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非 public 方法</span></span><br><span class="line">Powermockito.doCallRealMethod().when(Object object, String methodToExecute, Object... arguments);</span><br><span class="line">Whitebox.invokeMethod(Object object, String methodToExecute, Object... arguments);</span><br></pre></td></tr></table></figure>




<br />

<h1 id="5-设定方法返回值"><a href="#5-设定方法返回值" class="headerlink" title="5 设定方法返回值"></a>5 设定方法返回值</h1><p><strong>PS：此节的对象都是 mock / spy 对象。</strong></p>
<h2 id="5-1-普通方法"><a href="#5-1-普通方法" class="headerlink" title="5.1 普通方法"></a>5.1 普通方法</h2><ol>
<li><p>public 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有返回值</span></span><br><span class="line">PowerMockito.doReturn(Object toBeReturned).when(mockedClass).METHOD(Object.. Arguments);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无返回值</span></span><br><span class="line">PowerMockito.doNothing().when(T mock).METHOD(Obecject... arguments);</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li><p>非 public 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有返回值</span></span><br><span class="line">PowerMockito.doReturn(Object toBeReturned).when(T mock, String methodToExpect, Obecject... arguments);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无返回值</span></span><br><span class="line">PowerMockito.doNothing().when(T mock, String methodToExpect, Obecject... arguments);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5-2-静态方法"><a href="#5-2-静态方法" class="headerlink" title="5.2 静态方法"></a>5.2 静态方法</h2><ol>
<li><p>public 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PowerMockito.mockStatic(Class&lt;?&gt; type, Class&lt;?&gt;... types)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有两种方式，第一种更接近正常逻辑</span></span><br><span class="line"><span class="comment">// 1)</span></span><br><span class="line"><span class="comment">// 有返回值</span></span><br><span class="line">PowerMockito.when(T.STATIC_METHOD(Object... arguments)).thenReturn(Object toBeReturned);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2)</span></span><br><span class="line"><span class="comment">// 有返回值</span></span><br><span class="line">PowerMockito.doReturn(...).when(T mock);</span><br><span class="line">T.STATIC_METHOD(Object... arguments);</span><br></pre></td></tr></table></figure></li>
<li><p>非 public 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PowerMockito.mockStatic(Class&lt;?&gt; type, Class&lt;?&gt;... types)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1)</span></span><br><span class="line"><span class="comment">// 有返回值</span></span><br><span class="line">PowerMockito.when(T.class, String methodToExpect, Obecject... arguments).thenReturn(Object toBeReturned);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2)</span></span><br><span class="line"><span class="comment">// 有返回值</span></span><br><span class="line">PowerMockito.doReturn(...).when(T mock);</span><br><span class="line">Whitebox.invokeMethod(T.class, String methodToExpect, Obecject... arguments);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无返回值</span></span><br><span class="line">PowerMock.doNothing().when(T.class, String methodToExpect, Object... arguments);</span><br></pre></td></tr></table></figure></li>
</ol>
<br />
对于 spy 对象来说，`when().doReturn()` 仍然会执行指定方法的真实代码逻辑，虽然返回结果被修改了；而 `doReturn().when().METHOD()`，就确实屏蔽了指定方法。

<p>对于 mock 对象来说，这两者就没有区别。</p>
<p>参考</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/44239404">Mock/Spy 能力 - zhihu</a></li>
<li><a href="https://stackoverflow.com/questions/7391806/use-doreturn-to-partially-mock-static-method-with-powermockito">Use doReturn to partially mock static method with PowerMockito - StackOverflow</a></li>
<li><a href="https://stackoverflow.com/questions/55913409/donothing-when-for-private-void-method-itself-is-invoking-method">doNothing.When for private void method itself is invoking method - StackOverflow</a></li>
<li><a href="http://sangsoonam.github.io/2019/02/04/mockito-doreturn-vs-thenreturn.html">Mockito: doReturn vs thenReturn</a></li>
</ul>
<br />

<h1 id="6-验证方法"><a href="#6-验证方法" class="headerlink" title="6 验证方法"></a>6 验证方法</h1><p><strong>PS: 先调用外层方法，再验证外层方法内调用过的方法</strong></p>
<h2 id="6-1-普通方法"><a href="#6-1-普通方法" class="headerlink" title="6.1 普通方法"></a>6.1 普通方法</h2><ol>
<li><p>public 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证方法的调用和相关参数</span></span><br><span class="line">Mockito.verify(? Extends Object mock).METHOD(Object... arguments); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 只验证方法的调用，any()，any(T.class)，anyInt()，anyString()</span></span><br><span class="line">Mockito.verify(? Extends Object mock).METHOD(Mockito.any());  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证方法没有被调用</span></span><br><span class="line">Mockito.verify(? Extends Object mock, Mockito.never()).METHOD(Object... arguments); </span><br></pre></td></tr></table></figure>

<p>PS: </p>
<ul>
<li>以下的各类验证，对 Mockito.never() 的使用都可以参照这个例子。</li>
<li>[Mockito.ArgumentMatchers.]any() 是一个匹配器，它可以匹配 null 和任意对象。但它不能匹配 Java 的基础类型（int，double，boolean），可以使用 anyInt()，anyDouble()，anyBoolean() 来匹配。</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>非 public 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PowerMockito.verifyPrivate(Object object).invoke(<span class="string">&quot;MethodName&quot;</span>, Argument);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="6-2-静态方法"><a href="#6-2-静态方法" class="headerlink" title="6.2 静态方法"></a>6.2 静态方法</h2><p><strong>PS: 每个待验证的静态方法都需要一个 <code>verifyStatic()</code>。</strong></p>
<ol>
<li><p>public 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PowerMockito.mockStatic(Class&lt;?&gt; type);</span><br><span class="line"></span><br><span class="line">......  <span class="comment">// 调用方法</span></span><br><span class="line"></span><br><span class="line">PowerMockito.verifyStatic(Class&lt;T&gt; mockedClass, VerificationMode mode);</span><br><span class="line">T.STATIC_METHOD(Object... arguments);  <span class="comment">// 待验证的静态方法</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li><p>非 public 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PowerMockito.mockStatic(Class&lt;?&gt; type);</span><br><span class="line"></span><br><span class="line">......  <span class="comment">// 调用方法</span></span><br><span class="line"></span><br><span class="line">PowerMockito.verifyStatic(Class&lt;T&gt; mockedClass, VerificationMode mode);</span><br><span class="line">Whitebox.invokeMethod(Class&lt;T&gt; mockedClass, String methodToExecute, Object... arguments);  <span class="comment">// 待验证的静态方法</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>参考</p>
<ul>
<li><a href="https://www.baeldung.com/mockito-verify">Mockito Verify Cookbook</a></li>
<li><a href="https://stackoverflow.com/questions/32976855/powermockito-verifystatic-problems">PowerMockito.verifyStatic() problems - StackOverflow</a></li>
<li><a href="https://github.com/powermock/powermock/wiki/MockStatic">MockStatic - PowerMockito Docs</a></li>
</ul>
<br />

<h1 id="7-抑制方法"><a href="#7-抑制方法" class="headerlink" title="7 抑制方法"></a>7 抑制方法</h1><p>首先，对测试类使用类级注解 <code>@PrepareForTest(ClassWithEvilConstructor.class)</code>。</p>
<p>然后，分以下三种情况，实现对特定方法的抑制。</p>
<h2 id="7-1-普通方法"><a href="#7-1-普通方法" class="headerlink" title="7.1 普通方法"></a>7.1 普通方法</h2>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有参数</span></span><br><span class="line">PowerMockito.suppress(MemberMatcher.method(Class&lt;?&gt; declaringClass, String methodName, Class&lt;?&gt;... parameterTypes));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数</span></span><br><span class="line">PowerMockito.suppress(MemberMatcher.method(Class&lt;?&gt; declaringClass, String methodName);</span><br></pre></td></tr></table></figure>



<h2 id="7-2-静态方法"><a href="#7-2-静态方法" class="headerlink" title="7.2 静态方法"></a>7.2 静态方法</h2><p>先 mock 后 suppress</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PowerMockito.mockStatic(Class.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数</span></span><br><span class="line">PowerMockito.suppress(MemberMatcher.method(Class&lt;?&gt; declaringClass, String methodName, Class&lt;?&gt;... parameterTypes));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数</span></span><br><span class="line">PowerMockito.suppress(MemberMatcher.method(Class&lt;?&gt; declaringClass, String methodName);</span><br></pre></td></tr></table></figure>



<h2 id="7-3-构造方法"><a href="#7-3-构造方法" class="headerlink" title="7.3 构造方法"></a>7.3 构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有参数</span></span><br><span class="line">PowerMockito.suppress(MemberMatcher.constructor(Class&lt;T&gt; declaringClass, Class&lt;?&gt;... parameterTypes));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数</span></span><br><span class="line">PowerMockito.suppress(MemberMatcher.constructor(Class&lt;T&gt; declaringClass));</span><br></pre></td></tr></table></figure>



<p>参考</p>
<ul>
<li><a href="https://github.com/powermock/powermock/wiki/Suppress-Unwanted-Behavior">Suppress unwanted behavior - GitHub Wiki</a></li>
<li><a href="https://stackoverflow.com/questions/16458981/how-to-suppress-and-verify-private-static-method-calls">How to suppress and verify private static method calls?</a></li>
</ul>
<br />

<h1 id="8-与-Robolectric-协同"><a href="#8-与-Robolectric-协同" class="headerlink" title="8 与 Robolectric 协同"></a>8 与 Robolectric 协同</h1><ul>
<li><a href="https://github.com/robolectric/robolectric/wiki/Using-PowerMock">https://github.com/robolectric/robolectric/wiki/Using-PowerMock</a></li>
</ul>
<br />

<p><strong>以上！</strong></p>
<br />]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>testing</tag>
        <tag>PowerMock</tag>
      </tags>
  </entry>
  <entry>
    <title>重装系统中遇到的麻烦</title>
    <url>/Experience/questions-of-resetting-system/</url>
    <content><![CDATA[<p><strong>简述</strong>：每次重装系统都是一次全新的“体验”。这次遇到的麻烦是<code>UEFI</code>和<code>legacy</code>，<code>GPT</code>硬盘和<code>MBR</code>硬盘的冲突。重装完系统后还出现无法从硬盘启动（reboot and select proper boot device）的问题。</p>
<span id="more"></span>
<br />

<h1 id="1-UEFI方式和MBR格式的冲突"><a href="#1-UEFI方式和MBR格式的冲突" class="headerlink" title="1 UEFI方式和MBR格式的冲突"></a>1 UEFI方式和MBR格式的冲突</h1><h2 id="1-1-问题描述"><a href="#1-1-问题描述" class="headerlink" title="1.1 问题描述"></a>1.1 问题描述</h2><p>　　选择win10安装版本和格式化驱动器0之后，点击下一步时，出现如下错误：</p>
<blockquote>
<p>Windows无法安装到这个磁盘。选中的磁盘具有MBR分区表。在EFI系统上，Windows只能安装到GPT磁盘。</p>
</blockquote>
<h2 id="1-2-原因"><a href="#1-2-原因" class="headerlink" title="1.2 原因"></a>1.2 原因</h2><p>　　win8/win10系统均添加快速启动功能，预装的win8/win10电脑默认都是<code>UEFI</code>引导和<code>GPT</code>硬盘，传统的引导方式为<code>Legacy</code>引导和<code>MBR</code>硬盘，<code>UEFI</code>必须跟<code>GPT</code>对应，同理<code>Legacy</code>必须跟<code>MBR</code>对应。</p>
<p>　　如果BIOS开启<code>UEFI</code>，而硬盘分区表格式为<code>MBR</code>则无法安装；BIOS关闭<code>UEFI</code>而硬盘分区表格式为<code>GPT</code>也是无法安装Windows。</p>
<p>　　(注意事项：转换分区表格式会清空硬盘所有数据!)</p>
<h2 id="1-3-解决办法"><a href="#1-3-解决办法" class="headerlink" title="1.3 解决办法"></a>1.3 解决办法</h2><p>　　因为重装win10系统使用的<code>UEFI</code>引导方法，所以需要把驱动器0从<code>MBR</code>转化到<code>GPT</code>。解决步骤：</p>
<p>　　（1）在当前安装界面按住<code>Shift</code>+<code>F10</code>，唤出命令提示符窗口；</p>
<p>　　（2）输入<code>diskpark</code>，回车，进入<code>DISKPART</code>模式；</p>
<p>　　（3）输入<code>list disk</code>，回车，列出当前磁盘信息；</p>
<p>　　（4）输入<code>select disk 0</code>，回车，选中驱动器0；</p>
<p>　　（5）输入<code>clean</code>，回车，删除驱动器0的分区；</p>
<p>　　（6）输入<code>convert gpt</code>，回车，驱动器0转化为<code>GPT</code>格式，之后关闭命令提示符窗口即可。</p>
<br />
# 2 无法从硬盘启动

<h2 id="2-1-问题描述"><a href="#2-1-问题描述" class="headerlink" title="2.1 问题描述"></a>2.1 问题描述</h2><p>　　成功重装系统后，开机时出现如下提示：</p>
<blockquote>
<p>Reboot and Select proper Boot device<br>or Insert Boot Media in Selected device_</p>
</blockquote>
<h2 id="2-2-解决办法"><a href="#2-2-解决办法" class="headerlink" title="2.2 解决办法"></a>2.2 解决办法</h2><p>　　很懵逼！</p>
<p>　　最后尝试性地在Bios中的Advanced，将<code>OS support</code>从<code>Legacy OS</code>改成<code>UEFI OS</code>，保存后退出。这次启动，就成功进入win10系统。</p>
<p>　　原因，应该还是引导办法不对。但不知道为何，我明明成功在<code>GPT</code>格式硬盘上安装系统了，这说明引导方式是<code>UEFI</code>，但却还是发生这个错误。</p>
<br />

<h1 id="3-名词解释"><a href="#3-名词解释" class="headerlink" title="3 名词解释"></a>3 名词解释</h1><blockquote>
<p>MBR—-Master Boot Record（主引导扇区）</p>
<p>之所以叫“主引导扇区”，是因为它是存在于驱动器开始部分的一个特殊的启动扇区。这个扇区包含了已安装的操作系统的启动加载器和驱动器的逻辑分区信息。所谓启动加载器，是一小段代码，用于加载驱动器上其他分区上更大的加载器。</p>
<p>如果你安装了Windows，Windows启动加载器的初始信息就放在这个区域里——如果MBR的信息被覆盖导致Windows不能启动，你就需要使用Windows的MBR修复功能来使其恢复正常。如果你安装了Linux，则位于MBR里的通常会是GRUB加载器。 </p>
<p>MBR支持最大2TB磁盘，它无法处理大于2TB容量的磁盘。MBR还只支持最多4个主分区——如果你想要更多分区，你需要创建所谓“扩展分区”，并在其中创建逻辑分区。 </p>
</blockquote>
<p>-</p>
<blockquote>
<p>GPT—-GUID Partition Table（全局唯一标识分区表）</p>
<p>这是一个正逐渐取代MBR的新标准。它和UEFI相辅相成——UEFI用于取代老旧的BIOS，而GPT则取代老旧的MBR。之所以叫作“GUID分区表”，是因为你的驱动器上的每个分区都有一个全局唯一的标识符（globally unique identifier，GUID）——这是一个随机生成的字符串，可以保证为地球上的每一个GPT分区都分配完全唯一的标识符。 </p>
<p>这个标准没有MBR的那些限制。磁盘驱动器容量可以大得多，大到操作系统和文件系统都没法支持。它同时还支持几乎无限个分区数量，限制只在于操作系统——Windows支持最多128个GPT分区，而且你还不需要创建扩展分区。 </p>
<p>在MBR磁盘上，分区和启动信息是保存在一起的。如果这部分数据被覆盖或破坏，事情就麻烦了。相对的，GPT在整个磁盘上保存多个这部分信息的副本，因此它更为健壮，并可以恢复被破坏的这部分信息。</p>
<p>GPT还为这些信息保存了循环冗余校验码（CRC）以保证其完整和正确——如果数据被破坏，GPT会发觉这些破坏，并从磁盘上的其他地方进行恢复。而MBR则对这些问题无能为力——只有在问题出现后，你才会发现计算机无法启动，或者磁盘分区都不翼而飞了。</p>
</blockquote>
]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>experience</tag>
        <tag>system</tag>
        <tag>GPT</tag>
        <tag>MBR</tag>
      </tags>
  </entry>
  <entry>
    <title>「PyQt5」2. QPushButton 的 signals 和 slots</title>
    <url>/Python/PyQt5/signals-and-slots-of-button/</url>
    <content><![CDATA[<p><strong>简述</strong>：<code>Graphical Application</code>是事件驱动型的，和控制台或终端程序不同。所谓事件，就是诸如点击按钮、选择多选框中一条选项这样的用户行为。本文记录了<code>QPushButton</code>的<code>signals</code>和<code>slots</code>用法。</p>
<span id="more"></span>
<br />

<h1 id="1-名词解释"><a href="#1-名词解释" class="headerlink" title="1 名词解释"></a>1 名词解释</h1><ul>
<li><code>signal</code>翻译为信号，指事件发生时<code>PyQt5 widget</code>发送的信号。</li>
<li><code>slot</code>：翻译为槽（奇奇怪怪），是任何可调用的函数或方法。</li>
</ul>
<p>　　对于<code>QPushButton</code>来说，<code>signal</code>是点击按钮时<code>QPushButton</code>发送的<code>Clicked()</code>信号，<code>slot</code>可以是自己编写的可调用函数/方法，也可以是<code>PyQt5</code>自有的函数/方法。</p>
<h1 id="2-QPushButton的signals"><a href="#2-QPushButton的signals" class="headerlink" title="2 QPushButton的signals"></a>2 QPushButton的signals</h1><p>　　<a href="https://doc.qt.io/qtforpython/PySide2/QtWidgets/QPushButton.html?highlight=qpushbutton"><code>QPushButton</code></a>具有如下signal：</p>
<ul>
<li><a href="https://doc.qt.io/qtforpython/PySide2/QtWidgets/QAbstractButton.html#PySide2.QtWidgets.PySide2.QtWidgets.QAbstractButton.clicked"><code>clicked()</code></a>：This signal is emitted when the button is activated (i.e., pressed down then released while the mouse cursor is inside the button), when the shortcut key is typed, or when click() or animateClick() is called. Notably, this signal is not emitted if you call setDown(), setChecked() or toggle().</li>
<li><a href="https://doc.qt.io/qtforpython/PySide2/QtWidgets/QAbstractButton.html#PySide2.QtWidgets.PySide2.QtWidgets.QAbstractButton.pressed"><code>pressed()</code></a>：This signal is emitted when the button is pressed down.</li>
<li><a href="https://doc.qt.io/qtforpython/PySide2/QtWidgets/QAbstractButton.html#PySide2.QtWidgets.PySide2.QtWidgets.QAbstractButton.released"><code>released()</code></a>：This signal is emitted when the button is released.</li>
<li><a href="https://doc.qt.io/qtforpython/PySide2/QtWidgets/QAbstractButton.html#PySide2.QtWidgets.PySide2.QtWidgets.QAbstractButton.toggled"><code>toggled()</code></a>：This signal is emitted whenever a checkable button changes its state. </li>
<li><a href="https://doc.qt.io/qtforpython/PySide2/QtCore/QObject.html#PySide2.QtCore.PySide2.QtCore.QObject.destroyed"><code>destroyed()</code></a>：类被摧毁，信号不可阻断。</li>
<li><a href="https://doc.qt.io/qt-5/qobject.html#objectNameChanged"><code>objectNameChanged()</code></a>：类名变化。</li>
</ul>
<p>　　前四者继承自<code>PyQt5.QtWidgets.QWidget.QAbstractButton</code>，后二者继承自<code>PyQt5.QtCore.QObject</code>。</p>
<h1 id="3-实例"><a href="#3-实例" class="headerlink" title="3 实例"></a>3 实例</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QWidget, QPushButton, QApplication,</span><br><span class="line">                             QLabel, QGridLayout)</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> Qt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exmaple</span>(<span class="params">QWidget</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        </span><br><span class="line">        self.setup_ui()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup_ui</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.btn = QPushButton(<span class="string">&#x27;Click me&#x27;</span>)</span><br><span class="line">        self.btn.clicked.connect(self.prt)  <span class="comment"># 链接signal与slot</span></span><br><span class="line">        self.lbl = QLabel()</span><br><span class="line">        </span><br><span class="line">        self.grid = QGridLayout()</span><br><span class="line">        self.grid.addWidget(self.btn, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        self.grid.addWidget(self.lbl, <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        self.setLayout(self.grid)</span><br><span class="line">        self.grid.setSpacing(<span class="number">20</span>)  <span class="comment"># 控件与控件、控件与窗口边界之间的留白</span></span><br><span class="line">        self.setWindowTitle(<span class="string">&#x27;Example&#x27;</span>)</span><br><span class="line">        self.show()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.lbl.setText(<span class="string">&#x27;Clicked!&#x27;</span>)</span><br><span class="line">        self.lbl.setAlignment(Qt.AlignCenter)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    ex = Exmaple()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>

<p>　　<code>self.btn.clicked.connect(self.prt)</code>将<code>clicked()</code>与处理程序<code>prt()</code>链接起来，其中，<code>clicked()</code>是<code>signal</code>，<code>prt()</code>是<code>slot</code>。除此之外，还有另外一种链接办法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PyQt5.QtCore.QObject.connect(widget, QtCore.SIGNAL(‘signalname’), slot_function)</span><br></pre></td></tr></table></figure>

<br />
**以上！**
<br />








]]></content>
      <categories>
        <category>Python</category>
        <category>PyQt5</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pyqt5</tag>
        <tag>qpushbutton</tag>
        <tag>signal</tag>
        <tag>slot</tag>
        <tag>event-driven</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建简易 web 服务器过程中的问题</title>
    <url>/Python/questions-of-constructing-web-server/</url>
    <content><![CDATA[<p><strong>简述</strong>： <a href="https://github.com/aosabook/500lines"><strong><em>500 lines or less</em></strong></a> 是一本在Github上开源的Python教程书籍，内容包含有18个Python Project。正如书名，都是低于500行代码的Project。</p>
<p>　　不过，项目是基于<code>Python2</code>的，而我自学的是<code>Python3</code>，因此编写过程中遇到了2个问题。</p>
<p><br /><span id="more"></span></p>
<h1 id="1-库名变化"><a href="#1-库名变化" class="headerlink" title="1 库名变化"></a>1 库名变化</h1><h2 id="1-1-问题"><a href="#1-1-问题" class="headerlink" title="1.1 问题"></a>1.1 问题</h2><p>　　原Python2程序中导入了库 <code>BaseHTTPServer</code> ，但在Python3中，该库已经改为 <a href="https://docs.python.org/3/library/http.server.html"><code>http.server</code></a> 。</p>
<h2 id="1-2-解决办法"><a href="#1-2-解决办法" class="headerlink" title="1.2 解决办法"></a>1.2 解决办法</h2><p>　　<del><code>import BaseHTTPServer</code></del>  —&gt; <code>import http.server</code></p>
<p>　　就是这样，而已。</p>
<br />
# 2 网页编码

<h2 id="2-1-问题"><a href="#2-1-问题" class="headerlink" title="2.1 问题"></a>2.1 问题</h2><p>　　原Python2程序中有一段类似如下的html代码， </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Page = &quot;&quot;&quot;\</span><br><span class="line">    <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, web!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">    &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>　　但运行时出现 <code>TypeError: a bytes-like object is required, not &#39;str&#39;</code>。</p>
<h2 id="2-2-解决办法"><a href="#2-2-解决办法" class="headerlink" title="2.2 解决办法"></a>2.2 解决办法</h2><p>　　解决办法有两种，一种是使用前缀 <code>b</code> 将str转化为bytes；另一种是使用 <code>str.encode(&#39;utf-8&#39;)</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Page = b&quot;&quot;&quot;\</span><br><span class="line">    ...all the other code...</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">或者</span><br><span class="line">Page = &quot;&quot;&quot;\</span><br><span class="line">    ...all the other code...</span><br><span class="line">    &quot;&quot;&quot;.encode(&#x27;utf-8&#x27;)</span><br></pre></td></tr></table></figure>

<p>　　我在StackOverFlow上找到<a href="https://stackoverflow.com/questions/42612002/python-sockets-error-typeerror-a-bytes-like-object-is-required-not-str-with?noredirect=1&lq=1">相关解释</a>，大概意思是：在Python3中字符串是Unicode形式，但在网络中，数据应该是以字节的形式传输。</p>
<blockquote>
<p>The reason for this error is that in Python 3, strings are Unicode, but when transmitting on the network, the data needs to be bytes strings instead. So… a couple of suggestions:</p>
<p>……</p>
<p>Best solution:</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">output = <span class="string">&#x27;Thank you for connecting&#x27;</span></span><br><span class="line">c.sendall(output.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><br />以上！</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web Server</tag>
        <tag>HTTP</tag>
        <tag>存疑</tag>
      </tags>
  </entry>
  <entry>
    <title>「Java」为什么“多态”</title>
    <url>/Java/why-polymorphism/</url>
    <content><![CDATA[<p><strong>简述</strong>：多态（ <code>polymorphism</code> ）在 <code>OOP</code>（ <code>object-oriented programming</code>，面向对象编程）很常见，但却不好理解。窝以为窝懂了，后来发现自己原来不太懂。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一刻，窝还在盲人摸象，希望通过分析多态的优缺点来了解它。我自己摸索着去理解它，所以这些内容不一定是对的。</p>
<span id="more"></span>

<br />



<h1 id="1-多态"><a href="#1-多态" class="headerlink" title="1 多态"></a>1 多态</h1><p>简单地说，多态就是：</p>
<ol>
<li><strong>父类引用</strong>指向<strong>子类对象</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal a = <span class="keyword">new</span> Cat();  <span class="comment">// Animal 是 Cat 的父类。</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>子类要重写（ <code>Override</code> ）父类的方法。</li>
</ol>
<p>如果不了解多态，可以点<a href="https://www.zhihu.com/question/30082151"><strong>这里</strong></a>。</p>
<br />

<h1 id="2-优点"><a href="#2-优点" class="headerlink" title="2 优点"></a>2 优点</h1><p>鉴于参考内容的示例代码非常不错，窝就抄过来用了，见谅见谅。这里是<a href="https://www.zhihu.com/question/30082151/answer/120520568?utm_source=com.google.android.apps.docs&utm_medium=social"><strong>出处</strong></a>。</p>
<br />

<p>多态当然是有它的优点，才会被引入的嘛。</p>
<ol>
<li><p>通过继承和重写（ <code>Override</code> ）非静态方法，对父类进行特定的改写。</p>
<p>虽然引用变量 <code>a</code> 引用的是子类 <code>Cat</code> 的对象，但 <code>a</code> 能访问的是</p>
<ul>
<li><code>Animal</code> 的成员变量/常量</li>
<li><code>Animal</code>  的静态方法</li>
<li><code>Animal</code>  中<strong>未被子类 <code>Cat</code>重写</strong>的非静态方法</li>
<li> <code>Cat</code> 中<strong>重写</strong>的非静态方法。</li>
</ul>
<p>简单地说，就是不能访问 <code>Animal</code> 中那些被重写的非静态方法。</p>
<p>但是，经过强制转型（ <code>((Cat) a)</code> ），就又变了个样，比较魔幻了。看不懂不要紧，看代码就好了。</p>
<p>总结：<strong>父类引用指向子类对象，等于指向一个改变了（在子类中重写的）某些非静态方法的父类的对象</strong>。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line">        a.eat();  			<span class="comment">// 猫吃饭（被 Cat 重写的非静态方法）</span></span><br><span class="line">        a.sleep();			<span class="comment">// 动物睡觉（ Animal 的静态方法)</span></span><br><span class="line">        a.run();			<span class="comment">// 动物奔跑（没有被 Cat 重写的静态方法）</span></span><br><span class="line">        System.out.println(a.num);			<span class="comment">// 10</span></span><br><span class="line">        System.out.println(a.age);			<span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">        ((Cat) a).sleep();  <span class="comment">// 猫睡觉</span></span><br><span class="line">        System.out.println(((Cat) a).num);  <span class="comment">// 100</span></span><br><span class="line">        System.out.println(((Cat) a).age);  <span class="comment">// 100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物奔跑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>复用代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Animal a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> something with a.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>test</code> 函数时，传入参数可以是 <code>Animal</code> 的对象，也可以是 <code>Animal</code> 的子类的对象。</p>
<p>不需要针对 <code>Animal</code> 子类的对象重载（ <code>Overload</code> ）<code>test</code> 函数，如 <code>public void test(Cat c)</code> 。</p>
<ol start="3">
<li>其他。。。</li>
</ol>
<p>代码撸得不够多，想不出来了。</p>
<br />



<h1 id="3-缺点"><a href="#3-缺点" class="headerlink" title="3 缺点"></a>3 缺点</h1><ul>
<li>父类引用指向子类对象，无法通过父类引用访问子类的成员变量与静态方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line">        </span><br><span class="line">        a.catchMouse();</span><br><span class="line">        System.out.print(a.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出： 找不到对象的方法 <code>catchMouse()</code> 和 成员变量 <code>name</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error:(5, 10) java: cannot find symbol</span><br><span class="line">                         symbol:   method catchMouse()</span><br><span class="line">                         location: variable a of type Animal</span><br><span class="line">Error:(6, 27) java: cannot find symbol</span><br><span class="line">                         symbol:   variable name</span><br><span class="line">                         location: variable a of type Animal</span><br></pre></td></tr></table></figure>

<p>原因：父类 <code>Animal</code> 中没有方法 <code>catchMouse()</code>和成员变量 <code>name</code> 。</p>
<br />



<h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h1><ul>
<li><a href="https://www.zhihu.com/question/30082151">JAVA的多态用几句话能直观的解释一下吗？ - zhihu</a></li>
<li><a href="https://stackoverflow.com/questions/14997202/creating-object-with-reference-to-interface">Creating object with reference to Interface -  StackOverflow</a></li>
<li><a href="https://www.developer.com/java/data/diving-deeper-into-polymorphism-and-its-benefits-in-java.html">Diving Deeper into Polymorphism and its Benefits in Java - developer</a></li>
</ul>
<br />



<p><strong>以上</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>polymorphism</tag>
        <tag>advantage</tag>
        <tag>disadvange</tag>
      </tags>
  </entry>
  <entry>
    <title>「C++」vector 用法</title>
    <url>/C/vector/</url>
    <content><![CDATA[<p><strong>简述</strong>：<code>vector</code>是<code>C++</code>标准程序库中的一个类，众多容器（<code>container</code>）之一，可视为会自动扩展容量的数组，以循序(<code>sequential</code>)的方式维护变量集合，是一种非常实用的容器。</p>
<span id="more"></span>

<br />
# 1 vector介绍
　　`vector`以模板(泛型)方式实现，可以保存任意类型的变量，包括用户自定义的数据类型，例如：它可以是放置整数（`Int`）类型的 `vector`、也可以是放置字符串（`string`）类型的 `vector`、或者放置用户自定类别（`user-defined class`）的`vector`。
　　`vector`的特色有支持随机存取，在集合尾端增删元素很快，但是在集合中间增删元素比较费时。
　　`vector`类定义于`<vector>`头文件中。
<br />

<br />
# 2 vector类的方法

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span> </span></span><br><span class="line">std:: vector&lt;TYPE&gt; vec;</span><br></pre></td></tr></table></figure>
<ul>
<li>访问元素<ul>
<li><code>vec[i]</code> - 访问索引值为<code>i</code>的元素引用。 (索引值从零起算，故第一个元素是<code>vec[0]</code>。)</li>
<li><code>vec.at(i)</code> - 访问索引值为<code>i</code>的元素的引用，以<code>at()</code>访问会做数组边界检查，如果访问越界将会抛出一个异常，这是与<code>operator[]</code>的唯一差异。</li>
<li><code>vec.front()</code> - 回传<code>vector</code>第一个元素的引用。</li>
<li><code>vec.back()</code> - 回传<code>vector</code>最尾端元素的引用。</li>
</ul>
</li>
<li>新增或移除元素<ul>
<li><code>vec.push_back()</code> - 新增元素至<code>vector</code>的尾端，必要时会进行存储器配置。</li>
<li><code>vec.pop_back()</code> - 删除<code>vector</code>最尾端的元素。</li>
<li><code>vec.insert()</code> - 插入一个或多个元素至<code>vector</code>内的任意位置。</li>
<li><code>vec.erase()</code> - 删除<code>vector</code>中一个或多个元素。</li>
<li><code>vec.clear()</code> - 清空所有元素。</li>
</ul>
</li>
<li>获取长度/容量<ul>
<li><code>vec.size()</code> - 获取<code>vector</code>目前持有的元素个数。</li>
<li><code>vec.empty()</code> - 如果<code>vector</code>内部为空，则传回<code>true</code>值。</li>
<li><code>vec.capacity()</code> - 获取<code>vector</code>目前可容纳的最大元素个数。这个方法与存储器的配置有关，它通常只会增加，不会因为元素被删减而随之减少。</li>
</ul>
</li>
<li>重新配置／重置长度<ul>
<li><code>vec.reserve()</code> - 如有必要，可改变<code>vector</code>的容量大小（配置更多的存储器）。在众多的<code>STL</code>实例，容量只能增加，不可以减少。</li>
<li><code>vec.resize()</code> - 改变<code>vector</code>目前持有的元素个数。</li>
</ul>
</li>
<li>迭代 (Iterator)<ul>
<li><code>vec.begin()</code> - 回传一个<code>iterator</code>，它指向<code>vector</code>第一个元素。</li>
<li><code>vec.end()</code> - 回传一个<code>iterator</code>，它指向<code>vector</code>最尾端元素的下一个位置（请注意：它不是最末元素）。</li>
<li><code>vec.rbegin()</code> - 回传一个反向<code>iterator</code>，它指向<code>vector</code>最尾端元素的。</li>
<li><code>vec.rend()</code> - 回传一个<code>iterator</code>，它指向<code>vector</code>的第一个元素的前一个位置。</li>
</ul>
</li>
</ul>
<br />
# 3 二维vector

<h2 id="3-1-声明"><a href="#3-1-声明" class="headerlink" title="3.1 声明"></a>3.1 声明</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;vector&lt;TYPE&gt;&gt; VEC_NAME;  <span class="comment">//VEC_NAME: 容器名</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-增添元素"><a href="#3-2-增添元素" class="headerlink" title="3.2 增添元素"></a>3.2 增添元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;vector&lt;TYPE&gt; VEC_NAME;</span><br><span class="line">VEC_NAME[0].push_back(element); //在容器内的第一子容器末添加值为element的数据，容量size变大</span><br></pre></td></tr></table></figure>

<h2 id="3-3-删减元素"><a href="#3-3-删减元素" class="headerlink" title="3.3 删减元素"></a>3.3 删减元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;vector&lt;TYPE&gt;&gt;　VEC_NAME;</span><br><span class="line">VEC_NAME[<span class="number">0</span>].<span class="built_in">pop_back</span>();  <span class="comment">//删减容器内第一子容器的末元素，不返回元素</span></span><br></pre></td></tr></table></figure>

<p>以上！</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>「Java」内存屏障和 Java 并发</title>
    <url>/Java/memory-barriers-and-java-concurrency/</url>
    <content><![CDATA[<p><strong>简述：</strong>本文是 InfoQ 上一篇<a href="https://www.infoq.com/articles/memory_barriers_jvm_concurrency/">文章</a>的译文，文中略有不通顺之处。</p>
<span id="more"></span>

<br />

<p>内存屏障，或者说内存栅栏，是一组用于限制内存操作的执行顺序的 CPU 指令。本文将解析内存屏障对多线程程序的影响，具体到内存屏障和 JVM 并发结构（如 <code>volatile</code>、<code>synchronized</code> 和 <code>Atomic</code> 类）之间的关系。读者需要对这些概念和 Java 内存模型有扎实的理解。不过，文章并不打算阐述互斥（<code>mutual exclusion</code>），并行（<code>parallelism</code>）或者原子性（<code>atomicity</code>）。内存屏障用于实现一个很重要的并发编程基本特性，即 <code>可见性</code>。</p>
<p>感谢 Brian Goetz 和 Eric Yew 对文章的审阅工作，同时也感谢 Christian Thalinger 提供的 <code>SPARC</code> 框架设备。</p>
<br />



<h1 id="1-为什么内存屏障如此重要"><a href="#1-为什么内存屏障如此重要" class="headerlink" title="1 为什么内存屏障如此重要"></a>1 为什么内存屏障如此重要</h1><p>访问主内存（<code>main memory</code>）一次需要数以百计个时钟周期（<code>clock cycle</code>）。CPU 使用缓存（<code>cache</code>）将内存延迟（<code>memory latency</code>）的开销降低了几个数量级。为了提高性能，缓存会对挂起（<code>pending</code>）的内存操作进行重排序（<code>re-order</code>）。也就是说，程序的读/写操作不一定按照代码顺序来执行。 </p>
<p>当数据是不可变的（<code>immutable</code>）或被封闭在某个线程内（<code>confined to the scope of one thread</code>）时，这种优化不会改变程序结果。然而，当指令重排序遇上对称多处理（<code>symmetric multi-processing</code>）和共享可变状态（<code>shared mutable state</code>）这些情况时，可能会是一场噩梦。 对共享可变数据的内存操作进行重排序时，程序运行结果会变得不确定，比如一个线程可能以与代码顺序不一致的顺序来修改对另一个线程可见（<code>visible</code>）的值。不过，内存屏障可以通过让处理器序列化（<code>serialize</code>）挂起（<code>pending</code>）的内存操作来避免这个问题。</p>
<br />



<h1 id="2-内存屏障作为协议"><a href="#2-内存屏障作为协议" class="headerlink" title="2 内存屏障作为协议"></a>2 内存屏障作为协议</h1><p>JVM 并不直接显露内存屏障。（Memory barriers are not directly exposed by the JVM. ）反之，为了保证语言级的并发原语语义，它们被 JVM 插入到指令序列中。（Instead they are inserted into the instruction sequence by the JVM in order to uphold the semantics of language level concurrency primitives. ）我们将会看一些 Java 简单源码和其汇编指令，以了解其中原理。</p>
<p>让我们用 <code>Dekker&#39;s algorithm</code> ，来学习内存屏障的速成课程。该算法使用三个 volatile 变量（<code>intentFirst</code>、<code>intentSecond</code>、<code>turn</code>）来协调（<code>coordinate</code>）两个线程之间对共享资源的访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 线程 1                          // 线程 2</span></span><br><span class="line"> <span class="number">1</span>  intentFirst = <span class="keyword">true</span>;               intentSecond = <span class="keyword">true</span>;</span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span>  <span class="keyword">while</span> (intentSecond) &#123;            <span class="keyword">while</span> (intentFirst) &#123;     <span class="comment">// volatile 读</span></span><br><span class="line"> <span class="number">4</span>    	<span class="keyword">if</span> (turn != <span class="number">0</span>) &#123;                  <span class="keyword">if</span> (turn != <span class="number">1</span>) &#123;      <span class="comment">// volatile 读</span></span><br><span class="line"> <span class="number">5</span>    	    intentFirst = <span class="keyword">false</span>;              intentSecond = <span class="keyword">false</span>;</span><br><span class="line"> <span class="number">6</span>          <span class="keyword">while</span> (turn != <span class="number">0</span>) &#123;&#125;              <span class="keyword">while</span> (turn != <span class="number">1</span>) &#123;&#125;</span><br><span class="line"> <span class="number">7</span>         intentFirst = <span class="keyword">true</span>;               intentSecond = <span class="keyword">true</span>;</span><br><span class="line"> <span class="number">8</span>      &#125;                                 &#125;</span><br><span class="line"> <span class="number">9</span>  &#125;                                 &#125;</span><br><span class="line"><span class="number">10</span>  criticalSection();                criticalSection();</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span>  turn = <span class="number">1</span>;                         turn = <span class="number">0</span>;                 <span class="comment">// volatile 写</span></span><br><span class="line"><span class="number">13</span>  intentFirst = <span class="keyword">false</span>;              intentSecond = <span class="keyword">false</span>;     <span class="comment">// volatile 写</span></span><br></pre></td></tr></table></figure>

<p>不要关注这个算法的细节。那么，该看些什么呢？</p>
<p>仔细看，每个线程都试图在第一行通过将自己的 <code>intent</code> 置为 <code>true</code> 来进入临界区（<code>critical section</code>）。如果一个线程在第三行观察（<code>observe</code>）到冲突（即两个线程的 <code>intent</code> 都为 <code>true</code>），那么将通过轮流执行（<code>turn taking</code>）来解决冲突。在给定的时间点上，只有一个线程可以访问临界区。</p>
<p>硬件优化（<code>hardware optimizations</code>）在没有内存屏障的情况下会使代码运行结果变得不确定，即使编译器以代码顺序来编译这些内存操作。</p>
<ul>
<li>看第 3 行和第 4 行上的两个连续的 <code>volatile</code> 读操作。每个线程都会检查另一个线程是否有进入临界区的 <code>intent</code>，再检查轮到谁了。</li>
<li>看第 12 行和第 13 行上的两个连续的 <code>volatile</code> 写操作。每个线程将变量 <code>turn</code> 改为另一个线程对应的值，并且将自己进入临界区的 <code>intent</code> 置为 <code>false</code>。</li>
</ul>
<p>读线程不应该在另一个线程将其 <code>intent</code> 置为 <code>false</code> 后才观察到那个线程对变量 <code>turn</code> 的写操作，这将是一场灾难（A reading thread should never expect to observe the other thread’s write to the turn variable after the other thread’s withdrawal of intent. This would be a disaster. ）。但如果没有用 <code>volatile</code> 修饰这些变量，就会发生这种情况！比如，假如没有 <code>volatile</code> ，在线程 1 对变量 <code>turn</code> 写入(线程 1 倒数第二行)之前，线程 2 可能可以观察到线程 1 对 <code>intentFirst</code> 的写入(线程 1 最后一行)。</p>
<p>关键字 <code>volatile</code> 可以避免这个问题，因为它在对 <code>turn</code> 变量的写入和对 <code>intentFirst</code> 变量的写入之间建立了一个 <em><code>happens before</code></em> 关系（The keyword volatile prevents this problem because it establishes a <em>happens before</em> relationship between the write to the turn variable and the write to the intentFirst variable. ）。编译器不能对这些写操作重排序，如果必须的话，它就会使用内存屏障来禁止处理器的重排序。</p>
<p>HotSpot 选项 <code>PrintAssembly</code> 是 JVM 的一个诊断标志（diagnostic flag），它能够让我们获取 JIT 编译器生成的汇编指令。这需要最新的 OpenJDK 版本（update 14 或以上）或新版 HotSpot。另外还需要一个反汇编插件。Kenai 就有适合 Solaris、Linux 和 BSD 平台的插件。hsdis 插件可以作为 Windows 平台上的替代方案。</p>
<p>源码中第 3 行连续的两个读操作中的第一个体现在下面的汇编指令中。环境是多核 CPU Itanium 2，JDK 1.6（Update 17）。</p>
<p>下面的所有汇编指令，所有指令流都是按照左侧的行号进行排序的。相关的读操作、写操作和内存屏障指令都有前缀 <code>*</code>。建议读者不要陷入对每条指令的语义思考中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(Itanium)</span><br><span class="line">1  0x2000000001de819c:  adds r37=597, r36      ;...84112554</span><br><span class="line">2* 0x2000000001de81a0:  ld1.acq r38=[r37]      ;...0b30014a a010</span><br><span class="line">3  0x2000000001de81a6:  nop.m 0x0              ;...00000002 00c0</span><br><span class="line">4  0x2000000001de81ac:  sxt1 r38=r38           ;...00513004</span><br><span class="line">5  0x2000000001de81b0:  cmp4.eq p0, p6=0, r38  ;...1100004c 8639</span><br><span class="line">6  0x2000000001de81b6:  nop.i 0x0              ;...00000002 0003</span><br><span class="line">7  0x2000000001de81bc:  br.cond.dpnt.many 0x2000000001de8220;;</span><br></pre></td></tr></table></figure>

<p>这些简短的指令说来就话长了。第一个 <code>volatile</code> 读在第 2 行。Java 内存模型保证 JVM 会在第二次 <code>volatile</code> 读之前，按<strong>程序顺序</strong>将第一个 <code>volatile</code> 读传递给 CPU 。但这还不够，因为 CPU 仍然可以乱序执行这些操作。为了维护 Java 内存模型的一致性，JVM 使用带参数的 <code>ld.acq</code> （<code>load acquire</code>）来注释（<code>annotate</code>）第一个 <code>volatile</code> 读操作。通过使用 <code>ld.acq</code> ，编译器可以确保第 2 行上的读操作在后续的读操作之前完成。这样，问题就解决了。</p>
<p>注意，这影响的是读，而不是写。这里需要介绍一下单向内存屏障和双向内存屏障。</p>
<ul>
<li><strong>单向</strong>内存屏障：对读 <strong>或</strong> 写强制排序。<code>ld.acq</code> 就是一个例子。</li>
<li><strong>双向</strong>内存屏障：对读 <strong>和</strong> 写强制排序。</li>
</ul>
<p>一致性是双向的。（Consistency is a two way street. ）<strong>如果另一个线程没有将写操作和写操作分开（<code>separate</code>），那么读线程在两次读操作之间插入一个内存屏障有什么用呢？</strong>为了让线程间进行通信，它们都必须遵守协议（<code>protocol</code>），就像网络中的节点，或者团队中的人。如果一个线程不遵守协议，那么其他线程的工作（<code>effort</code>）就没有意义。在 <code>Dekker&#39;s algorithm</code> 中最后两行代码（即两个 <code>volatile</code> 写操作）对应的汇编指令中，我们会看到一个内存屏障。</p>
<blockquote>
<p>$ java -XX:+UnlockDiagnosticVMOptions -XX:PrintAssemblyOptions=hsdis-print-bytes -XX:CompileCommand=print,WriterReader.write WriterReader</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(Itanium)</span><br><span class="line"> 1  0x2000000001de81c0: adds r37=592,r36    ;...0b284149 0421</span><br><span class="line"> 2  0x2000000001de81c6: st4.rel [r37]=r39   ;...00389560 2380</span><br><span class="line"> 3  0x2000000001de81cc: adds r36=596,r36    ;...84112544</span><br><span class="line"> 4* 0x2000000001de81d0: st1.rel [r36]=r0    ;...09000048 a011</span><br><span class="line"> 5* 0x2000000001de81d6: mf                  ;...00000044 0000</span><br><span class="line"> 6  0x2000000001de81dc: nop.i 0x0           ;...00040000</span><br><span class="line"> 7  0x2000000001de81e0: mov r12=r33         ;...00600042 0021</span><br><span class="line"> 8  0x2000000001de81e6: mov.ret b0=r35,0x2000000001de81e0</span><br><span class="line"> 9  0x2000000001de81ec: mov.i ar.pfs=r34    ;...00aa0220</span><br><span class="line">10  0x2000000001de81f0: mov r6=r32          ;...09300040 0021</span><br></pre></td></tr></table></figure>

<p>在第 4 行，我们可以看到第二个写操作用<strong>显式</strong>内存屏障进行了注释（<code>annotate</code>）。通过使用带参数的 <code>st.rel</code>（或 <code>store release</code>），编译器可以确保第一个写操作在第二个写操作之前是<strong>可见的</strong>。这就达成了协议的双向性（This completes both sides of the protocol），因为第一个写操作发生在第二个写操作之前。</p>
<p>指令 <code>st.rel</code> 是<strong>单向</strong>内存屏障，就像 <code>ld.acq</code> 一样。但是，在第 5 行，编译器还添加了一个<strong>双向</strong>内存屏障。指令 <code>mf</code>（<code>memory fence</code>），是 Itanium 2 指令集中的一个<strong>完全</strong>内存屏障（<code>fully fence</code>）。</p>
<br />



<h1 id="3-内存屏障是硬件特性"><a href="#3-内存屏障是硬件特性" class="headerlink" title="3 内存屏障是硬件特性"></a>3 内存屏障是硬件特性</h1><p>本文不打算对所有内存屏障做全面概述，这太费时费力了。重要的是要认识到，内存屏障的指令在不同的硬件架构中有相当大的差异。下面是在多核 CPU Intel Xeon 上获取的连续 <code>volatile</code> 写操作的汇编指令。本文中余下所有汇编指令都是基于 Intel Xeon 的，除非另有说明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> （Intel Xeon x86)</span><br><span class="line"> 1  0x03f8340c: push   %ebp                     ;...55</span><br><span class="line"> 2  0x03f8340d: sub    $0x8, %esp               ;...81ec0800 0000</span><br><span class="line"> 3  0x03f83413: mov    $0x14c, %edi             ;...bf4c0100 00</span><br><span class="line"> 4  0x03f83418: movb   $0x1, -0x505a72f0(%edi)  ;...c687108d a5af01</span><br><span class="line"> 5  0x03f8341f: mfence                          ;...0faef0</span><br><span class="line"> 6  0x03f83422: mov    $0x148, %ebp             ;...bd480100 00</span><br><span class="line"> 7  0x03f83427: mov    $0x14d, %edx             ;...ba4d0100 00</span><br><span class="line"> 8  0x03f8342c: movsbl -0x505a72f0(%edx), %ebx  ;...0fbe9a10 8da5af</span><br><span class="line"> 9  0x03f83433: test   %ebx, %ebx               ;...85db</span><br><span class="line">10  0x03f83435: jne    0x03f83460               ;...7529</span><br><span class="line">11  0x03f83437: movl   $0x1, -0x505a72f0(%ebp)  ;...c785108d a5af01</span><br><span class="line">12  0x03f83441: movb   $0x0, -0x505a72f0(%edi)  ;...c687108d a5af00</span><br><span class="line">13* 0x03f83448: mfence                          ;...0faef0</span><br><span class="line">14  0x03f8344b: add    $0x8,%esp                ;...83c408</span><br><span class="line">15  0x03f8344e: pop    %ebp                     ;...5d</span><br></pre></td></tr></table></figure>

<p>基于 x86 Xeon 的汇编指令第 11 行和第 12 行，我们看到 <strong><code>volatile</code> 写操作</strong>。第二个写操作后有一个 <code>mfence</code> 指令（第 13 行），这是一个<strong>显式</strong>的<strong>双向</strong>内存屏障。</p>
<p>下面是基于 <code>SPARC</code> 的连续 <code>volatile</code> 写操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(SPARC)</span><br><span class="line"> 1  0xfb8ecc84: ldub [ %l1 + 0x155 ], %l3    ;...e60c6155</span><br><span class="line"> 2  0xfb8ecc88: cmp  %l3, 0                  ;...80a4e000</span><br><span class="line"> 3  0xfb8ecc8c: bne, pn %icc, 0xfb8eccb0     ;...12400009</span><br><span class="line"> 4  0xfb8ecc90: nop                          ;...01000000</span><br><span class="line"> 5  0xfb8ecc94: st  %l0, [ %l1 + 0x150 ]     ;...e0246150</span><br><span class="line"> 6  0xfb8ecc98: clrb  [ %l1 + 0x154 ]        ;...c02c6154</span><br><span class="line"> 7* 0xfb8ecc9c: membar  #StoreLoad           ;...8143e002</span><br><span class="line"> 8  0xfb8ecca0: sethi  %hi(0xff3fc000), %l0  ;...213fcff0</span><br><span class="line"> 9  0xfb8ecca4: ld  [ %l0 ], %g0             ;...c0042000</span><br><span class="line">10  0xfb8ecca8: ret                          ;...81c7e008</span><br><span class="line">11  0xfb8eccac: restore                      ;...81e80000</span><br></pre></td></tr></table></figure>

<p>在第 5 行和第 6 行可以看到 <strong><code>volatile</code> 写操作</strong>。第二个写操作后跟随有 <code>membar</code> 指令（第 7 行），这也是一个<strong>显式</strong>的<strong>双向</strong>内存屏障。</p>
<p><code>x86</code> 和 <code>SPARC </code> 的指令流与 <code>Itanium</code> 的指令流之间有一个重要的区别。<strong>JVM 在 <code>x86</code> 和 <code>SPARC</code> 上在连续的写操作后设置了内存屏障，但是在这两个写操作之间没有设置内存屏障。然而，<code>Itanium</code> 的指令流在两个写操作之间有一个内存屏障。</strong></p>
<p>为什么 JVM 在不同的硬件架构中表现不同？</p>
<p>因为每种硬件架构都有一个内存模型，每个内存模型都有自己的一套一致性保证（<code>consistent guarantee</code>）体系。比如 <code>x86</code> 或 <code>SPARC</code> 的内存模型，有非常强大的一致性保证。其他内存模型，如 <code>Itanium</code>、<code>PowerPC</code> 或 <code>Alpha</code>，则较为宽松（<code>relaxed</code>）。比如，<code>x86</code> 和 <code>SPARC</code> 不会重排序连续的写操作，所以不需要内存屏障。而 <code>Itanium</code>、<code>PowerPC</code> 和 <code>Alpha</code> 会对连续的写操作进行重排序，因此 JVM 必须在写操作之间设置一个内存屏障。</p>
<p><strong>也就是说，JVM 使用内存屏障来消除 Java 内存模型和硬件的内存模型之间的差异。</strong></p>
<br />



<h1 id="4-隐式内存屏障"><a href="#4-隐式内存屏障" class="headerlink" title="4 隐式内存屏障"></a>4 隐式内存屏障</h1><p>显式的指令 <code>fence</code> 不是序列化（<code>serialize</code>）内存操作的唯一方法。让我们来看看 <code>Counter</code> 类这个例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] _)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">            inc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        counter += <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Counter</code> 类中有一个经典的“读 - 修改 - 写”操作。因为这三个操作一定是原子操作（即组合起来就不是原子操作）， 所以不能用 <code>volatile</code> 修饰静态字段 <code>counter</code> ，得用 <code>synchronized</code> 修饰方法 <code>inc()</code>。我们可以使用以下命令编译 <code>Counter</code> 类并查看方法 <code>inc()</code> 生成的汇编指令。Java 内存模型为 <code>synchronized</code> 区域的退出操作（<code>exiting of synchronized regions</code>） 提供了与 <code>volatile</code> 内存操作（<code>volatile memory operations</code>）相同的可见性语义（<code>visibility semantics</code>），因此我们会看到另一种内存屏障。</p>
<blockquote>
<p>$ java -XX:+UnlockDiagnosticVMOptions -XX:PrintAssemblyOptions=hsdis-print-bytes -XX:-UseBiasedLocking -XX:CompileCommand=print,Counter.inc Counter</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(Intel Xeon)</span><br><span class="line"> 1  0x04d5eda7: push   %ebp               ;...55</span><br><span class="line"> 2  0x04d5eda8: mov    %esp,%ebp          ;...8bec</span><br><span class="line"> 3  0x04d5edaa: sub    $0x28,%esp         ;...83ec28</span><br><span class="line"> 4  0x04d5edad: mov    $0x95ba5408,%esi   ;...be0854ba 95</span><br><span class="line"> 5  0x04d5edb2: lea    0x10(%esp),%edi    ;...8d7c2410</span><br><span class="line"> 6  0x04d5edb6: mov    %esi,0x4(%edi)     ;...897704</span><br><span class="line"> 7  0x04d5edb9: mov    (%esi),%eax        ;...8b06</span><br><span class="line"> 8  0x04d5edbb: or     $0x1,%eax          ;...83c801</span><br><span class="line"> 9  0x04d5edbe: mov    %eax,(%edi)        ;...8907</span><br><span class="line">10* 0x04d5edc0: lock cmpxchg %edi,(%esi)  ;...f00fb13e</span><br><span class="line">11  0x04d5edc4: je     0x04d5edda         ;...0f841000 0000</span><br><span class="line">12  0x04d5edca: sub    %esp,%eax          ;...2bc4</span><br><span class="line">13  0x04d5edcc: and    $0xfffff003,%eax   ;...81e003f0 ffff</span><br><span class="line">14  0x04d5edd2: mov    %eax,(%edi)        ;...8907</span><br><span class="line">15  0x04d5edd4: jne    0x04d5ee11         ;...0f853700 0000</span><br><span class="line">16  0x04d5edda: mov    $0x95ba52b8,%eax   ;...b8b852ba 95</span><br><span class="line">17  0x04d5eddf: mov    0x148(%eax),%esi   ;...8bb04801 0000</span><br><span class="line">18* 0x04d5ede5: inc    %esi               ;...46</span><br><span class="line">19  0x04d5ede6: mov    %esi,0x148(%eax)   ;...89b04801 0000</span><br><span class="line">20  0x04d5edec: lea    0x10(%esp),%eax    ;...8d442410</span><br><span class="line">21  0x04d5edf0: mov    (%eax),%esi        ;...8b30</span><br><span class="line">22  0x04d5edf2: test   %esi,%esi          ;...85f6</span><br><span class="line">23  0x04d5edf4: je     0x04d5ee07         ;...0f840d00 0000</span><br><span class="line">24  0x04d5edfa: mov    0x4(%eax),%edi     ;...8b7804</span><br><span class="line">25* 0x04d5edfd: lock cmpxchg %esi,(%edi)  ;...f00fb137</span><br><span class="line">26  0x04d5ee01: jne    0x04d5ee1f         ;...0f851800 0000</span><br><span class="line">27  0x04d5ee07: mov    %ebp,%esp          ;...8be5</span><br><span class="line">28  0x04d5ee09: pop    %ebp               ;...5d</span><br></pre></td></tr></table></figure>

<p>不出意外，<code>synchronized</code> 生成的指令数量比 <code>volatile</code> 的多。多出部分可以在第 18 行找到，但 JVM 并没有插入<strong>显式</strong>内存屏障。相反，JVM 在第 10 行和第 25 行使用了两次带 <code>lock </code> 前缀的 <code>cmpxchg</code> 指令。（解释 <code>cmpxchg</code> 指令的语义超出了本文的范围。）值得注意的是，<code>lock cmpxchg</code> 不仅自动执行写操作，它还会刷新挂起（<code>flush pending</code>）的读和写操作。写操作将在所有后续内存操作之前都可见。如果我们使用 <code>java.util.concurrent.atomic</code> 来重构并运行 <code>Counter</code> 类，我们可以看到同样的技巧（<code>trick</code>）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger counter = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">        	counter.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>$ java -XX:+UnlockDiagnosticVMOptions -XX:PrintAssemblyOptions=hsdis-print-bytes -XX:CompileCommand=print,*AtomicInteger.incrementAndGet Counter</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(Intel Xeon)</span><br><span class="line"> 1  0x024451f7: push   %ebp               ;...55</span><br><span class="line"> 2  0x024451f8: mov    %esp,%ebp          ;...8bec</span><br><span class="line"> 3  0x024451fa: sub    $0x38,%esp         ;...83ec38</span><br><span class="line"> 4  0x024451fd: jmp    0x0244520a         ;...e9080000 00</span><br><span class="line"> 5  0x02445202: xchg   %ax,%ax            ;...6690</span><br><span class="line"> 6  0x02445204: test   %eax,0xb771e100    ;...850500e1 71b7</span><br><span class="line"> 7  0x0244520a: mov    0x8(%ecx),%eax     ;...8b4108</span><br><span class="line"> 8  0x0244520d: mov    %eax,%esi          ;...8bf0</span><br><span class="line"> 9  0x0244520f: inc    %esi               ;...46</span><br><span class="line">10  0x02445210: mov    $0x9a3f03d0,%edi   ;...bfd0033f 9a</span><br><span class="line">11  0x02445215: mov    0x160(%edi),%edi   ;...8bbf6001 0000</span><br><span class="line">12  0x0244521b: mov    %ecx,%edi          ;...8bf9</span><br><span class="line">13  0x0244521d: add    $0x8,%edi          ;...83c708</span><br><span class="line">14* 0x02445220: lock cmpxchg %esi,(%edi)  ;...f00fb137</span><br><span class="line">15  0x02445224: mov    $0x1,%eax          ;...b8010000 00</span><br><span class="line">16  0x02445229: je     0x02445234         ;...0f840500 0000</span><br><span class="line">17  0x0244522f: mov    $0x0,%eax          ;...b8000000 00</span><br><span class="line">18  0x02445234: cmp    $0x0,%eax          ;...83f800</span><br><span class="line">19  0x02445237: je     0x02445204         ;...74cb</span><br><span class="line">20  0x02445239: mov    %esi,%eax          ;...8bc6</span><br><span class="line">21  0x0244523b: mov    %ebp,%esp          ;...8be5</span><br><span class="line">22  0x0244523d: pop    %ebp               ;...5d</span><br></pre></td></tr></table></figure>

<p>在第 14 行，我们再次看到写操作有 <code>lock</code> 前缀。这将确保在所有后续内存操作之前，变量的新值对其他线程都可见。</p>
<br />



<h1 id="5-内存屏障可被消除"><a href="#5-内存屏障可被消除" class="headerlink" title="5 内存屏障可被消除"></a>5 内存屏障可被消除</h1><p>JVM 知道如何消除不必要的内存屏障。</p>
<p>如果硬件内存模型的一致性保证（<code>consistency guarantee</code>）强于等于 Java 内存模型的一致性保证，这种情况下就比较简单，JVM 只会插入 <code>no op</code>，而不是实际的内存屏障。例如，<code>x86</code> 和 <code>SPARC</code> 硬件的内存模型的一致性保证足够强大，在读取 <code>volatile</code> 变量时就无需设置内存屏障。</p>
<p>还记得在 <code>Itanium</code> 上用来分隔两个读操作的显式单向内存屏障（<code>ld.acq</code>）吗？没错，在 <code>x86</code> 上 <code>Dekker&#39;s algorithm</code> 中连续的 <code>volatile</code> 读操作的汇编指令没有内存屏障。</p>
<p>在 <code>x86</code> 上，对共享内存的连续读操作。（A read followed by a read of shared memory on x86.）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(x86 Dekker)</span><br><span class="line"> 1  0x03f83422: mov    $0x148,%ebp             ;...bd480100 00</span><br><span class="line"> 2  0x03f83427: mov    $0x14d,%edx             ;...ba4d0100 00</span><br><span class="line"> 3* 0x03f8342c: movsbl -0x505a72f0(%edx),%ebx  ;...0fbe9a10 8da5af</span><br><span class="line"> 4  0x03f83433: test   %ebx,%ebx               ;...85db</span><br><span class="line"> 5  0x03f83435: jne    0x03f83460              ;...7529</span><br><span class="line"> 6  0x03f83437: movl   $0x1,-0x505a72f0(%ebp)  ;...c785108d a5af01</span><br><span class="line"> 7  0x03f83441: movb   $0x0,-0x505a72f0(%edi)  ;...c687108d a5af00</span><br><span class="line"> 8  0x03f83448: mfence                         ;...0faef0</span><br><span class="line"> 9  0x03f8344b: add    $0x8,%esp               ;...83c408</span><br><span class="line">10  0x03f8344e: pop    %ebp                    ;...5d</span><br><span class="line">11  0x03f8344f: test   %eax,0xb78ec000         ;...850500c0 8eb7</span><br><span class="line">12  0x03f83455: ret                            ;...c3</span><br><span class="line">13  0x03f83456: nopw   0x0(%eax,%eax,1)        ;...66660f1f 840000</span><br><span class="line">14* 0x03f83460: mov    -0x505a72f0(%ebp),%ebx  ;...8b9d108d a5af</span><br><span class="line">15  0x03f83466: test   %edi,0xb78ec000         ;...853d00c0 8eb7</span><br></pre></td></tr></table></figure>

<p><code>volatile</code> 读操作位于第 3 行和第 14 行。它们都没有配以内存屏障。换句话说，在 <code>x86</code> 上（或者在 <code>SPARC</code> 上）执行 <code>volatile</code> 读操作时，唯一的性能损失就是不能对指令重排优化，指令本身与普通读操作没有什么不同。</p>
<p>另外，单向内存屏障的开销自然要比双向的低。当 JVM 知道单向内存屏障已经足够时，它就不会使用双向内存屏障，本文中的第一个示例证明了这一点。我们看到 <code>Itanium</code> 上两个连续的 <code>volatile</code> 读操作中的第一个使用一个单向内存屏障（<code>ld.acq</code>）进行注释（<code>annotate</code>）。如果使用显式的双向内存屏障对读操作进行注释）进行注释（<code>annotate</code>），程序仍然是正确的，但延迟开销（<code>latency cost</code>）会增大。</p>
<br />



<h1 id="6-动态编译"><a href="#6-动态编译" class="headerlink" title="6 动态编译"></a>6 动态编译</h1><p>静态编译器在构建时所知道的事情，动态编译器在运行时都会知道，甚至更多。更多的信息意味着更多的优化可能。例如，让我们看看 JVM 在单处理器上运行时如何使用内存屏障。下面的指令流是 <code>Dekker</code> 算法中两个连续的 <code>volatile</code> 写操作的运行时编译结果。环境是 VMWare WorkStation 里的单处理器模式 <code>x86</code> 镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(x86) </span><br><span class="line"> 1  0x017b474c: push   %ebp                    ;...55</span><br><span class="line"> 2  0x017b474d: sub    $0x8,%esp               ;...81ec0800 0000</span><br><span class="line"> 3  0x017b4753: mov    $0x14c,%edi             ;...bf4c0100 00</span><br><span class="line"> 4  0x017b4758: movb   $0x1,-0x507572f0(%edi)  ;...c687108d 8aaf01</span><br><span class="line"> 5  0x017b475f: mov    $0x148,%ebp             ;...bd480100 00</span><br><span class="line"> 6  0x017b4764: mov    $0x14d,%edx             ;...ba4d0100 00</span><br><span class="line"> 7  0x017b4769: movsbl -0x507572f0(%edx),%ebx  ;...0fbe9a10 8d8aaf</span><br><span class="line"> 8  0x017b4770: test   %ebx,%ebx               ;...85db</span><br><span class="line"> 9  0x017b4772: jne    0x017b4790              ;...751c</span><br><span class="line">10* 0x017b4774: movl   $0x1,-0x507572f0(%ebp)  ;...c785108d 8aaf01</span><br><span class="line">11* 0x017b477e: movb   $0x0,-0x507572f0(%edi)  ;...c687108d 8aaf00</span><br><span class="line">12  0x017b4785: add    $0x8,%esp               ;...83c408</span><br><span class="line">13  0x017b4788: pop    %ebp                    ;...5d</span><br></pre></td></tr></table></figure>

<p>在单处理器系统中，JVM 为<strong>所有</strong>内存屏障插入 <code>no op</code>，因为内存操作已经序列化（<code>serialize</code>）了。写操作（第 10 行和第 11 行）后不会有内存屏障。JVM 对 <code>atomic</code> 类进行了类似的优化（第 14 行）。下面是在相同的 <code>VMWare</code> 镜像中， <code>AtomicInteger.incrementAndGet()</code> 的运行时编译结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(x86)</span><br><span class="line"> 1  0x036880f7: push   %ebp               ;...55</span><br><span class="line"> 2  0x036880f8: mov    %esp,%ebp          ;...8bec</span><br><span class="line"> 3  0x036880fa: sub    $0x38,%esp         ;...83ec38</span><br><span class="line"> 4  0x036880fd: jmp    0x0368810a         ;...e9080000 00</span><br><span class="line"> 5  0x03688102: xchg   %ax,%ax            ;...6690</span><br><span class="line"> 6  0x03688104: test   %eax,0xb78b8100    ;...85050081 8bb7</span><br><span class="line"> 7  0x0368810a: mov    0x8(%ecx),%eax     ;...8b4108</span><br><span class="line"> 8  0x0368810d: mov    %eax,%esi          ;...8bf0</span><br><span class="line"> 9  0x0368810f: inc    %esi               ;...46</span><br><span class="line">10  0x03688110: mov    $0x9a3f03d0,%edi   ;...bfd0033f 9a</span><br><span class="line">11  0x03688115: mov    0x160(%edi),%edi   ;...8bbf6001 0000</span><br><span class="line">12  0x0368811b: mov    %ecx,%edi          ;...8bf9</span><br><span class="line">13  0x0368811d: add    $0x8,%edi          ;...83c708</span><br><span class="line">14* 0x03688120: cmpxchg %esi,(%edi)       ;...0fb137</span><br><span class="line">15  0x03688123: mov    $0x1,%eax          ;...b8010000 00</span><br><span class="line">16  0x03688128: je     0x03688133         ;...0f840500 0000</span><br><span class="line">17  0x0368812e: mov    $0x0,%eax          ;...b8000000 00</span><br><span class="line">18  0x03688133: cmp    $0x0,%eax          ;...83f800</span><br><span class="line">19  0x03688136: je     0x03688104         ;...74cc</span><br><span class="line">20  0x03688138: mov    %esi,%eax          ;...8bc6</span><br><span class="line">21  0x0368813a: mov    %ebp,%esp          ;...8be5</span><br><span class="line">22  0x0368813c: pop    %ebp               ;...5d</span><br></pre></td></tr></table></figure>

<p>注意第 14 行中的 <code>cmpxchg</code> 指令。前面我们看到编译器给这个指令添加了一个 <code>lock</code> 前缀。在没有 SMP（<code>symmetric multiprocessing</code>）的情况下，JVM 避免了这种开销，这是静态编译无法做到的。</p>
<br />



<h1 id="7-收尾"><a href="#7-收尾" class="headerlink" title="7 收尾"></a>7 收尾</h1><p>内存屏障是多线程编程的必要条件。它可以分为不同类型，有显式、隐式之分，也有单向、双向之分。JVM 利用内存屏障实现跨平台的 Java 内存模型。我希望本文能够帮助有经验的 JVM 开发人员更深入地了解他们的代码的工作原理。</p>
<br />



<h1 id="8-参考"><a href="#8-参考" class="headerlink" title="8 参考"></a>8 参考</h1><ul>
<li><a href="http://www.intel.com/products/processor/manuals/">Intel 64 and IA-32 Architectures Software Developer’s Manuals</a></li>
<li><a href="http://www.csee.umbc.edu/help/architecture/aig.pdf">IA-64 Application Instruction Set Architecture Guide</a></li>
<li><a href="http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601">Java Concurrency in Practice</a> by <a href="http://www.briangoetz.com/">Brian Goetz</a></li>
<li><a href="http://g.oswego.edu/dl/jmm/cookbook.html">JSR-133 Cookbook</a> by Doug Lea</li>
<li>Mutual exclusion with <a href="http://en.wikipedia.org/wiki/Dekker's_algorithm">Dekker’s Algorithm</a></li>
<li>Examining generated code with <a href="http://wikis.sun.com/display/HotSpotInternals/PrintAssembly">PrintAssembly</a></li>
<li><a href="http://kenai.com/projects/base-hsdis/downloads">The Kenai Project</a> - a disassembler plugin</li>
<li><a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/">hsdis</a> - a disassembler plugin</li>
</ul>
<br />

<p><strong>以上！</strong></p>
<br />]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrency</tag>
        <tag>memory barrier</tag>
        <tag>visibility</tag>
      </tags>
  </entry>
</search>
