{"pages":[{"title":"About Alex","text":"A python coder who is lazy to try. Email: alexinst00@gmail.com","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"BaiduPCS-Go：仿Linux命令行的百度网盘客户端","text":"简述： BaiduPCS-Go是一个模仿Linux命令的百度网盘的第三方不限速客户端。使用这个客户端，很酷炫，但也不一定很方便。 特色 这是一个仿Linux命令行的百度网盘客户端。（是的，不限速） 注意文件名和目录名可用通配符*补全(使用*代替n个字符，n&gt;=0)。 123# 示例：d /a_directory/b_directory/c_file.txt =d /a*/b*/c* 特点 跨平台（Windows，macOS，Android等） 支持多账户。 网盘内列出文件和目录, 支持通配符匹配路径; 下载网盘内文件, 支持网盘内目录 (文件夹) 下载, 支持多个文件或目录下载, 支持断点续传和高并发高速下载。 离线下载，支持http/https/ftp/电驴/磁力链协议。 好玩，不过没有一点Linux基础，就不怎么好玩了。 # 程序下载 项目地址: [iikira/BaiduPCS-Go][1] 下载地址: [iikira/BaiduPCS-Go releases][2] ## Windows 下载地址: - 64位系统：[BaiduPCS-Go-v3.3.3-windows-x64.zip][3] - 32位系统：[BaiduPCS-Go-v3.3.3-windows-x86.zip][4] Android/macOS Android：需要用到 Termux 或 NeoTerm 类软件。这里只提一下。 macOS：没有macOS的设备，这里属于凑字数。。 # 程序运行 下载后解压缩，双击 BaiduPCS-Go.exe。界面如下： 123456----BaiduPCS-Go - 百度网盘客户端 for windows/amd64 ....... ....... .......BaiduPCS-Go &gt; 登录/退出/切换123login # 登录logout # 退出当前账户su/chuser # 切换账户 在命令行窗口中输入 login ，再根据提示输入账号和密码，即可登录百度账号。 还有其他登录方式，如 login -bduss=&lt;BDUSS&gt;。(获取bduss) logout 和 su / chuser 的用法也比较简单。 查看当前账户及已登录账户1loglist 切换目录1234cd -l /Path/To/File# cd = change directory = 切换目录。# /Path/To/File = 文件路径，绝对路径或相对路径。# -l: 显示目标目录下的子文件及子目录。 例：cd /a/b/c/d 下载12d /Path/To/File# d = download = 下载 例：d /a/b/c/d/e.txt。文件路径也可以是相对路径的。 web功能1web #启用web功能 输入上述命令后，在浏览器栏输入localhost:8080，就可以在本地查看你的网盘目录。 很不错的功能。 # 帮助菜单 1h 输入 h ，可以看到帮助菜单。这里做成表格，以便观看 用法 [global options] command [command options] [arguments…] COMMANDS 含义 tool 工具箱 help / h Shows a list of commands or help for one command 其他： run 执行系统命令 sumfile / sf 获取文件的秒传信息 web 启用 web 客户端 (测试中) 百度账号： login 登录百度账号 loglist 获取当前帐号, 和所有已登录的百度帐号 logout 退出当前登录的百度帐号 su / chuser 切换已登录的百度帐号 百度网盘： cd 切换工作目录 cp 拷贝(复制) 文件/目录 download / d 下载文件或目录 ls / l / ll 列出当前工作目录内的文件和目录 或 指定目录内的文件和目录 meta 获取单个文件/目录的元信息 (详细信息) mkdir 创建目录 mv 移动/重命名 文件/目录 offlinedl/clouddl / od 离线下载 pwd 输出当前所在目录 (工作目录) quota 获取配额, 即获取网盘的总储存空间, 和已使用的储存空间 rapidupload / ru 手动秒传文件 rm 删除 单个/多个 文件/目录 upload / u 上传文件或目录 配置: config 显示和修改程序配置项 GLOBAL OPTIONS: 全局选项 –verbose 启用调试 –help / -h 查看帮助 –version / -v 查看版本号","link":"/Manual/BaiduPCS-Go/"},{"title":"「Network」127.0.0.1 与 0.0.0.0","text":"简述：我对 127.0.0.1 和 0.0.0.0 这两个地址的概念一直都，好像了解，但却说不清楚。最近写博客的冲动比较强烈，遂查阅诸多资料，作解惑与收录。 127.0.0.1127.0.0.1 是 IPv4 的 loopback 地址。localhost 这个主机名称一般会解析为 127.0.0.1 。 所谓 loopback（环回，无助于理解的翻译） 机制，就是不借由本机网络接口（network interface）和本机接入的网络，实现（仅限）在本机中的网络服务。 loopback 地址是一个接口（interface），基于软件实现，与硬件没有关联，也并没有实际接入外部网络。使用 loopback 网络接口会忽略本地的网络接口硬件。 127.0.0.1 指向本机，通过在浏览器地址栏输入 127.0.0.1 及某一端口号， 可与 监听这一地址和该端口的本机程序进行连接。 If you enter an IP address (or corresponding domain name) in your browser, the router will forward your request to the internet and to the correct server. This means that if you enter 172.217.0.0, you will reach the Google homepage. However, the situation is different with 127.0.0.1 because requests to this address will not be forwarded to the internet. TCP/IP recognizes from the first block (127) that you don’t want to access the internet, you are calling yourself instead. This then triggers the loopback. 实际上，IPv4 loopback 地址是 127.0.0.0/8，也就是形式为 127.xxx.xxx.xxx 的所有地址（除了 127.255.255.255），总数超过1600万。这意味着，在浏览器地址栏输入这1600多万 IPv4 地址的任一个以及相应端口，都能连接到监听程序。 如图所示，输入 127.0.0.1:4000、127.1.1.1:4000、127.255.255.1:4000三个不同的地址，均能跳转至 Hexo 首页。 0.0.0.0在 IPv4 中，0.0.0.0 是一个不可路由（non-routable）的地址，用于指向一个无效、不适用或者未知的目标。在不同情况中，这一地址具有不同的含义。 提到主机地址 在配置服务器时， 可以泛指所有 IPv4 地址，比如绑定监听 socket。 当某主机未被分配一个 IPv4 地址时，该主机可以将 0.0.0.0 声明为它的地址。比如在通过 DHCP 获取地址时，主机向所在子网发送一个 DHCP discover 的链路层帧（Frame），帧中的 IPv4 数据报的源 IPv4 地址就是 0.0.0.0，因为该主机还未分配地址。 提到路由表（routing table） 0.0.0.0/0 作为 默认路由（default route）的 目的地址（Destination ）字段。（这里需要对 CIDR 有基本的了解）因为 CIDR 的最长前缀匹配（longest prefix match）规则，而0.0.0.0/0 的子网掩码长度为0，所以0.0.0.0/0 将是路由表中的最后匹配，即默认路由。 0.0.0.0作为路由表中规则的网关（Gateway）字段。没有指定去往目的子网的相应网关，也就是说目的地址在同一网段，通信时不需要经过网关。 参考 Localhost (127.0.0.1) - IONOS 0.0.0.0 - wikipedia What’s the difference between 127.0.0.1 and 0.0.0.0? - Superuser Default Gateway &amp; Default Routes - Cisco CCNA Linux 路由表详解及 route 命令详解 - CSDN Loopback - Wikipedia 以上！","link":"/Network/127-0-0-1-and-0-0-0-0/"},{"title":"「Android」Context，Application 和 Activity","text":"简述：Context 在 Android 开发中无处不在，可以说是最重要的概念。对 Context 的错误使用，很容易造成 Android App 的内存泄漏。 前言 Application 和 Activity 都间接继承自 Context 。 所谓 Application Context ，就是指 Application。同样的，Activity Context 也就是指 Activity。 本文把等同的事物（比如 Activity Context 和 Activity）当作不同来讲，逻辑上似乎有些奇怪，但这主要是为了强调它（Activity Context）一方面提供了应用级和系统级的接口，另一方面（Activity）也是显示的主体。 Context12java.lang.object ↳ android.content.Context 是什么 Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc. Context 是访问应用程序全局信息的接口，是一个由Android 系统提供实现（类 ContextImpl）的抽象类。它允许访问应用程序特有的资源（resource）和类（class），以及向上调用（up-call）应用级操作，如启动 Activity、Broadcast 和接收 Intent 等。 能做什么 创建 View（比如 TextView 、Button、ImageView 等） 启动 Activity、Service 发送和接收广播（Broadcast） 。。。。。。 实现 Context 只是一个抽象类，其实现是继承Context 的 类 ContextImpl。 Activity 和 Application123456java.lang.object ↳ android.content.Context ↳ android.context.ContextWrapper ↳ android.view.ContextThemeWrapper *↳ android.app.Activity *↳ android.app.Application 可以看出，Activity 和 Application 间接继承了 Context，那这两者是什么，之间又有什么区别呢？ 是什么 Activity 是与用户交互的入口点。它表示拥有界面的单个屏幕。例如，电子邮件应用可能有一个显示新电子邮件列表的 Activity、一个用于撰写电子邮件的 Activity 以及一个用于阅读电子邮件的 Activity。尽管这些 Activity 通过协作在电子邮件应用中形成一种紧密结合的用户体验，但每个 Activity 都独立于其他 Activity 而存在。因此，其他应用可以启动其中任何一个 Activity（如果电子邮件应用允许）。例如，相机应用可以启动电子邮件应用内用于撰写新电子邮件的 Activity，以便用户共享图片。Activity 有助于完成系统和应用程序之间的以下重要交互： 追踪用户当前关心的内容（屏幕上显示的内容），以确保系统继续运行托管 Activity 的进程。 了解先前使用的进程包含用户可能返回的内容（已停止的 Activity），从而更优先保留这些进程。 帮助应用处理终止其进程的情况，以便用户可以返回已恢复其先前状态的 Activity。 提供一种途径，让应用实现彼此之间的用户流，并让系统协调这些用户流。（此处最经典的示例是共享。） Application 或其子类是保存应用全局信息的类。当应用程序的进程启动时，第一个实例化的类就是 Application。Application 是一个单例（singleton）的类，即一个运行的应用只有 Application 或其子类的一个实例。不能在 Application 中保存可变的共享数据，因为你不知道它会被谁改变。更好的选择是保存在 文件、SharedPreferences 或 SQLite 中。 区别 有不同的生命周期。Application Context 存在于应用程序的运行期间，而 Activity Context 则与 Activity 的实例”同生共死“。 有不完全相同的应用场景。 Application Activity 启动 Activity / Start an activity ✘ ✔ 显示对话框 / Show a dialog ✘ ✔ 生成布局 / Layout inflation ✘ ✔ 加载资源 / Load resource values ✔ ✔ 启动 Service / Start a service ✔ ✔ 与 Service 绑定 / Bild to a service ✔ ✔ 发送 Broadcast / Send a broadcast ✔ ✔ 注册 Broadcast 接收器 / Register a broadcast receiver ✔ ✔ 显然，Activity Context 能做到的比 Application Context 更多。 获取 Context方法 Context.getApplicationContext()：返回当前进程的唯一、全局的 Application Context，它的生命周期与当前 Context 并不相干。 Activity.getApplication(): 返回该 Activity 的 Application ，和 getApplicationContext() 返回的是同一个对象。 View.getContext()：返回一个 Context 引用，指向 View 运行依靠的 Context，通常就是当前正在显示的 Activity 实例。 Activity.this：适用于在 Activity 内的匿名内部类 访问 其外部的 Activity。 ContextWrapper.getBaseContext()：返回 base Context。 选用 避免使用 getBaseContext()。因为你并不知道返回的是哪个Context。 与 UI 相关的场景，使用 Activity Context；除此之外，可以使用 Application Context。 将一个 Context 传到 Activity 的范围之外，选择 Application Context 能够很简单地避免内存泄漏，减少很多考虑。 最重要的一点，确保不要将短暂存在的 Context 传递给长时间存在的对象，比如将 Activity Context 传给一个长时间在后台运行的 Service。 参考 Context - Android Application - Android Activity - Android View - Android 应用基础知识 - Android Understanding the Android Application Class - CodePath Android 中用 getApplicationContext() 会不会避免某些内存泄漏问题 - ZhiHu 如何理解Context? - ZhiHu Which Context should I use in Android? - Medium Understanding Context In Android Application - Mindorks Mastering Android context - FreeCodeCamp Using Context - CodePath Using Application context everywhere? - StackOverFlow Android: why must use getBaseContext() instead of this 以上！","link":"/Android/Context-Application-and-Activity/"},{"title":"Hexo部署到Github出错","text":"简述: 将本地Hexo博客部署到Github Pages时，Git Bash出现报错：无法读取Github用户。在repo的url链接中加入用户名和密码，即可解决问题。 问题 搭建Hexo博客，按照网上教程，在hexo d这一步出现如下错误： 1234567891011121314151617fatal: HttpRequestException encountered. ��������ʱ�����bash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for 'https://github.com': No errorFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: fatal: HttpRequestException encountered. ��������ʱ������bash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for 'https://github.com': No error at ChildProcess.&lt;anonymous&gt; at emitTwo (events.js:106:13) at ChildProcess.emit (events.js:191:7) at ChildProcess.cp.emit at maybeClose at Process.ChildProcess._handle.onexit (internal/child_process.js:226:5) 解决办法 编辑博客文件下的_config.yml。 找到#Deployment，修改如下： 12345deploy: type: git repo: https://&lt;用户名&gt;:&lt;密码&gt;@github.com/ares-x/ares-x.github.io.git branch: master","link":"/Hexo/Hexo-delopy-to-github/"},{"title":"「Debian」Debian 使用 apt 安装软件时提示插入光盘","text":"简述：apt 是 Debian 的安装包管理工具。 问题在VMware中成功安装Debian 9.2，进入终端运行： 1$ sudo apt-get update 结果出现如下错误： 123Media change: please insert the disc labeled 'Debian GNU/Linux......'in the drive '/media/cdrom/' and press enter 解决办法打开并修改文件 sources.list： 1$ sudo vim /etc/apt/sources.list 找到： 1deb cdrom:[Debian GNU/Linux ......] ....... 将其注释： 12# deb cdrom:[Debian GNU/Linux ......] ....... 最后： 1$ sudo apt-get update 以上","link":"/Linux/apt-get-install-error-media-change/"},{"title":"「Linux」增删用户以及赋予 sudo 权限","text":"简述 ：Linux日常使用不建议用root登录，因为root具有全部权限。为此，需要添加一个普通用户，而为了正常使用，还需要赋予其sudo权限。 1. 添加普通用户并赋予 sudo 权限1.1 创建普通用户帐号1$ sudo adduser USERNAME 全文USERNAME 指代用户名，例如 Alex、Sam 等等。 为运行创建新用户的命令，当前 user 必须是root或者具有sudo权限的普通 user。 创建过程中，需要输入用户密码，其他信息的输入可选择跳过。 1.2 将用户添加至 sudo group1$ sudo usermod -aG sudo USERNAME usermod 手册：Here 2 测试用户权限切换至新用户： 1$ su - USERNAME 测试权限： 1$ sudo whoami 输出应为： 1root 3 修改密码3.1 修改自己的密码1$ passwd 3.2 修改他人的密码1$ sudo passwd USERNAME 修改其他用户的密码，你必须是root用户或者具有sudo权限 。 4 移除用户的 sudo 权限1$ sudo deluser USERNAME sudo 验证用户是否已从sudo组删除： 1$ sudo -lU USERNAME deluser手册：Here；sudo手册：Here 5 删除用户（慎重）1$ sudo deluser --remove-home USERNAME --remove-home：删除用户时移除其home目录。不加此选项，home目录不会被删除。 6 查看所有用户和组6.1 查看所有用户1$ cat /etc/group 6.2 查看所有组1$ cat /etc/passwd 6.3 查看当前用户所在组1$ groups 7 参考深入理解 sudo 与 su 之间的区别 How To Create a Sudo User on Ubuntu 一起学习在 Ubuntu 上授予和移除 sudo 权限 以上！","link":"/Linux/add-check-and-delete-user-on-linux/"},{"title":"避免访问 Google 时出现的人机验证 reCaptcha","text":"简述：DigitalOcean也许资格太老，福利太好，被人滥用，导致现在开出VPS的IP可能存在问题。具体表现为，每次清空cookie，再次使用Google或Youtube就会出现人机验证reCaptcha。 问题 我也用过好几家云服务商的VPS，诸如DigitalOcean、VirMach、Free-www、CenterHop等。 对于我，至今出现Google的人机验证reCaptcha这问题，都是在使用DO家VPS搭建的扶墙服务的情况下。很显然，DO家的IP因为VPS被滥用，问题挺大的。 这个人机验证是真的烦。 解决办法 在通过如V2ray使用Google时，如果出现验证码，那么页面下方会告知此时访问Google的IP地址，你就能看到具体是IPv4被封还是IPv6被封啦。 禁用IPv6 如果是IPv6地址存在问题，那就禁用IPv6，只使用IPv4访问网络。 编辑/etc/sysctl.conf，在文件末尾加入： 1234# disable ipv6net.ipv6.conf.all.disable_ipv6=1net.ipv6.conf.default.disable_ipv6=1net.ipv6.conf.lo.disable_ipv6=1 强制IPv4 如果是IPv4地址存在问题，那就只使用IPv6访问网络。当然，鉴于国内目前除了教育网，IPv6协议尚未普及，所以这种情况可能就比较尴尬了。 方法是，在VPS的hosts文件中，指定Google等的IPv6地址。编辑/etc/hosts，加入： 1234562607:f8b0:4005:801::200e google.com2607:f8b0:4005:801::200e www.google.com2607:f8b0:4007:805::100f scholar.google.cn2607:f8b0:4007:805::100f scholar.google.com2607:f8b0:4007:805::100f scholar.google.com.hk2607:f8b0:4007:805::100f scholar.l.google.com 如上IPv6地址可能已失效，请参考lennylxx/ipv6-hosts中提供的最新IPv6地址。 鸣谢本文参考自博主Penguin的博文，这是地址。 **以上！**","link":"/Experience/avoid-recaptcha-of-google/"},{"title":"「SQL」2. SQL格式规范、基本命令与范例","text":"简述：这里只记录SQL的部分基本指令，包括SELECT FROM，WHERE，GROUP BY，ORDER BY。 SQL要点注释SQL语句中的单行注释使用--，多行注释采用 /*…*/ 代码规范 SQL编程格式的优化建议 SQL Style Guide 执行顺序SQL 语句有一个让大部分人都感到困惑的特性，就是：SQL 语句的执行顺序跟其语句的语法顺序并不一致。SQL 语句的语法顺序是： SELECT[DISTINCT] FROM WHERE GROUP BY HAVING UNION ORDER BY 为了方便理解，上面并没有把所有的 SQL 语法结构都列出来，但是已经足以说明 SQL 语句的语法顺序和其执行顺序完全不一样，就以上述语句为例，其执行顺序为： FROM WHERE GROUP BY HAVING SELECT DISTINCT UNION ORDER BY ​ 摘自：十步完全理解 SQL 查询语句 SELECT FROM语句解释从表中选择数据 1234SELECT attribute_name, ...FROM table_name 查重语句12345678SELECT attribute_nameFROM table_nameGROUP BY attribute_nameHAVING COUNT(attribute_name) &gt; 1; 前N个语句12345678910SELECT *FROM table_nameORDER BY attribute_name DESCLIMIT n OFFSET n CASE…END 判断语句1234567CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 WHEN 条件3 THEN 结果3 ......... WHEN 条件N THEN 结果NEND 筛选语句 WHERE语法123456SELECT attribute_nameFROM table_nameWHERE attribute_name operator value 属性名不要求相同。 运算符/通配符/操作符 operator 描述 = 等于 &lt;&gt; 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 分组语句 GROUP BY语句解释GROUP BY语句根据一个或多个列对结果集进行分组。 12345678SELECT attribute_nameFROM table_nameWHERE attribute_name operator valueGROUP BY attribute_name 属性名不要求相同。 HAVING子句在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。示例： 12345678910SELECT attribute_name, aggregate_function(attribute_name)FROM table_nameWHERE attribute_name operator valueGROUP BY attribute_nameHAVING aggregate_function(attribute_name) operator value 排序语句 ORDER BYORDER BY语句用于根据指定的列对结果集进行排序。默认按照升序，添加DESC关键字可改成降序。 正序、逆序SQL默认按照升序（ASC），添加DESC关键字可改成降序。 简单实操查找重复的电子邮箱（难度：简单） 创建表，表名 accounts，再添加 records。 12345678 CREATE TABLE email (ID INT NOT NULL PRIMARY KEY,Email VARCHAR(255));INSERT INTO email VALUES('1','a@b.com');INSERT INTO email VALUES('2','c@d.com');INSERT INTO email VALUES('3','a@b.com'); Yeah，这就成了。 查重 12345678SELECT Email FROM accountsGROUP BY EmailHAVING COUNT(Email)&gt;1; 查找结果： 查找大国 建表，表名 world，再添加 records 。 123456789101112131415161718CREATE TABLE World (name VARCHAR(50) NOT NULL,continent VARCHAR(50) NOT NULL,area INT NOT NULL,population INT NOT NULL,gdp INT NOT NULL);INSERT INTO World VALUES('Afghanistan','Asia',652230,25500100,20343000);INSERT INTO World VALUES('Albania','Europe',28748,2831741,12960000);INSERT INTO World VALUES('Algeria','Africa',2381741,37100000,188681000);INSERT INTO World VALUES('Andorra','Europe',468,78115,3712000);INSERT INTO World VALUES('Angola','Africa',1246700,20609294,100990000); 查找大国（条件：国家的面积超过300万平方公里，或者(人口超过2500万并且 gdp 超过2000万)） 123456SELECT name, population, areaFROM worldWHERE area &gt; 3000000 OR (population &gt; 25000000 and GDP &gt; 20000000); Here we go! 系列 「SQL」1. 安装 MySQL 「SQL」2. SQL格式规范、基本命令与范例 「SQL」3. MySQL 的数据类型 以上！","link":"/SQL/basic-instructions-of-sql/"},{"title":"「TensorFlow」2. 编译 TensorFlow C++","text":"简述：编译 TensorFlow C++ 很费劲，需要一颗向死之心。虽然成功编译已经是半个月前的事，但我拖到现在才整理成稿。因此会存在一些纰漏，你可以多多咕果或者留言咨询我。 系统环境： OS：Ubuntu 14.04.6 LTS x64 (trusty) RAM：64 GB GPU：NVIDIA GTX TITAN x 4 CUDA Toolkit：10.0 cuDNN：7.4.2 安装版本： bazel：0.21.0 TensorFlow：1.13.1 安装 bazel幸好 bazel 0.21.0 支持 Ubuntu 14.04 ，不然就只能砸电脑了，虽然没钱赔！ 官方步骤： 安装依赖： pkg-config, zip, g++, zlib1g-dev, unzip, 和 python。 1$ sudo apt-get install pkg-config zip g++ zlib1g-dev unzip python 下载安装脚本，这是bazel 发布页面。 12$ cd /tmp$ wget https://github.com/bazelbuild/bazel/releases/download/0.21.0/bazel-0.21.0-installer-linux-x86_64.sh 运行脚本： 12$ chmod +x bazel-0.21.0-installer-linux-x86_64.sh$ ./bazel-0.21.0-installer-linux-x86_64.sh --user 使用 --user 会将 bazel 安装在 $HOME/bin 路径下，并将配置文件 .bazelrc 设置在 $HOME 路径下。 配置环境变量 如果你有使用 --user，则： 123$ echo &quot;# bazel pathexport PATH=&quot;$PATH:$HOME/bin&quot;&quot; &gt;&gt; ~/.bashrc$ source ~/.bashrc 官方教程只设置了临时环境变量，但我习惯一步到位。 验证 12345$ bazel versionWARNING: --batch mode is deprecated. Please instead explicitly shut down your Bazel server using the command &quot;bazel shutdown&quot;.INFO: Invocation ID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxBuild label: 0.21.0.................................................. 环境初始化 拉取 TensorFlow 123$ mkdir ~/Programs$ cd Programs/$ git clone -b r1.13 https://github.com/tensorflow/tensorflow.git TensorFlow/ 运行环境初始化脚本 123$ cd TensorFlow/tensorflow/contrib/makefile$ chmod +x build_all_linux.sh$ ./build_all_linux.sh 编译 TensorFlow 配置编译要求 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677$ cd ~/Programs/TensorFlow$ ./configureWARNING: Duplicate rc file: /home/ttt/Programs/tensorflow-r1.13-4/.tf_configure.bazelrc is read multiple times, most recently imported from /home/ttt/.bazelrcWARNING: --batch mode is deprecated. Please instead explicitly shut down your Bazel server using the command &quot;bazel shutdown&quot;.INFO: Invocation ID: a16de493-8f9e-46f8-96bc-0903f0e36c3bYou have bazel 0.21.0 installed.Please specify the location of python. [Default is /usr/bin/python]: /home/ttt/miniconda3/bin/pythonFound possible Python library paths: /home/ttt/miniconda3/lib/python3.6/site-packagesPlease input the desired Python library path to use. Default is [/home/ttt/miniconda3/lib/python3.6/site-packages]Do you wish to build TensorFlow with XLA JIT support? [Y/n]: yXLA JIT support will be enabled for TensorFlow.Do you wish to build TensorFlow with OpenCL SYCL support? [y/N]: nNo OpenCL SYCL support will be enabled for TensorFlow.Do you wish to build TensorFlow with ROCm support? [y/N]: nNo ROCm support will be enabled for TensorFlow.Do you wish to build TensorFlow with CUDA support? [y/N]: yCUDA support will be enabled for TensorFlow.Please specify the CUDA SDK version you want to use. [Leave empty to default to CUDA 10.0]: Please specify the location where CUDA 10.0 toolkit is installed. Refer to README.md for more details. [Default is /usr/local/cuda]: Please specify the cuDNN version you want to use. [Leave empty to default to cuDNN 7]: Please specify the location where cuDNN 7 library is installed. Refer to README.md for more details. [Default is /usr/local/cuda]: Do you wish to build TensorFlow with TensorRT support? [y/N]: nNo TensorRT support will be enabled for TensorFlow.Please specify the locally installed NCCL version you want to use. [Default is to use https://github.com/nvidia/nccl]: Please specify a list of comma-separated Cuda compute capabilities you want to build with.You can find the compute capability of your device at: https://developer.nvidia.com/cuda-gpus.Please note that each additional compute capability significantly increases your build time and binary size. [Default is: 6.1,6.1,6.1,6.1]: Do you want to use clang as CUDA compiler? [y/N]: nnvcc will be used as CUDA compiler.Please specify which gcc should be used by nvcc as the host compiler. [Default is /usr/bin/gcc]: Do you wish to build TensorFlow with MPI support? [y/N]: nNo MPI support will be enabled for TensorFlow.Please specify optimization flags to use during compilation when bazel option &quot;--config=opt&quot; is specified [Default is -march=native -Wno-sign-compare]: Would you like to interactively configure ./WORKSPACE for Android builds? [y/N]: nNot configuring the WORKSPACE for Android builds.Preconfigured Bazel build configs. You can use any of the below by adding &quot;--config=&lt;&gt;&quot; to your build command. See .bazelrc for more details. --config=mkl # Build with MKL support. --config=monolithic # Config for mostly static monolithic build. --config=gdr # Build with GDR support. --config=verbs # Build with libverbs support. --config=ngraph # Build with Intel nGraph support. --config=dynamic_kernels # (Experimental) Build kernels into separate shared objects.Preconfigured Bazel build configs to DISABLE default on features: --config=noaws # Disable AWS S3 filesystem support. --config=nogcp # Disable GCP support. --config=nohdfs # Disable HDFS support. --config=noignite # Disable Apacha Ignite support. --config=nokafka # Disable Apache Kafka support. --config=nonccl # Disable NVIDIA NCCL support.Configuration finished 编译 TensorFlow C++ 库 CPU 版本 1$ bazel build --config=opt //tensorflow:libtensorflow_cc.so GPU 版本 1$ bazel build --config=opt --config=cuda //tensorflow:libtensorflow_cc.so 测试环境 新建目录及文件 1234$ mkdir -p ~/Projects/demo$ cd ~/Projects/demo$ mkdir build src$ touch CMakeLists.txt src/main.cpp 编写测试代码 main.cpp 1234567891011121314151617#include &lt;tensorflow/core/platform/env.h&gt;#include &lt;tensorflow/core/public/session.h&gt;#include &lt;iostream&gt;using namespace std;using namespace tensorflow;int main(){ Session* session; Status status = NewSession(SessionOptions(), &amp;session); if (!status.ok()) { cout &lt;&lt; status.ToString() &lt;&lt; &quot;\\n&quot;; return 1; } cout &lt;&lt; &quot;Session successfully created.\\n&quot;;} 编写 CMakeLists.txt 12345678910111213141516cmake_minimum_required(VERSION 3.15)project(demo)set(CMAKE_CXX_STANDARD 11)set(PROGRAMS_DIR /home/ttt/Programs)set(TENSORFLOW_DIR ${PROGRAMS_DIR}/TensorFlow)include_directories(${TENSORFLOW_DIR})include_directories(${TENSORFLOW_DIR}/bazel-genfiles)include_directories(${TENSORFLOW_DIR}/tensorflow/contrib/makefile/downloads/absl)include_directories(${TENSORFLOW_DIR}/tensorflow/contrib/makefile/downloads/eigen)link_directories(${TENSORFLOW_DIR}/bazel-bin/tensorflow)add_executable(demo main.cpp)target_link_libraries(LaneNet tensorflow_cc tensorflow_framework) 目录结构 123456├── build| ├── CMakeLists.txt|├── src| └── main.cpp 编译并运行测试程序 1234$ cd ~/Programs/demo/build$ cmake ..$ make$ ./demo 输出： 12..................................................Session successfully created. 疑难杂症 bazel 版本问题 1ERROR:/home/ttt/.cache/bazel/_bazel_ttt/12fb0bc5892f7f0d9058b186b377c0bf/external/local_config_cc/BUILD:57:1: in cc_toolchain rule @local_config_cc//:cc-compiler-k8: Error while selecting cc_toolchain: Toolchain identifier 'local' was not found, valid identifiers are [local_linux, local_darwin, local_windows] 解决办法：bazel 0.19.1 -&gt; 0.21.0 eigen 版本问题 123/usr/local/tensorflow/include/third_party/eigen3/unsupported/Eigen/CXX11/Tensor:1:42: fatal error: unsupported/Eigen/CXX11/Tensor: 没有那个文件或目录 #include &quot;unsupported/Eigen/CXX11/Tensor&quot; 解决办法：更新 eigen 至 3.3，且添加到 CMakeLists.txt 的搜索目录 找不到 abseil-cpp 12/usr/local/tensorflow/include/tensorflow/core/lib/core/stringpiece.h:29:38: fatal error: absl/strings/string_view.h: 没有那个文件或目录 #include &quot;absl/strings/string_view.h&quot; 解决办法（来源）：下载 abseil-cpp 并添加到 CMakeLists.txt 的搜索目录 CMakeLists.txt 12/home/ttt/Programs/tensorflow-r1.13-3/tensorflow/core/framework/tensor_shape.h:22:48: fatal error: tensorflow/core/framework/types.pb.h: 没有那个文件或目录 #include &quot;tensorflow/core/framework/types.pb.h&quot; 解决办法：include_directories(${TENSORFLOW_DIR}/bazel-genfiles) 参考 Installing Bazel on Ubuntu - bazel Ubuntu安装TensorFlow C++ - GitHub 将Tensorflow源码编译成C++库文件 - hemajun815 Tensorflow C++ 从训练到部署(1)：环境搭建 Standalone C++ Build — TF + OpenCV - Medium Use TensorFlow C++ API with OpenCV3 - Medium Tensorflow c++ 实践及各种坑 系列 「TensorFlow」1. 安装 CUDA 和 cuDNN 「TensorFlow」2. 编译 TensorFlow C++ 以上！","link":"/TensorFlow/build-tensorflow-cpp/"},{"title":"「PyQt5」1. QtWidgets 模块中 Class 的通用函数&#x2F;方法","text":"简述：PyQt5是Python和Qt库的成功融合，用来开发GUI应用程序。它有超过300类，将近6000个函数和方法，非常复杂。PyQt分为4和5两个大版本，又可以应用于C++和Python两种语言，所以文档资料很不好找。 本文记录了一些PyQt5.QtWidgets中多数Class的少数较难通用函数/方法，仅为笔记。 学习文档 PyQt5中文教程：这是PyQt5 Tutorials的翻译，可用于入门。但只是初级的教程，而且使用的图床大概是QQ相册，许多图片无法显示。 Qt for Python: 顾名思义，这是Python的PyQt5官方文档，但对于类的函数或方法的解释太简单，有些鸡肋。 Qt Documentation for C++：这是用于C++的PyQt5.11文档，文字解释很具体，但并不能直接应用于Python。 QtWidgets QtWidgets模块提供了一套创造经典桌面风格的用户界面的UI Class，包含有： QWidget： QPushButton：按键 QComboBox：多选框 QLabel：标签 QLineEdit、QTextEdit：单行文本框和多行文本框 …… 控件Text12&lt;CONTORL_NAME&gt;.setText('...') # 设置控件Texttext = &lt;CONTORL_NAME&gt;.Text() # 提取控件Text &lt;CONTROL_NAME&gt;指的是控件Class的Instance名。 控件可用性12&lt;CONTROL_NAME&gt;.setEnabled(True)&lt;CONTROL_NAME&gt;.setEnabled(False) Text在控件中的位置12345678910111213from PyQt5.QtCore import Qt...class window(QWidget): def __init__(self): ... def initUI(self): self.lbl = QLabel() set.lbl.setAlignment(Qt.AlignCenter) # or set.lbl.setStyleSheet(&quot;qproperty-alignment: 'AlignCenter';&quot;)... 以QLabel为例，方法setAlignment的参数可以有： Qt.AlignLeft Qt.AlignCenter Qt.AlignRight Qt.AlignTop：顶部 Qt.AlignBottom：底部 …… **以上！**","link":"/Python/PyQt5/common-methods-of-pyqt/"},{"title":"「Hexo」Hexo 开启阅读计数功能","text":"简述：本文简练描述 Hexo 博客如何开启自带的阅读计数功能。 leancloud配置第一步先注册。 第二步创建应用，名字随意，计价方案为开发版。 第三步创建Class，名字必须为Counter，默认ACL权限设置为无限制。 第四步在设置中获取appid和appkey，之后跳到**NexT配置**。 NexT配置打开NexT主题目录下的_config.yml，找到leancloud_visitors位置，并如下修改之。 1234567891011# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx #&lt;app_id&gt; app_key: xxxxxxxxxxxxxxxxxxxxxxxxxxxx #&lt;app_key&gt; # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don't care about security in lc counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set the `security` to `false`. security: false # 如果设置了web安全域名，此处须改为 true。 betterPerformance: true 设置web安全域名（非必须）在设置-&gt;安全中心中，web安全域名处填写博客域名。 如果打开浏览器调试模式（F12），出现403错误，则意味着域名填写出错。 那就只有两个办法： 死磕 放弃设置web安全域名 我选择第二个办法，毕竟第一个办法失败了，毕竟只是个小破站。所以，在NexT主题的_config.yml中将leancloud_visitors的security设置为false。 以上！","link":"/Manual/counting-function-of-hexo/"},{"title":"「C++」数据类型 char 转化为 string","text":"简述：C++中数据类型char和string都可以存放字符，所以存在将char类型转化为类型string的需求。 具体方法 话不多说，先上代码。 123456789101112131415#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt; //stringstream出处int main(){ char c = 'a'; std::string str; std::stringstream ss; ss &lt;&lt; c; str = ss.str(); std::cout &lt;&lt; str &lt;&lt; std::endl; return 0;} 这里借助stringstream，存储变量c中的值，再赋给变量str，完成转化。 以上！","link":"/C/convert-from-char-to-string/"},{"title":"「SQL」3. MySQL 的数据类型","text":"简述：MySQL的数据类型可以分为三类：文本、数字和日期/时间类型。 数据类型在 MySQL 中，有三种主要的类型：文本、数字和日期/时间类型。 Text 类型 数据类型 描述 CHAR(size) 固定长度（可包含字母、数字以及特殊字符），size指字符串的长度，最大为 255。 VARCHAR(size) 可变长度。size指字符串的长度，最大为 255。如果大于 255，则被转换为TEXT类型。 TINYTEXT 可变长度，最多 255 个字符。 TEXT 可变长度，最多 65,535 个字符。 MEDIUMTEXT 可变长度，最多 16,777,215 个字符。 LONGTEXT 可变长度，最多 4,294,967,295 个字符。 BLOB BLOBs(Binary Large Objects)，存放最多 65,535 bytes的数据。 MEDIUMBLOB 存放最多 16,777,215 bytes的数据。 LONGBLOB 存放最多 4,294,967,295 bytes的数据。 ENUM(x,y,z,etc.) 枚举列表，可在 ENUM 列表中列出最大 65535 个值（字符串）。如果列表中不存在插入的值，则插入空值。注释：这些值是按照输入的顺序存储的。格式：ENUM('X','Y','Z') An ENUM is a string object with a value chosen from a list of permitted values that are enumerated explicitly in the column specification at table creation time. 整型类型 数据类型 字节数 有符号 无符号 TINYINT 1 -128 ～127 0 ～ 255 SMALLINT 2 -32768 ～ 32767 0 ～ 65535 MEDIUMINT 3 -8388608 ～ 8388607 0 ～ 16777215 INT 4 -2147483648 ～ 2147483647 0 ～ 4294967295 BIGINT 8 -9223372036854775808 ～ 9223372036854775807 0 ～ 18446744073709551615 整数类型拥有额外的选项 UNSIGNED。 浮点数类型 数据类型 字节数 描述 FLOAT(M,D) 4 M 代表显示长度，D 代表小数位数，这两个参数都不是必需参数，默认为10, 2，小数精度可以达到24位 DOUBLE(M,D) 8 M和D默认为16, 4，小数精度可以达到53位。 DECIMAL(M,D) 作为字符串存储，是非压缩的无符号浮点数。 每一位十进制数都对应一个字节。 DECIMAL 和 FLOAT/DOUBLE的区别，主要有两点： FLOAT/DOUBLE在db中存储的是近似值，而DECIMAL 则是以字符串形式进行保存的； DECIMAL(M,D)的规则和FLOAT/DOUBLE相同，但FLOAT/DOUBLE在不指定M、D时默认按照实际精度来处理,而DECIMAL 在不指定M、D时默认为DECIMAL (10, 0)。 Date 类型 数据类型 字节数 格式 描述 DATE() 3 YYYY-MM-DD 支持的范围是 1000-01-01 ~ 9999-12-31 TIME() 3 HH:MM:SS 支持的范围是 -838:59:59 ~ 838:59:59 YEAR() 1 YY / YYYY 2 /4 位格式的年份。4 位：1901 ～ 2155；2 位：70 ～ 69（1970 ～2069）。 DATETIME() 8 YYYY-MM-DD HH:MM:SS 范围是 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 TIMESTAMP() 4 YYYY-MM-DD HH:MM:SS 时间戳。TIMESTAMP 值使用 Unix 纪元(1970-01-01 00:00:00 UTC) 至今的描述来存储。范围是 1970-01-01 00:00:01 UTC 到 2038-01-09 03:14:07 UTC DATETIME 和 TIMESTAMP两种类型的区别： DATETIME 与TIMESTAMP能存储的时间范围也不同，DATETIME 的存储范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59，TIMESTAMP存储的时间范围为19700101080001 ~ 20380119111407 DATETIME默认值为空；TIMESTAMP默认值不为空，当插入值为null时，MySQL会取当前时间 DATETIME 存储的时间与时区无关，TIMESTAMP存储的时间及显示的时间都依赖于当前时区 TIMESTAMP 也接受不同的格式，比如 YYYY-MM-DD HH:MM:SS YY-MM-DD HH:MM:SS YYYY-MM-DD YY-MM-DD 系列 「SQL」1. 安装 MySQL 「SQL」2. SQL格式规范、基本命令与范例 「SQL」3. MySQL 的数据类型 以上！","link":"/SQL/data-types-of-MySQL/"},{"title":"「OS」进程和线程的区别","text":"简述：进程和线程是一对朦朦胧胧的概念，每次面试提问二者区别，都感觉自己没全说对。 本质描述进程（Process）和线程（Thread）都是一个时间段的描述，是 CPU 工作时间段的描述。 进程是 程序执行时间总和 = CPU 加载执行环境 -&gt; CPU 执行程序 -&gt; CPU 保存执行环境。 线程是 程序模块执行时间总和 = CPU 加载执行环境（共享进程的）-&gt; CPU 执行程序模块-&gt; CPU 保存执行环境（共享进程的） 进程和线程都是描述 CPU 工作的时间段，线程是更细小的时间段。 具体区别 两者关系：一个进程可以包含多个线程，线程在进程下运行。 同侪关系： 进程间不会相互影响，一个线程崩溃将导致整个进程挂掉。 进程之间是一种树的层级关系，P0 分出 P1 等等。而线程是一种平级的关系。 数据共享： 进程有自己的内存，通过分页将虚拟地址空间映射到物理地址空间来存储数据。不同进程间数据共享很复杂，需要借助进程间通信机制（如管道，消息队列，Socket，共享内存和信号量等） 同一进程下，不同线程间数据共享地址空间（如段、数据段、用户 ID 和组 ID、文件描述符表、当前工作目录等）。 资源消耗：进程要比线程消耗更多的计算机资源。 上下文切换：对于操作系统内核而言，进程的上下文切换（context switch）时间消耗比线程的上下文切换更长（heavier）。 参考 线程和进程的区别是什么？ - ZhiHu What is the difference between a process and a thread? - Quora 以上！","link":"/OS/differences-of-process-and-thread/"},{"title":"「NodeJs」Win7 下安装 NodeJs","text":"简述：win7系统下安装NodeJs莫名失败（Node.js Setup Wizard ended prematurely），我经过搜索和尝试，最后终于安装成功。为此耗费了足足五个小时的时间。。。 报错信息 在快要安装成功时，出现回滚。我的天，真是夭寿！ 这番报错，毫无有价值的参考信息。 解决方法下载Windows Binary版本 下载地址：node-v8.12.0-win-x64 8.12.0 版本是LTS（Long-term Support）稳定版本。 设置环境变量 选择合适位置放置解压后的Nodejs文件夹 右击我的电脑， 选择属性。 点击位于左侧的高级系统设置。 在跳出的对话框中，点击右下角的环境变量。 设置两个环境变量。示例：D:\\nodejs， D:\\nodejs\\node_modules。 测试 按住win+R，在运行对话框中输入cmd，回车。 在命令行窗口中分次输入 123node -vnpm -v 响应分别为 1238.12.06.4.1 至此，若响应如上，则宣告安装成功。 若不是，那就。。。 以上","link":"/Manual/fix-nodejs-setup-error-on-win7/"},{"title":"「SQL」1. 安装 MySQL","text":"简述：四月份开始学习SQL，一个新坑的开始，填不完的坑。直到现在才整理了一篇博文，因为坑太多了。。。 OS：Windows 10 v1903 (18362) 软件安装及初始化安装下载地址：MySQL Community Server步骤： 对压缩包解压缩，并放到某个本地位置，如D:\\Program Files\\MySQL 进入 D:\\Program Files\\MySQL（这里修改为自己的安装目录），新建文件 my.ini。打开并输入再保存： 123456789101112131415161718[mysql]# 设置 mysql 客户端默认字符集default-character-set=utf8[mysqld]# 设置 3306 端口port=3306# 设置 mysql 的安装目录basedir=D:\\\\Program Files\\\\MySQL# 允许最大连接数max_connections=20# 服务端使用的字符集默认为 8 比特编码的 latin1 字符集character-set-server=utf8mb4# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 以管理员打开命令行窗口（CMD）。 切换路径至 D:\\Program Files\\MySQL\\bin 初始化数据库： 1mysqld --defaults-file=D:\\Program Files\\MySQL\\my.ini --initialize --console 执行完成后，会输出 root 用户的初始默认密码，如： 12018-04-20T02:35:05.464644Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: BAsCY5ws,hjt BAsCY5ws,hjt 就是初始密码，后续登录需要用到。 安装：mysqld install。 启动：net start mysql。 （不需要执行）停止：net stop mysql。 初始化命令行窗口目录： D:\\Program Files\\MySQL\\bin 登录： 1mysql -u root -p 输入之前记下的 temporary password，回车之后就登录了。 修改密码（超难）： 1mysql&gt; set password for root@localhost='xxxxxxx'; **不要忘记结尾的 ;**。 网上TMD教程没几个对的，比如 set password for 'root'@'localhost' = password('xxxxxxx')。 显示已有的数据库：mysql&gt; show databases;。 12345678910mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.08 sec) 新建数据库：mysql&gt; create database test;。 使用数据库：mysql&gt; use test;。 参考 MySQL 安装 - 菜鸟教程 数据库基础知识数据库定义数据库 ( Database ) 是按照数据结构来组织、存储和管理数据的仓库。每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。 关系型数据库所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。关系数据库管理系统 ( Relational Database Management System, RDMS ) 的特点： 数据以表格的形式出现 每行为各种记录名称 每列为记录名称所对应的数据域 许多的行和列组成一张表单 若干的表单组成 database 行 (row) 行：一行（=元组，或记录）是一组相关的数据，例如某个用户的年龄，出生日期，手机号码等数据。` 列 (column) 列: 一列(数据元素) 包含了相同的数据, 例如学号。` 主键 (primary key) 主键：主键唯一。一个数据表中只能包含一个主键。你可以使用主键来查询数据。 外键 (foreign key) 外键：用于关联两个表。 MySQL数据库管理系统数据库 数据库: 数据库是一些关联表的集合。 数据表 数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。 视图 虚拟的表。本身不存储数据，而是按指定的方式进行查询。 存储过程 为以后的使用而保存的一条或多条MySQL语句的集合。 系列 「SQL」1. 安装 MySQL 「SQL」2. SQL格式规范、基本命令与范例 「SQL」3. MySQL 的数据类型 以上！","link":"/SQL/installation-and-simple-instructions-of-sql/"},{"title":"「TensorFlow」1. 安装 CUDA 和 cuDNN","text":"简述：为了编译 TensorFlow C++，再次踏上 CUDA 之旅。这是一条不归路，但还是必须做个整理记录，因为这也许不是最后一次。 系统环境： OS：Ubuntu 14.04.6 LTS x64 (trusty) RAM：64 GB GPU：GTX TITAN x 4 安装版本： CUDA Toolkit：10.0 cuDNN：7.4.2 更新驱动 打开 ”附加驱动“ (Ubuntu 14.04 LTS) Ubuntu-desktop + Ubuntu 主题：按 Win 键，搜索”附加驱动“ Ubuntu-desktop + Gnome 主题 ：左上角”应用程序“ -&gt; 系统工具 -&gt; 首选项 -&gt; 附加驱动 选择驱动程序： 选择 ”使用 NVIDIA binary driver - version 410.56 来自 nvidia-410 (开源) ” 点击右下角“应用更改” 等待完成驱动更新 默认安装位置 Component 默认安装位置 CUDA Toolkit /usr/local/cuda-10.0 CUDA Samples $(HOME)/NVIDIA_CUDA-10.0_Samples cuDNN /usr/lib/x86_64-linux-gnu &amp; /usr/include 安装 CUDA 验证是否安装 gcc 1$ gcc --version 如果输出如： 12Command 'gcc' not found, but can be installed with:sudo apt install gcc 则意味着当前主机尚未安装 gcc，需运行以下指令进行安装： 12$ sudo apt update$ sudo apt install build-essential manpages-dev 下载 下载地址：CUDA 10.0 安装 首先，停用 gdm（Ubuntu 桌面环境），在命令行界面（ Ctrl + Alt + F1 ~ F6 ）或者远程连接（ SSH ）的命令行界面下进行指令输入 1$ sudo service gdm stop 随后，安装 CUDA 以及补丁包，按照命令行提示进行操作 12$ sudo sh cuda_10.0.xxx_xxx.xx_linux.run$ sudo sh cuda_10.0.xxx.x_linux.run 最后，恢复桌面环境 1$ sudo service gdm start 验证是否安装成功，共有三种方法： 1$ nvcc -V 输出应为： 1234nvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2018 NVIDIA CorporationBuilt on Sat_Aug_25_21:08:01_CDT_2018Cuda compilation tools, release 10.0, V10.0.130 1$ cat /proc/driver/nvidia/version 输出应为： 12NVRM version: NVIDIA UNIX x86_64 Kernel Module 418.56 Fri Mar 15 12:59:26 CDT 2019GCC version: gcc version 4.8.4 (Ubuntu 4.8.4-2ubuntu1~14.04.4) 1$ cat /usr/local/cuda/version.txt 输出应为： 1CUDA Version 10.0.130 系统重启 若出现异常，这里也许能有相似的情况。 检查检查设备文件 /dev/nvidia* 是否存在，且文件权限是否正确 (666)。通常情况下，这些文件会被需要用到 NVIDIA 驱动的应用程序 (如 CUDA 应用或 X server) 经由调用 nvidia-modprobe自动生成。 但你也可以通过下面的脚本程序，手动创建这些文件。 12345678910111213141516171819202122232425262728293031#!/bin/bash/sbin/modprobe nvidiaif [ &quot;$?&quot; -eq 0 ]; then # Count the number of NVIDIA controllers found. NVDEVS=`lspci | grep -i NVIDIA` N3D=`echo &quot;$NVDEVS&quot; | grep &quot;3D controller&quot; | wc -l` NVGA=`echo &quot;$NVDEVS&quot; | grep &quot;VGA compatible controller&quot; | wc -l` N=`expr $N3D + $NVGA - 1` for i in `seq 0 $N`; do mknod -m 666 /dev/nvidia$i c 195 $i done mknod -m 666 /dev/nvidiactl c 195 255else exit 1fi/sbin/modprobe nvidia-uvmif [ &quot;$?&quot; -eq 0 ]; then # Find out the major device number used by the nvidia-uvm driver D=`grep nvidia-uvm /proc/devices | awk '{print $1}'` mknod -m 666 /dev/nvidia-uvm c $D 0else exit 1fi 配置环境变量 123$ export PATH=/usr/local/cuda-10.1/bin:/usr/local/cuda-10.0/NsightCompute-2019.1${PATH:+:${PATH}}$ export LD_LIBRARY_PATH=/usr/local/cuda-10.0/lib64\\ ${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} 这样设置是临时性的，你可以将之复制到 ~/.bashrc 中，以达到永久设置的目的。 安装 cuDNN 下载 下载地址：cuDNN 所有版本 找到 Download cuDNN v7.4.2 (Dec 14, 2018), fro CUDA 10.0，下载三个 DEB 文件（cuDNN Runtime Library、cuDNN Developer Library、 cuDNN Code Samples and User Guide） 安装 123$ sudo dpkg -i libcudnn7_7.4.2.xx-1+cuda10.0_amd64.deb // 运行时库$ sudo dpkg -i libcudnn7-dev_7.4.2.xx-1+cuda10.0_amd64.deb // 开发者库$ sudo dpkg -i libcudnn7-doc_7.4.2.24-1+cuda10.0_amd64.deb // 代码案例和用户指南 验证 1$ grep -i cudnn_major -A 2 /usr/include/cudnn.h 输出应为： 1234567#define CUDNN_MAJOR 7#define CUDNN_MINOR 4#define CUDNN_PATCHLEVEL 2--#define CUDNN_VERSION (CUDNN_MAJOR * 1000 + CUDNN_MINOR * 100 + CUDNN_PATCHLEVEL)#include &quot;driver_types.h&quot; 问题与解决 无限重复登陆；重启后黑屏，左上角有一下划线不断闪烁： 解决方案：远程登录 (SSH) ，更新 GPU 驱动至更高版本 123456789101112131415161718ssh NAME@IP -p 22............$ ubuntu-drivers devices== /sys/devices/pci0000:00/0000:00:03.0/0000:03:00.0/0000:04:10.0/0000:05:00.0 ==vendor : NVIDIA Corporationmodalias : pci:vxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdriver : nvidia-418 - third-party freedriver : xserver-xorg-video-nouveau - distro free builtindriver : nvidia-415 - third-party freedriver : nvidia-430 - third-party free recommendeddriver : nvidia-384 - third-party non-freedriver : nvidia-410 - third-party free$ sudo apt install nvidia-xxx$ sudo reboot 启动并登陆系统后只显示壁纸，无顶栏与左侧快捷栏 解决方案有两种： 新建一个用户账号，注销当前账号，换用新账号登陆。原理未知。 换用系统主题 (Ubuntu -&gt; 其他)。在刚启动系统，进行账号登录时，在登录按钮左边有一个齿轮状的按钮，点击一下你就了解了。 参考 CUDA installation Guide Linux - NVIDIA cuDNN install - NVIDIA install gcc - linuxize install the nvidia drivers - linuxconfig 系列 「TensorFlow」1. 安装 CUDA 和 cuDNN 「TensorFlow」2. 编译 TensorFlow C++ 以上！","link":"/TensorFlow/installation-of-cuda-toolkit-and-cudnn/"},{"title":"「C++」string 成员函数","text":"简述：类string声明于C++ STL（Standard Template Library)中的一个头文件&lt;string&gt;中，与char类型字符串相比较，它显得方便而强大。 string简介 &lt;string&gt;是C++标准程序库中的一个头文件，定义了C++标准中的字符串的基本模板类std::basic_string及相关的模板类实例，这里不进行详细介绍。详细可查看相关 wiki百科 ，以及 cplusplus 。 其中的string是以char作为模板参数的模板类实例，把字符串的内存管理责任由string负责而不是由用户负责，大大减轻了C语言风格的字符串的麻烦。 std::basic_string提供了大量的字符串操作函数，如比较、连接、搜索、替换、获得子串等。并可与C语言风格字符串双向转换。std::basic_string属于C++ STL容器类，用户自定义的类也可以作为它的模板参数，因此也适用C++ STL Algorithm库。 声明变量123456......#include &lt;string&gt;...... std::string str;...... 成员函数 构造与析构 string::string（构造） string::~string（析构） string::operator = - 赋值 string::assign – 赋值 string::get_allocator – 获得内存分配器 字符访问 string::at – 访问特定字符，带边界检查 string::operator [] – 访问特定字符 string::front – 访问第一个字符 string::back – 访问最后一个字符 string::data – 访问基础数组，C++11后与c_str()完全相同 string::c_str – 返回对应于字符串内容的C风格零结尾的只读字符串 string::substr – 以子串构造一个新串；参数为空时取全部源串 迭代器 string::begin – 获得指向开始位置的迭代器 string::end – 获得指向末尾的迭代器 string::rbegin – 获得指向末尾的逆向迭代器 string::rend – 获得指向开始位置的逆向迭代器 string::cbegin – 获得指向开始位置的只读迭代器 string::cend – 获得指向末尾的只读迭代器 string::crbegin – 获得指向末尾的逆向只读迭代器 string::crend – 获得指向开始位置的逆向只读迭代器 容量 string::empty – 检查是否为空 string::size – 返回数据的字符长度 string::length – 返回数据的字符长度，与size()完全相同 string::max_size – 返回可存储的最大的字节容量，在32位Windows上大概为 43 亿字节。 string::reserve – 改变string的字符存储容量，实际获得的存储容量不小于reserve的参数值。 string::capacity – 返回当前的字符存储容量 string::shrink_to_fit（C++11 新增） – 降低内存容量到刚好 修改器 string::clear – 清空内容 string::insert – 插入字符或字符串。目标string中的插入位置可用整数值或迭代器表示。如果参数仅为一个迭代器，则在其所指位置插入0 值。 string::erase – 删除 1 个或 1 段字符 string::push_back – 追加 1 个字符 string::pop_back – 删除最后 1 个字符，C++11标准引入 string::append – 追加字符或字符串 string::operator+= – 追加，只有一个参数——字符指针、字符或字符串；不像append()一样可以追加参数的子串或若干相同字符 string::copy – 拷贝出一段字符到C风格字符数组；有溢出危险 string::resize – 改变（增加或减少）字符串长度；如果增加了字符串长度，新字符缺省为0值 string::swap – 与另一个string交换内容 string::replace – 替换子串；如果替换源数据与被替换数据的长度不等，则结果字符串的长度发生改变 搜索 string::find – 前向搜索特定子串的第一次出现 string::rfind – 从尾部开始，后向搜索特定子串的第一次出现 string::find_first_of – 搜索指定字符集合中任意字符在*this中的第一次出现 string::find_last_of – 搜索指定字符集合中任意字符在*this中的最后一次出现 string::find_first_not_of – *this中的不属于指定字符集合的首个字符 string::find_last_not_of – *this中的不属于指定字符集合的末个字符 string::compare – 与参数字符串比较 常量值 string::npos – 表示“未找到”，值为static const unsigned -1 非成员的有关的全局函数 std::operator+ – 字符串连接 std::operator!= – 不等比较 std::operator== – 相等比较 std::operator&lt; – 小于比较 std::operator&lt;= – 小于等于比较 std::operator&gt; – 大于比较 std::operator&gt;= – 大于等于比较 std::operator&lt;&lt; – 字符串内容写到输出流中 std::operator&gt;&gt; – 从输入流中读取一个字符串 std::getline – 从istream中读入一行或一段字符到string中 std::swap – 交换两个string的内容。是std::swap算法针对std::basic_string的特化版本 std::stoi – 字符串转为整形 std::stol – 字符串转为长整形 std::stoll – 字符串转为长长整形 std::stoul – 字符串转为无符号长整形 std::stoull – 字符串转为无符号长长整形 std::stof – 字符串转为单精度浮点形 std::stod – 字符串转为双精度浮点形 std::stold – 字符串转为长双精度浮点形 std::to_string – 整型、无符号整型、浮点型转化为string std::to_wstring – 整型、无符号整型、浮点型转化为wstring std::hash&lt;std::string&gt; – 计算hash值 std::hash&lt;std::wstring&gt; – 计算hash值 std::hash&lt;std::u16string&gt; – 计算hash值 std::hash&lt;std::u32string&gt; – 计算hash值 以上！","link":"/C/introduction-of-string/"},{"title":"「Hexo」配置多终端推送文章","text":"简述：Hexo 博客系统很轻便，经常配合 Github Page 使用。多终端推送更新是个问题，不过网上的解决方法很多，也基本一致，窝也记录一下自己的操作过程。 1 更新Repo1$ npm audit 根据终端提示内容，对 Repo 进行更新。在其他终端拉取仓库并进行简要配置后，就可以推送文章了。 当然，麻烦总是多过预期。不过，warning存在的意义就是被忽视，解决error就好了（ 2 第一终端配置本地 Hexo 对应文件夹其实就有.gitignore文件，可知 Hexo 也是支持将源文件存放到 Github 的。 注意事项： 本地 themes 文件夹下有git clone下载的主题，需先将对应目录下的 .git 文件夹删除，并将 themes 剪切到别处。将 Hexo 文件夹 add-&gt;commit-&gt;push三连后，再将之剪切回来，另行 add-&gt;commit-&gt;push 操作三连。 在 Hexo 对应目录下执行以下指令： 123456$ git init$ git checkout -b hexo // 新建并切换到分支 hexo$ git add . $ git commit -m 'Hexo Source'$ git remote add origin git@github.com:USERNAME/USERNAME.github.io.git$ git push origin hexo // 推送到 Github Page 仓库的 hexo 分支 3 其他终端配置1234$ git clone -b hexo git@github.com:USERNAME/USERNAME.github.io.git DIRNAME/$ cd DIRNAME$ npm install -g hexo-cli$ npm install // 这里不需要 npm init 4 新增文章并推送（任意终端）123456$ git pull origin hexo // 拉取 Github 端的最新仓库，防止 commit 时出现冲突$ hexo new &quot;POST_NAME&quot;$ git add source/$ git commit -m &quot;COMMIT_TITLE&quot;$ git push origin hexo$ hexo g -d 参考自： https://resalee.github.io/2017/11/01/hexo-github-blog/ https://www.zhihu.com/question/21193762 以上！","link":"/Manual/multiple-pc-configuration-of-hexo/"},{"title":"「Linux」VPS 重启后未分配 IP","text":"简述：VPS（Ubuntu OS）重启后出现未分配 IP 地址而无法连接的问题，具体现象为 ifconfig 命令未显示网络接口 eth0 的信息。解决办法为通过 VNC 登陆 VPS，调用 ifconfig 启用网络接口 eth0，再调用 dhclient 向 DHCP 服务器请求 IP。 1 问题与解决1.1 问题描述VPS（Ubuntu OS）重启后出现未分配 IP 地址而无法连接的问题。具体现象为 cat /etc/network/interfaces 的信息中包含网络接口 lo 与 eth0。 123456789101112auto loiface lo inet loopbackauto eth0iface eth0 inet static address XXX.XXX.XXX.XXX netmask 255.255.255.0 broadcast XXX.XXX.XXX.255 network XXX.XXX.XXX.0 gateway XXX.XXX.XXX.1dns-nameserver 8.8.8.8 但 ifconfig 命令只显示网络接口 lo 的信息，即 eth0 未激活。 12345678lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 43 bytes 5520 (5.5 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 43 bytes 5520 (5.5 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 在本地 ping 远程 VPS，显示连接超时，也无法通过 SSH 登录 VPS。 1.2 解决方案 激活网络接口 eth0。shell 命令： 1$ sudo ifconfig eth0 up 网络接口的名字不一定是 eth0，可通过 cat /etc/network/interfaces 查看所有网络接口。 通过 DHCP 协议配置网络接口的参数。shell 命令： 1$ sudo dhclient eth0 查看网络接口 eth0 的信息。shell 命令： 1$ sudo ifconfig eth0 2 ifconfigifconfig 是 interface configuration 的缩写，能够显示网络接口信息，配置网络接口。不给定参数的情况下，ifconfig 会显示当前启用的网络接口信息。 2.1 语法12ifconfig [-v] [-a] [-s] [interface]ifconfig [-v] interface [aftype] options | address ... 2.2 用法 写法 含义 ifconfig 显示可用网络接口的信息。 ifconfig -a 显示所有网络接口的信息。 ifconfig eth0 显示网络接口 eth0 的信息。 ifconfig eth0 up 启用网络接口 eth0。 ifconfig eth0 down 停用网络接口 eth0。 ifconfig eth0 172.16.25.125 设置网络接口 eth0 的 IP 地址。 ifconfig eth0 netmask 255.255.255.224 设置网络接口 eth0 的子网掩码。 ifconfig eth0 broadcast 172.16.25.63 设置网络接口 eth0 的广播地址。 ifconfig eth0 mtu 1000 设置网络接口 eth0 的 MTU（最大传输单元）。 3 dhclientdhclient 的全写是 Dynamic Host Configuration Protocol（DHCP） Client。 DHCP 协议用于让中央服务器给主机分配一个网络 IP 地址。 起初，主机设备的网络接口并未被分配一个 IP 地址，所以该主机无法连接。（可以通过 ip address 或 ifconfig -a 来验证这一点）。 调用 dhclient，能够向 DHCP 服务器请求一个 IP 地址。主机向本地网络中的广播地址发送一个 DHCP discovery message，（在路由器或网关）运行的 DHCP 服务器收到消息后向该主机发送一个 DHCP offer message，提供一个 IP 地址。 dhclient 的配置文件是 dhclient.conf。 3.1 语法1234567891011dhclient [ -4 | -6 ] [ -S ] [ -N [ -N... ] ] [ -T [ -T... ] ] [ -P [ -P... ] ] -R ] [ -i ] [ -I ] [ -4o6 port ] [ -D LL|LLT ] [ -p port-number ] [ -d ] [ -df duid-lease-file ] [ -e VAR=value ] [ -q ] [ -1 ] [ -r | -x ] [ -lf lease-file ] [ -pf pid-file ] [ --no-pid ] [ -cf config-file ] [-sf script-file ] [ -s server-addr ] [ -g relay ][ -n ] [ -nw ] [ -w ] [ --dad-wait-time seconds ][ --prefix-len-hint length ] [ --decline-wait-time seconds ] [ -v ] [ --version ][ if0 [ ...ifN ] ] 3.2 选项 选项 含义 -p 指定 DHCP 客户端监听的端口号（默认端口号 86） -d 总是以前台方式运行程序 -q 安静模式，不打印任何错误的提示信息 -r 释放 IP 地址 -n 不配置任何接口 -x 停止正在运行的 DHCP 客户端，而不释放当前租约，杀死现有的 dhclient -s 在获取 IP 地址之前指定 DHCP 服务器 -w 即使没有找到广播接口，也继续运行 4 参考 ubuntu 下 eth0 网卡信息不见了 - CSDN 如何在 Linux 命令行上查看 IP 地址 - Howtoing 15 Useful “ifconfig” Commands to Configure Network Interface in Linux - Tecmint What does dhclient do? - Stack Overflow 以上！","link":"/Linux/no-ip-after-rebooting/"},{"title":"「Testing」测试框架 PowerMock 使用手册","text":"简述：这篇文章主要是列出 Android 测试框架 PowerMock 的常用 API 和一些注解。其中某些 API 其实并没有用过，所以不能保证全文毫无错误。在此之前，建议先阅读一些入门文章，了解单元测试是什么和为什么做单元测试。 1 注解1.1 [JUnit] RunWith When a class is annotated with @RunWith or extends a class annotated with @RunWith, JUnit will invoke the class it references to run the tests in that class instead of the runner built into JUnit. We added this feature late in development. While it seems powerful we expect the runner API to change as we learn how people really use it. Some of the classes that are currently internal will likely be refined and become public. 简单地说，JUnit 会使用 @RunWith 中的 Runner 类，代替 JUnit 的内建 Runner 来运行测试。 参考 Annotation Type RunWith 1.2 [PowerMock] PrepareForTest Tells PowerMock to prepare certain classes for testing. Classes needed to be defined using this annotation are typically those that needs to be byte-code manipulated. This includes final classes, classes with final, private, static or native methods that should be mocked and also classes that should be return a mock object upon instantiation. 翻译过来，PrepareForTest 的作用就是提醒 PowerMock 对待测试的类做准备。这些待测试的类可以是： final 类 类中有需要 mock 的 final/private/static/native 方法 希望实例后返回的是某个类的 mock 对象 参考 Annotation Type PrepareForTest 1.3 [PowerMock] PowerMockIgnore This annotation tells PowerMock to defer the loading of classes with the names supplied to value() to the system classloader. This is useful in situations when you have e.g. a test/assertion utility framework (such as something similar to Hamcrest) whose classes must be loaded by the same classloader as EasyMock, JUnit and PowerMock etc. Note that the PrepareForTest and PrepareOnlyThisForTest will have precedence over this annotation. This annotation will have precedence over the PrepareEverythingForTest annotation. PowerMock 会延迟 system classloader 对在 PowerMockIgnore 中的类的加载。如果测试框架的类需要由 JUnit/EasyMock/PowerMock 的类加载器来加载，就可以用上 PowerMockIgnore 了。 不过，PrepareForTest 和 PrepareOnlyThisForTest 的优先级比 PowerMockIgnore 高。 参考 Annotation Type PowerMockIgnore 2 构造对象2.1 mock1T object = PowerMockito.mock(Class&lt;? extends Object&gt; type); 2.2 spy1T object = PowerMockito.spy(T object); 参考 Mockito – Using Spies What is the difference between mocking and spying when using Mockito - StackOverflow Mockito 的 mock 和 spy Mockito Mock 與 Spy 的差別 3 访问/修改非公有成员3.1 访问非 public 成员1ClassName obj = Whitebox.getInternalState(Object object, String fieldName); PS：假设类名为 Example，访问静态成员时，object 就是 Example.class。不止是访问非公有成员，其他与 static 有关的操作像是修改静态成员和调用静态方法等，object 都是 Example.class。 3.2 修改非 public 成员1Whiterbox.setInternalState(Object object, String fieldName, Object value); 4 调用/执行方法4.1 public 方法直接调用就行了鸭！ 4.2 非 public 方法12345// 有返回值ClassName toBeReturned = Whitebox.invokeMethod(Object object, String methodToExecute, Object... arguments);// 无返回值Whitebox.invokeMethod(Object object, String methodToExecute, Object... arguments); 4.3 调用 mock 对象真正的方法PS：先设置，再调用。设置 != 调用。另外，对象是通过 mock 得到的 1234567// public 方法Powermockito.doCallRealMethod().when(Object object).METHOD(Object... arguments); // 设置object.METHOD(Object... arguments); // 调用// 非 public 方法Powermockito.doCallRealMethod().when(Object object, String methodToExecute, Object... arguments);Whitebox.invokeMethod(Object object, String methodToExecute, Object... arguments); 5 设定方法返回值PS：此节的对象都是 mock / spy 对象。 5.1 普通方法 public 方法 12345// 有返回值PowerMockito.doReturn(Object toBeReturned).when(mockedClass).METHOD(Object.. Arguments);// 无返回值PowerMockito.doNothing().when(T mock).METHOD(Obecject... arguments); 非 public 方法 12345// 有返回值PowerMockito.doReturn(Object toBeReturned).when(T mock, String methodToExpect, Obecject... arguments);// 无返回值PowerMockito.doNothing().when(T mock, String methodToExpect, Obecject... arguments); 5.2 静态方法 public 方法 1234567891011PowerMockito.mockStatic(Class&lt;?&gt; type, Class&lt;?&gt;... types)// 有两种方式，第一种更接近正常逻辑// 1)// 有返回值PowerMockito.when(T.STATIC_METHOD(Object... arguments)).thenReturn(Object toBeReturned);// 2)// 有返回值PowerMockito.doReturn(...).when(T mock);T.STATIC_METHOD(Object... arguments); 非 public 方法 12345678910111213PowerMockito.mockStatic(Class&lt;?&gt; type, Class&lt;?&gt;... types)// 1)// 有返回值PowerMockito.when(T.class, String methodToExpect, Obecject... arguments).thenReturn(Object toBeReturned);// 2)// 有返回值PowerMockito.doReturn(...).when(T mock);Whitebox.invokeMethod(T.class, String methodToExpect, Obecject... arguments);// 无返回值PowerMock.doNothing().when(T.class, String methodToExpect, Object... arguments); 对于 spy 对象来说，`when().doReturn()` 仍然会执行指定方法的真实代码逻辑，虽然返回结果被修改了；而 `doReturn().when().METHOD()`，就确实屏蔽了指定方法。 对于 mock 对象来说，这两者就没有区别。 参考 Mock/Spy 能力 - zhihu Use doReturn to partially mock static method with PowerMockito - StackOverflow doNothing.When for private void method itself is invoking method - StackOverflow Mockito: doReturn vs thenReturn 6 验证方法PS: 先调用外层方法，再验证外层方法内调用过的方法 6.1 普通方法 public 方法 12345678// 验证方法的调用和相关参数Mockito.verify(? Extends Object mock).METHOD(Object... arguments); // 只验证方法的调用，any()，any(T.class)，anyInt()，anyString()Mockito.verify(? Extends Object mock).METHOD(Mockito.any()); // 验证方法没有被调用Mockito.verify(? Extends Object mock, Mockito.never()).METHOD(Object... arguments); PS: 以下的各类验证，对 Mockito.never() 的使用都可以参照这个例子。 [Mockito.ArgumentMatchers.]any() 是一个匹配器，它可以匹配 null 和任意对象。但它不能匹配 Java 的基础类型（int，double，boolean），可以使用 anyInt()，anyDouble()，anyBoolean() 来匹配。 非 public 方法 1PowerMockito.verifyPrivate(Object object).invoke(&quot;MethodName&quot;, Argument); 6.2 静态方法PS: 每个待验证的静态方法都需要一个 verifyStatic()。 public 方法 123456PowerMockito.mockStatic(Class&lt;?&gt; type);...... // 调用方法PowerMockito.verifyStatic(Class&lt;T&gt; mockedClass, VerificationMode mode);T.STATIC_METHOD(Object... arguments); // 待验证的静态方法 非 public 方法 123456PowerMockito.mockStatic(Class&lt;?&gt; type);...... // 调用方法PowerMockito.verifyStatic(Class&lt;T&gt; mockedClass, VerificationMode mode);Whitebox.invokeMethod(Class&lt;T&gt; mockedClass, String methodToExecute, Object... arguments); // 待验证的静态方法 参考 Mockito Verify Cookbook PowerMockito.verifyStatic() problems - StackOverflow MockStatic - PowerMockito Docs 7 抑制方法首先，对测试类使用类级注解 @PrepareForTest(ClassWithEvilConstructor.class)。 然后，分以下三种情况，实现对特定方法的抑制。 7.1 普通方法 12345// 有参数PowerMockito.suppress(MemberMatcher.method(Class&lt;?&gt; declaringClass, String methodName, Class&lt;?&gt;... parameterTypes));// 无参数PowerMockito.suppress(MemberMatcher.method(Class&lt;?&gt; declaringClass, String methodName); 7.2 静态方法先 mock 后 suppress 1234567PowerMockito.mockStatic(Class.class);// 有参数PowerMockito.suppress(MemberMatcher.method(Class&lt;?&gt; declaringClass, String methodName, Class&lt;?&gt;... parameterTypes));// 无参数PowerMockito.suppress(MemberMatcher.method(Class&lt;?&gt; declaringClass, String methodName); 7.3 构造方法12345// 有参数PowerMockito.suppress(MemberMatcher.constructor(Class&lt;T&gt; declaringClass, Class&lt;?&gt;... parameterTypes));// 无参数PowerMockito.suppress(MemberMatcher.constructor(Class&lt;T&gt; declaringClass)); 参考 Suppress unwanted behavior - GitHub Wiki How to suppress and verify private static method calls? 8 与 Robolectric 协同 https://github.com/robolectric/robolectric/wiki/Using-PowerMock 以上！","link":"/Testing/powermock-api/"},{"title":"搭建简易 web 服务器过程中的问题","text":"简述： 500 lines or less 是一本在Github上开源的Python教程书籍，内容包含有18个Python Project。正如书名，都是低于500行代码的Project。 而我尝试了一下 A Simple Web Server（这里给出中文翻译链接）这个项目，对我还是有一些难度的，毕竟对web编程懂得很少。而且，项目是基于Python2的，而我自学的是Python3，因此编写过程中遇到了2个问题。 库名变化问题 原Python2程序中导入了库 BaseHTTPServer ，但在Python3中，该库已经改为 http.server 。 解决办法 import BaseHTTPServer —&gt; import http.server 就是这样，而已。 # 网页编码 ## 问题 原Python2程序中有一段类似如下的html代码， 1234567Page = &quot;&quot;&quot;\\ &lt;html&gt; &lt;body&gt; &lt;p&gt;Hello, web!&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot; 但运行时出现 TypeError: a bytes-like object is required, not 'str'。 解决办法 解决办法有两种，一种是使用前缀 b 将str转化为bytes；另一种是使用 str.encode('utf-8')。 1234567Page = b&quot;&quot;&quot;\\ ...all the other code... &quot;&quot;&quot;或者Page = &quot;&quot;&quot;\\ ...all the other code... &quot;&quot;&quot;.encode('utf-8') 我在StackOverFlow上找到相关解释，大概意思是：在Python3中字符串是Unicode形式，但在网络中，数据应该是以字节的形式传输。 The reason for this error is that in Python 3, strings are Unicode, but when transmitting on the network, the data needs to be bytes strings instead. So… a couple of suggestions: …… Best solution: 12output = 'Thank you for connecting'c.sendall(output.encode('utf-8')) 以上！","link":"/Python/questions-of-constructing-web-server/"},{"title":"重装系统中遇到的麻烦","text":"简述：每次重装系统都是一次全新的“体验”。这次遇到的麻烦是UEFI和legacy，GPT硬盘和MBR硬盘的冲突。重装完系统后还出现无法从硬盘启动（reboot and select proper boot device）的问题。 UEFI方式和MBR格式的冲突问题描述 选择win10安装版本和格式化驱动器0之后，点击下一步时，出现如下错误： Windows无法安装到这个磁盘。选中的磁盘具有MBR分区表。在EFI系统上，Windows只能安装到GPT磁盘。 原因 win8/win10系统均添加快速启动功能，预装的win8/win10电脑默认都是UEFI引导和GPT硬盘，传统的引导方式为Legacy引导和MBR硬盘，UEFI必须跟GPT对应，同理Legacy必须跟MBR对应。 如果BIOS开启UEFI，而硬盘分区表格式为MBR则无法安装；BIOS关闭UEFI而硬盘分区表格式为GPT也是无法安装Windows。 (注意事项：转换分区表格式会清空硬盘所有数据!) 解决办法 因为重装win10系统使用的UEFI引导方法，所以需要把驱动器0从MBR转化到GPT。解决步骤： （1）在当前安装界面按住Shift+F10，唤出命令提示符窗口； （2）输入diskpark，回车，进入DISKPART模式； （3）输入list disk，回车，列出当前磁盘信息； （4）输入select disk 0，回车，选中驱动器0； （5）输入clean，回车，删除驱动器0的分区； （6）输入convert gpt，回车，驱动器0转化为GPT格式，之后关闭命令提示符窗口即可。 # 无法从硬盘启动 ## 问题描述 成功重装系统后，开机时出现如下提示： >Reboot and Select proper Boot device >or Insert Boot Media in Selected device_ 解决办法 我很懵逼！ 最后尝试性地在Bios中的Advanced，将OS support从Legacy OS改成UEFI OS，保存后退出。这次启动，就成功进入win10系统。 原因，应该还是引导办法不对。但不知道为何，我明明成功在GPT格式硬盘上安装系统了，这说明引导方式是UEFI，但却还是发生这个错误。 PS：我的笔记本电脑型号是麦本本锋麦S。BIOS没有升级或重装过。 # 名词解释 >MBR—-Master Boot Record（主引导扇区） > >之所以叫“主引导扇区”，是因为它是存在于驱动器开始部分的一个特殊的启动扇区。这个扇区包含了已安装的操作系统的启动加载器和驱动器的逻辑分区信息。所谓启动加载器，是一小段代码，用于加载驱动器上其他分区上更大的加载器。 > >如果你安装了Windows，Windows启动加载器的初始信息就放在这个区域里——如果MBR的信息被覆盖导致Windows不能启动，你就需要使用Windows的MBR修复功能来使其恢复正常。如果你安装了Linux，则位于MBR里的通常会是GRUB加载器。 > >MBR支持最大2TB磁盘，它无法处理大于2TB容量的磁盘。MBR还只支持最多4个主分区——如果你想要更多分区，你需要创建所谓“扩展分区”，并在其中创建逻辑分区。 - GPT—-GUID Partition Table（全局唯一标识分区表） 这是一个正逐渐取代MBR的新标准。它和UEFI相辅相成——UEFI用于取代老旧的BIOS，而GPT则取代老旧的MBR。之所以叫作“GUID分区表”，是因为你的驱动器上的每个分区都有一个全局唯一的标识符（globally unique identifier，GUID）——这是一个随机生成的字符串，可以保证为地球上的每一个GPT分区都分配完全唯一的标识符。 这个标准没有MBR的那些限制。磁盘驱动器容量可以大得多，大到操作系统和文件系统都没法支持。它同时还支持几乎无限个分区数量，限制只在于操作系统——Windows支持最多128个GPT分区，而且你还不需要创建扩展分区。 在MBR磁盘上，分区和启动信息是保存在一起的。如果这部分数据被覆盖或破坏，事情就麻烦了。相对的，GPT在整个磁盘上保存多个这部分信息的副本，因此它更为健壮，并可以恢复被破坏的这部分信息。 GPT还为这些信息保存了循环冗余校验码（CRC）以保证其完整和正确——如果数据被破坏，GPT会发觉这些破坏，并从磁盘上的其他地方进行恢复。而MBR则对这些问题无能为力——只有在问题出现后，你才会发现计算机无法启动，或者磁盘分区都不翼而飞了。","link":"/Experience/questions-of-resetting-system/"},{"title":"「PyQt5」2. QPushButton 的 signals 和 slots","text":"简述：Graphical Application是事件驱动型的，和控制台或终端程序不同。所谓事件，就是诸如点击按钮、选择多选框中一条选项这样的用户行为。 本文记录的是QPushButton的signals和slots，仅为笔记。 名词解释 signal翻译为信号，指事件发生时PyQt5 widget发送的信号。 slot：翻译为槽（奇奇怪怪），是任何可调用的函数或方法。 对于QPushButton来说，signal是点击按钮时QPushButton发送的Clicked()信号，slot可以是自己编写的可调用函数/方法，也可以是PyQt5自有的函数/方法。 QPushButton的signals QPushButton具有如下signal： clicked()：This signal is emitted when the button is activated (i.e., pressed down then released while the mouse cursor is inside the button), when the shortcut key is typed, or when click() or animateClick() is called. Notably, this signal is not emitted if you call setDown(), setChecked() or toggle(). pressed()：This signal is emitted when the button is pressed down. released()：This signal is emitted when the button is released. toggled()：This signal is emitted whenever a checkable button changes its state. destroyed()：类被摧毁，信号不可阻断。 objectNameChanged()：类名变化。 前四者继承自PyQt5.QtWidgets.QWidget.QAbstractButton，后二者继承自PyQt5.QtCore.QObject。 实例12345678910111213141516171819202122232425262728293031323334353637# coding=utf-8import sysfrom PyQt5.QtWidgets import (QWidget, QPushButton, QApplication, QLabel, QGridLayout)from PyQt5.QtCore import Qtclass Exmaple(QWidget): def __init__(self): super().__init__() self.setup_ui() def setup_ui(self): self.btn = QPushButton('Click me') self.btn.clicked.connect(self.prt) # 链接signal与slot self.lbl = QLabel() self.grid = QGridLayout() self.grid.addWidget(self.btn, 1, 0) self.grid.addWidget(self.lbl, 2, 0) self.setLayout(self.grid) self.grid.setSpacing(20) # 控件与控件、控件与窗口边界之间的留白 self.setWindowTitle('Example') self.show() def prt(self): self.lbl.setText('Clicked!') self.lbl.setAlignment(Qt.AlignCenter)if __name__ == &quot;__main__&quot;: app = QApplication(sys.argv) ex = Exmaple() sys.exit(app.exec_()) self.btn.clicked.connect(self.prt)将clicked()与处理程序prt()链接起来，其中，clicked()是signal，prt()是slot。除此之外，还有另外一种链接办法： 1PyQt5.QtCore.QObject.connect(widget, QtCore.SIGNAL(‘signalname’), slot_function) **以上！**","link":"/Python/PyQt5/signals-and-slots-of-button/"},{"title":"「C++」vector 用法","text":"简述：vector是C++标准程序库中的一个类，众多容器（container）之一，可视为会自动扩展容量的数组，以循序(sequential)的方式维护变量集合，是一种非常实用的容器。 # vector介绍 `vector`以模板(泛型)方式实现，可以保存任意类型的变量，包括用户自定义的数据类型，例如：它可以是放置整数（`Int`）类型的 `vector`、也可以是放置字符串（`string`）类型的 `vector`、或者放置用户自定类别（`user-defined class`）的`vector`。 `vector`的特色有支持随机存取，在集合尾端增删元素很快，但是在集合中间增删元素比较费时。 `vector`类定义于``头文件中。 # vector类的方法 12#include &lt;vector&gt; std:: vector&lt;TYPE&gt; vec; - 访问元素 - `vec[i]` - 访问索引值为`i`的元素引用。 (索引值从零起算，故第一个元素是`vec[0]`。) - `vec.at(i)` - 访问索引值为`i`的元素的引用，以`at()`访问会做数组边界检查，如果访问越界将会抛出一个异常，这是与`operator[]`的唯一差异。 - `vec.front()` - 回传`vector`第一个元素的引用。 - `vec.back()` - 回传`vector`最尾端元素的引用。 - 新增或移除元素 - `vec.push_back()` - 新增元素至`vector`的尾端，必要时会进行存储器配置。 - `vec.pop_back()` - 删除`vector`最尾端的元素。 - `vec.insert()` - 插入一个或多个元素至`vector`内的任意位置。 - `vec.erase()` - 删除`vector`中一个或多个元素。 - `vec.clear()` - 清空所有元素。 - 获取长度/容量 - `vec.size()` - 获取`vector`目前持有的元素个数。 - `vec.empty()` - 如果`vector`内部为空，则传回`true`值。 - `vec.capacity()` - 获取`vector`目前可容纳的最大元素个数。这个方法与存储器的配置有关，它通常只会增加，不会因为元素被删减而随之减少。 - 重新配置／重置长度 - `vec.reserve()` - 如有必要，可改变`vector`的容量大小（配置更多的存储器）。在众多的`STL`实例，容量只能增加，不可以减少。 - `vec.resize()` - 改变`vector`目前持有的元素个数。 - 迭代 (Iterator) - `vec.begin()` - 回传一个`iterator`，它指向`vector`第一个元素。 - `vec.end()` - 回传一个`iterator`，它指向`vector`最尾端元素的下一个位置（请注意：它不是最末元素）。 - `vec.rbegin()` - 回传一个反向`iterator`，它指向`vector`最尾端元素的。 - `vec.rend()` - 回传一个`iterator`，它指向`vector`的第一个元素的前一个位置。 # 二维vector ## 声明 ​```C++ std::vector VEC_NAME; //VEC_NAME: 容器名 12345## 增添元素```C++std::vector&lt;vector&lt;TYPE&gt; VEC_NAME;VEC_NAME[0].push_back(element); //在容器内的第一子容器末添加值为element的数据，容量size变大 删减元素12std::vector&lt;vector&lt;TYPE&gt;&gt; VEC_NAME;VEC_NAME[0].pop_back(); //删减容器内第一子容器的末元素，不返回元素 以上！","link":"/C/vector/"},{"title":"VSCode 工作目录和 os.getcwd() 之间的冲突","text":"简述： VScode用起来觉得不错，相较之下，Sublime Text3对中文字符串的支持就不怎么样了。不过VSCode也存在一个问题：VSCode工作目录和函数 os.getcwd() 有冲突。 问题 我发现在VScode中写Python代码，若是有调用 os.getcwd() ，调用结果将可能存在错误，因为这个函数和VSCode的工作目录存在冲突。 具体情况12import osprint(os.getcwd()) 比如，VSCode 的工作目录为 F:\\Python ，而代码如上的.py程序文件存放路径为 F:\\Python\\Python_work 时，执行程序的输出结果是：F:\\Python。 解决办法 经过Google，我在 CSDN 博主ljzhang的一篇博文中找到了解决办法。 将程序对应代码改成如下，就能够获取正确的当前目录路径。 1234import osprint(os.path.dirname(__file__))或者print(os.path.abspath(os.path.dirname(__file__))) 产生这种情况的具体原因是什么，我还不清楚。以后在 VScode写 Python , 只能避免使用函数 os.getcwd() 了。 以上！","link":"/Python/vscode-and-os-getcwd/"},{"title":"「Java」为什么“多态”","text":"简述：多态（ polymorphism ）在 OOP（ object-oriented programming，面向对象编程）很常见，但却不好理解。窝以为窝懂了，后来发现自己原来不太懂。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一刻，窝还在盲人摸象，希望通过分析多态的优缺点来了解它。我自己摸索着去理解它，所以这些内容不一定是对的。 1 多态简单地说，多态就是： 父类引用指向子类对象。 1Animal a = new Cat(); // Animal 是 Cat 的父类。 子类要重写（ Override ）父类的方法。 如果不了解多态，可以点这里。 2 优点鉴于参考内容的示例代码非常不错，窝就抄过来用了，见谅见谅。这里是出处。 多态当然是有它的优点，才会被引入的嘛。 通过继承和重写（ Override ）非静态方法，对父类进行特定的改写。 虽然引用变量 a 引用的是子类 Cat 的对象，但 a 能访问的是 Animal 的成员变量/常量 Animal 的静态方法 Animal 中未被子类 Cat重写的非静态方法 Cat 中重写的非静态方法。 简单地说，就是不能访问 Animal 中那些被重写的非静态方法。 但是，经过强制转型（ ((Cat) a) ），就又变了个样，比较魔幻了。看不懂不要紧，看代码就好了。 总结：父类引用指向子类对象，等于指向一个改变了（在子类中重写的）某些非静态方法的父类的对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Test { public static void main(String[] args) { Animal a = new Cat(); a.eat(); // 猫吃饭（被 Cat 重写的非静态方法） a.sleep(); // 动物睡觉（ Animal 的静态方法) a.run(); // 动物奔跑（没有被 Cat 重写的静态方法） System.out.println(a.num); // 10 System.out.println(a.age); // 10 ((Cat) a).sleep(); // 猫睡觉 System.out.println(((Cat) a).num); // 100 System.out.println(((Cat) a).age); // 100 }}class Animal { public int num = 10; public static int age = 10; public void eat() { System.out.println(&quot;动物吃饭&quot;); } public static void sleep() { System.out.println(&quot;动物睡觉&quot;); } public void run() { System.out.println(&quot;动物奔跑&quot;); }}class Cat extends Animal{ public int num = 100; public static int age = 100; public String name = &quot;Tom&quot;; @Override public void eat() { System.out.println(&quot;猫吃饭&quot;); } public static void sleep() { System.out.println(&quot;猫睡觉&quot;); } public void catchMouse() { System.out.println(&quot;猫抓老鼠&quot;); }} 复用代码 123public void test(Animal a) { do something with a.} 调用 test 函数时，传入参数可以是 Animal 的对象，也可以是 Animal 的子类的对象。 不需要针对 Animal 子类的对象重载（ Overload ）test 函数，如 public void test(Cat c) 。 其他。。。 代码撸得不够多，想不出来了。 3 缺点 父类引用指向子类对象，无法通过父类引用访问子类的成员变量与静态方法。 12345678public class Test { public static void main(String[] args) { Animal a = new Cat(); a.catchMouse(); System.out.print(a.name); }} 输出： 找不到对象的方法 catchMouse() 和 成员变量 name 。 123456Error:(5, 10) java: cannot find symbol symbol: method catchMouse() location: variable a of type AnimalError:(6, 27) java: cannot find symbol symbol: variable name location: variable a of type Animal 原因：父类 Animal 中没有方法 catchMouse()和成员变量 name 。 4 参考 JAVA的多态用几句话能直观的解释一下吗？ - zhihu Creating object with reference to Interface - StackOverflow Diving Deeper into Polymorphism and its Benefits in Java - developer 以上","link":"/Java/why-polymorphism/"},{"title":"「Java」内存屏障和 Java 并发","text":"简述：本文是 InfoQ 上一篇文章的译文。本人水平有限，对原文理解不足，行文中难免有不通顺之处。如有高见，还请不吝赐教。 内存屏障，或者说内存栅栏，是一组用于限制内存操作的执行顺序的 CPU 指令。本文将解析内存屏障对多线程程序的影响，具体到内存屏障和 JVM 并发结构（如 volatile、synchronized 和 Atomic 类）之间的关系。读者需要对这些概念和 Java 内存模型有扎实的理解。不过，文章并不打算阐述互斥（mutual exclusion），并行（parallelism）或者原子性（atomicity）。内存屏障用于实现一个很重要的并发编程基本特性，即 可见性。 感谢 Brian Goetz 和 Eric Yew 对文章的审阅工作，同时也感谢 Christian Thalinger 提供的 SPARC 框架设备。 为什么内存屏障如此重要访问主内存（main memory）一次需要数以百计个时钟周期（clock cycle）。CPU 使用缓存（cache）将内存延迟（memory latency）的开销降低了几个数量级。为了提高性能，缓存会对挂起（pending）的内存操作进行重排序（re-order）。也就是说，程序的读/写操作不一定按照代码顺序来执行。 当数据是不可变的（immutable）或被封闭在某个线程内（confined to the scope of one thread）时，这种优化不会改变程序结果。然而，当指令重排序遇上对称多处理（symmetric multi-processing）和共享可变状态（shared mutable state）这些情况时，可能会是一场噩梦。 对共享可变数据的内存操作进行重排序时，程序运行结果会变得不确定，比如一个线程可能以与代码顺序不一致的顺序来修改对另一个线程可见（visible）的值。不过，内存屏障可以通过让处理器序列化（serialize）挂起（pending）的内存操作来避免这个问题。 内存屏障作为协议JVM 并不直接显露内存屏障。（Memory barriers are not directly exposed by the JVM. ）反之，为了保证语言级的并发原语语义，它们被 JVM 插入到指令序列中。（Instead they are inserted into the instruction sequence by the JVM in order to uphold the semantics of language level concurrency primitives. ）我们将会看一些 Java 简单源码和其汇编指令，以了解其中原理。 让我们用 Dekker's algorithm ，来学习内存屏障的速成课程。该算法使用三个 volatile 变量（intentFirst、intentSecond、turn）来协调（coordinate）两个线程之间对共享资源的访问。 1234567891011121314 // 线程 1 // 线程 2 1 intentFirst = true; intentSecond = true; 2 3 while (intentSecond) { while (intentFirst) { // volatile 读 4 if (turn != 0) { if (turn != 1) { // volatile 读 5 intentFirst = false; intentSecond = false; 6 while (turn != 0) {} while (turn != 1) {} 7 intentFirst = true; intentSecond = true; 8 } } 9 } }10 criticalSection(); criticalSection();1112 turn = 1; turn = 0; // volatile 写13 intentFirst = false; intentSecond = false; // volatile 写 不要关注这个算法的细节。那么，该看些什么呢？ 仔细看，每个线程都试图在第一行通过将自己的 intent 置为 true 来进入临界区（critical section）。如果一个线程在第三行观察（observe）到冲突（即两个线程的 intent 都为 true），那么将通过轮流执行（turn taking）来解决冲突。在给定的时间点上，只有一个线程可以访问临界区。 硬件优化（hardware optimizations）在没有内存屏障的情况下会使代码运行结果变得不确定，即使编译器以代码顺序来编译这些内存操作。 看第 3 行和第 4 行上的两个连续的 volatile 读操作。每个线程都会检查另一个线程是否有进入临界区的 intent，再检查轮到谁了。 看第 12 行和第 13 行上的两个连续的 volatile 写操作。每个线程将变量 turn 改为另一个线程对应的值，并且将自己进入临界区的 intent 置为 false。 读线程不应该在另一个线程将其 intent 置为 false 后才观察到那个线程对变量 turn 的写操作，这将是一场灾难（A reading thread should never expect to observe the other thread’s write to the turn variable after the other thread’s withdrawal of intent. This would be a disaster. ）。但如果没有用 volatile 修饰这些变量，就会发生这种情况！比如，假如没有 volatile ，在线程 1 对变量 turn 写入(线程 1 倒数第二行)之前，线程 2 可能可以观察到线程 1 对 intentFirst 的写入(线程 1 最后一行)。 关键字 volatile 可以避免这个问题，因为它在对 turn 变量的写入和对 intentFirst 变量的写入之间建立了一个 happens before 关系（The keyword volatile prevents this problem because it establishes a happens before relationship between the write to the turn variable and the write to the intentFirst variable. ）。编译器不能对这些写操作重排序，如果必须的话，它就会使用内存屏障来禁止处理器的重排序。 HotSpot 选项 PrintAssembly 是 JVM 的一个诊断标志（diagnostic flag），它能够让我们获取 JIT 编译器生成的汇编指令。这需要最新的 OpenJDK 版本（update 14 或以上）或新版 HotSpot。另外还需要一个反汇编插件。Kenai 就有适合 Solaris、Linux 和 BSD 平台的插件。hsdis 插件可以作为 Windows 平台上的替代方案。 源码中第 3 行连续的两个读操作中的第一个体现在下面的汇编指令中。环境是多核 CPU Itanium 2，JDK 1.6（Update 17）。 下面的所有汇编指令，所有指令流都是按照左侧的行号进行排序的。相关的读操作、写操作和内存屏障指令都有前缀 *。建议读者不要陷入对每条指令的语义思考中。 12345678(Itanium)1 0x2000000001de819c: adds r37=597, r36 ;...841125542* 0x2000000001de81a0: ld1.acq r38=[r37] ;...0b30014a a0103 0x2000000001de81a6: nop.m 0x0 ;...00000002 00c04 0x2000000001de81ac: sxt1 r38=r38 ;...005130045 0x2000000001de81b0: cmp4.eq p0, p6=0, r38 ;...1100004c 86396 0x2000000001de81b6: nop.i 0x0 ;...00000002 00037 0x2000000001de81bc: br.cond.dpnt.many 0x2000000001de8220;; 这些简短的指令说来就话长了。第一个 volatile 读在第 2 行。Java 内存模型保证 JVM 会在第二次 volatile 读之前，按程序顺序将第一个 volatile 读传递给 CPU 。但这还不够，因为 CPU 仍然可以乱序执行这些操作。为了维护 Java 内存模型的一致性，JVM 使用带参数的 ld.acq （load acquire）来注释（annotate）第一个 volatile 读操作。通过使用 ld.acq ，编译器可以确保第 2 行上的读操作在后续的读操作之前完成。这样，问题就解决了。 注意，这影响的是读，而不是写。这里需要介绍一下单向内存屏障和双向内存屏障。 单向内存屏障：对读 或 写强制排序。ld.acq 就是一个例子。 双向内存屏障：对读 和 写强制排序。 一致性是双向的。（Consistency is a two way street. ）如果另一个线程没有将写操作和写操作分开（separate），那么读线程在两次读操作之间插入一个内存屏障有什么用呢？为了让线程间进行通信，它们都必须遵守协议（protocol），就像网络中的节点，或者团队中的人。如果一个线程不遵守协议，那么其他线程的工作（effort）就没有意义。在 Dekker's algorithm 中最后两行代码（即两个 volatile 写操作）对应的汇编指令中，我们会看到一个内存屏障。 $ java -XX:+UnlockDiagnosticVMOptions -XX:PrintAssemblyOptions=hsdis-print-bytes -XX:CompileCommand=print,WriterReader.write WriterReader 1234567891011(Itanium) 1 0x2000000001de81c0: adds r37=592,r36 ;...0b284149 0421 2 0x2000000001de81c6: st4.rel [r37]=r39 ;...00389560 2380 3 0x2000000001de81cc: adds r36=596,r36 ;...84112544 4* 0x2000000001de81d0: st1.rel [r36]=r0 ;...09000048 a011 5* 0x2000000001de81d6: mf ;...00000044 0000 6 0x2000000001de81dc: nop.i 0x0 ;...00040000 7 0x2000000001de81e0: mov r12=r33 ;...00600042 0021 8 0x2000000001de81e6: mov.ret b0=r35,0x2000000001de81e0 9 0x2000000001de81ec: mov.i ar.pfs=r34 ;...00aa022010 0x2000000001de81f0: mov r6=r32 ;...09300040 0021 在第 4 行，我们可以看到第二个写操作用显式内存屏障进行了注释（annotate）。通过使用带参数的 st.rel（或 store release），编译器可以确保第一个写操作在第二个写操作之前是可见的。这就达成了协议的双向性（This completes both sides of the protocol），因为第一个写操作发生在第二个写操作之前。 指令 st.rel 是单向内存屏障，就像 ld.acq 一样。但是，在第 5 行，编译器还添加了一个双向内存屏障。指令 mf（memory fence），是 Itanium 2 指令集中的一个完全内存屏障（fully fence）。 内存屏障是硬件特性本文不打算对所有内存屏障做全面概述，这太费时费力了。重要的是要认识到，内存屏障的指令在不同的硬件架构中有相当大的差异。下面是在多核 CPU Intel Xeon 上获取的连续 volatile 写操作的汇编指令。本文中余下所有汇编指令都是基于 Intel Xeon 的，除非另有说明。 12345678910111213141516 （Intel Xeon x86) 1 0x03f8340c: push %ebp ;...55 2 0x03f8340d: sub $0x8, %esp ;...81ec0800 0000 3 0x03f83413: mov $0x14c, %edi ;...bf4c0100 00 4 0x03f83418: movb $0x1, -0x505a72f0(%edi) ;...c687108d a5af01 5 0x03f8341f: mfence ;...0faef0 6 0x03f83422: mov $0x148, %ebp ;...bd480100 00 7 0x03f83427: mov $0x14d, %edx ;...ba4d0100 00 8 0x03f8342c: movsbl -0x505a72f0(%edx), %ebx ;...0fbe9a10 8da5af 9 0x03f83433: test %ebx, %ebx ;...85db10 0x03f83435: jne 0x03f83460 ;...752911 0x03f83437: movl $0x1, -0x505a72f0(%ebp) ;...c785108d a5af0112 0x03f83441: movb $0x0, -0x505a72f0(%edi) ;...c687108d a5af0013* 0x03f83448: mfence ;...0faef014 0x03f8344b: add $0x8,%esp ;...83c40815 0x03f8344e: pop %ebp ;...5d 基于 x86 Xeon 的汇编指令第 11 行和第 12 行，我们看到 volatile 写操作。第二个写操作后有一个 mfence 指令（第 13 行），这是一个显式的双向内存屏障。 下面是基于 SPARC 的连续 volatile 写操作。 123456789101112(SPARC) 1 0xfb8ecc84: ldub [ %l1 + 0x155 ], %l3 ;...e60c6155 2 0xfb8ecc88: cmp %l3, 0 ;...80a4e000 3 0xfb8ecc8c: bne, pn %icc, 0xfb8eccb0 ;...12400009 4 0xfb8ecc90: nop ;...01000000 5 0xfb8ecc94: st %l0, [ %l1 + 0x150 ] ;...e0246150 6 0xfb8ecc98: clrb [ %l1 + 0x154 ] ;...c02c6154 7* 0xfb8ecc9c: membar #StoreLoad ;...8143e002 8 0xfb8ecca0: sethi %hi(0xff3fc000), %l0 ;...213fcff0 9 0xfb8ecca4: ld [ %l0 ], %g0 ;...c004200010 0xfb8ecca8: ret ;...81c7e00811 0xfb8eccac: restore ;...81e80000 在第 5 行和第 6 行可以看到 volatile 写操作。第二个写操作后跟随有 membar 指令（第 7 行），这也是一个显式的双向内存屏障。 x86 和 SPARC 的指令流与 Itanium 的指令流之间有一个重要的区别。JVM 在 x86 和 SPARC 上在连续的写操作后设置了内存屏障，但是在这两个写操作之间没有设置内存屏障。然而，Itanium 的指令流在两个写操作之间有一个内存屏障。 为什么 JVM 在不同的硬件架构中表现不同？ 因为每种硬件架构都有一个内存模型，每个内存模型都有自己的一套一致性保证（consistent guarantee）体系。比如 x86 或 SPARC 的内存模型，有非常强大的一致性保证。其他内存模型，如 Itanium、PowerPC 或 Alpha，则较为宽松（relaxed）。比如，x86 和 SPARC 不会重排序连续的写操作，所以不需要内存屏障。而 Itanium、PowerPC 和 Alpha 会对连续的写操作进行重排序，因此 JVM 必须在写操作之间设置一个内存屏障。 也就是说，JVM 使用内存屏障来消除 Java 内存模型和硬件的内存模型之间的差异。 隐式内存屏障显式的指令 fence 不是序列化（serialize）内存操作的唯一方法。让我们来看看 Counter 类这个例子。 123456789101112class Counter{ static int counter = 0; public static void main(String[] _) { for (int i = 0; i &lt; 100000; i++) inc(); } static synchronized void inc() { counter += 1; }} Counter 类中有一个经典的“读 - 修改 - 写”操作。因为这三个操作一定是原子操作（即组合起来就不是原子操作）， 所以不能用 volatile 修饰静态字段 counter ，得用 synchronized 修饰方法 inc()。我们可以使用以下命令编译 Counter 类并查看方法 inc() 生成的汇编指令。Java 内存模型为 synchronized 区域的退出操作（exiting of synchronized regions） 提供了与 volatile 内存操作（volatile memory operations）相同的可见性语义（visibility semantics），因此我们会看到另一种内存屏障。 $ java -XX:+UnlockDiagnosticVMOptions -XX:PrintAssemblyOptions=hsdis-print-bytes -XX:-UseBiasedLocking -XX:CompileCommand=print,Counter.inc Counter 1234567891011121314151617181920212223242526272829(Intel Xeon) 1 0x04d5eda7: push %ebp ;...55 2 0x04d5eda8: mov %esp,%ebp ;...8bec 3 0x04d5edaa: sub $0x28,%esp ;...83ec28 4 0x04d5edad: mov $0x95ba5408,%esi ;...be0854ba 95 5 0x04d5edb2: lea 0x10(%esp),%edi ;...8d7c2410 6 0x04d5edb6: mov %esi,0x4(%edi) ;...897704 7 0x04d5edb9: mov (%esi),%eax ;...8b06 8 0x04d5edbb: or $0x1,%eax ;...83c801 9 0x04d5edbe: mov %eax,(%edi) ;...890710* 0x04d5edc0: lock cmpxchg %edi,(%esi) ;...f00fb13e11 0x04d5edc4: je 0x04d5edda ;...0f841000 000012 0x04d5edca: sub %esp,%eax ;...2bc413 0x04d5edcc: and $0xfffff003,%eax ;...81e003f0 ffff14 0x04d5edd2: mov %eax,(%edi) ;...890715 0x04d5edd4: jne 0x04d5ee11 ;...0f853700 000016 0x04d5edda: mov $0x95ba52b8,%eax ;...b8b852ba 9517 0x04d5eddf: mov 0x148(%eax),%esi ;...8bb04801 000018* 0x04d5ede5: inc %esi ;...4619 0x04d5ede6: mov %esi,0x148(%eax) ;...89b04801 000020 0x04d5edec: lea 0x10(%esp),%eax ;...8d44241021 0x04d5edf0: mov (%eax),%esi ;...8b3022 0x04d5edf2: test %esi,%esi ;...85f623 0x04d5edf4: je 0x04d5ee07 ;...0f840d00 000024 0x04d5edfa: mov 0x4(%eax),%edi ;...8b780425* 0x04d5edfd: lock cmpxchg %esi,(%edi) ;...f00fb13726 0x04d5ee01: jne 0x04d5ee1f ;...0f851800 000027 0x04d5ee07: mov %ebp,%esp ;...8be528 0x04d5ee09: pop %ebp ;...5d 不出意外，synchronized 生成的指令数量比 volatile 的多。多出部分可以在第 18 行找到，但 JVM 并没有插入显式内存屏障。相反，JVM 在第 10 行和第 25 行使用了两次带 lock 前缀的 cmpxchg 指令。（解释 cmpxchg 指令的语义超出了本文的范围。）值得注意的是，lock cmpxchg 不仅自动执行写操作，它还会刷新挂起（flush pending）的读和写操作。写操作将在所有后续内存操作之前都可见。如果我们使用 java.util.concurrent.atomic 来重构并运行 Counter 类，我们可以看到同样的技巧（trick）。 12345678910import java.util.concurrent.atomic.AtomicInteger;class Counter{ static AtomicInteger counter = new AtomicInteger(0); public static void main(String[] args){ for(int i = 0; i &lt; 1000000; i++) counter.incrementAndGet(); }} $ java -XX:+UnlockDiagnosticVMOptions -XX:PrintAssemblyOptions=hsdis-print-bytes -XX:CompileCommand=print,*AtomicInteger.incrementAndGet Counter 1234567891011121314151617181920212223(Intel Xeon) 1 0x024451f7: push %ebp ;...55 2 0x024451f8: mov %esp,%ebp ;...8bec 3 0x024451fa: sub $0x38,%esp ;...83ec38 4 0x024451fd: jmp 0x0244520a ;...e9080000 00 5 0x02445202: xchg %ax,%ax ;...6690 6 0x02445204: test %eax,0xb771e100 ;...850500e1 71b7 7 0x0244520a: mov 0x8(%ecx),%eax ;...8b4108 8 0x0244520d: mov %eax,%esi ;...8bf0 9 0x0244520f: inc %esi ;...4610 0x02445210: mov $0x9a3f03d0,%edi ;...bfd0033f 9a11 0x02445215: mov 0x160(%edi),%edi ;...8bbf6001 000012 0x0244521b: mov %ecx,%edi ;...8bf913 0x0244521d: add $0x8,%edi ;...83c70814* 0x02445220: lock cmpxchg %esi,(%edi) ;...f00fb13715 0x02445224: mov $0x1,%eax ;...b8010000 0016 0x02445229: je 0x02445234 ;...0f840500 000017 0x0244522f: mov $0x0,%eax ;...b8000000 0018 0x02445234: cmp $0x0,%eax ;...83f80019 0x02445237: je 0x02445204 ;...74cb20 0x02445239: mov %esi,%eax ;...8bc621 0x0244523b: mov %ebp,%esp ;...8be522 0x0244523d: pop %ebp ;...5d 在第 14 行，我们再次看到写操作有 lock 前缀。这将确保在所有后续内存操作之前，变量的新值对其他线程都可见。 内存屏障可被消除JVM 知道如何消除不必要的内存屏障。 如果硬件内存模型的一致性保证（consistency guarantee）强于等于 Java 内存模型的一致性保证，这种情况下就比较简单，JVM 只会插入 no op，而不是实际的内存屏障。例如，x86 和 SPARC 硬件的内存模型的一致性保证足够强大，在读取 volatile 变量时就无需设置内存屏障。 还记得在 Itanium 上用来分隔两个读操作的显式单向内存屏障（ld.acq）吗？没错，在 x86 上 Dekker's algorithm 中连续的 volatile 读操作的汇编指令没有内存屏障。 在 x86 上，对共享内存的连续读操作。（A read followed by a read of shared memory on x86.） 12345678910111213141516(x86 Dekker) 1 0x03f83422: mov $0x148,%ebp ;...bd480100 00 2 0x03f83427: mov $0x14d,%edx ;...ba4d0100 00 3* 0x03f8342c: movsbl -0x505a72f0(%edx),%ebx ;...0fbe9a10 8da5af 4 0x03f83433: test %ebx,%ebx ;...85db 5 0x03f83435: jne 0x03f83460 ;...7529 6 0x03f83437: movl $0x1,-0x505a72f0(%ebp) ;...c785108d a5af01 7 0x03f83441: movb $0x0,-0x505a72f0(%edi) ;...c687108d a5af00 8 0x03f83448: mfence ;...0faef0 9 0x03f8344b: add $0x8,%esp ;...83c40810 0x03f8344e: pop %ebp ;...5d11 0x03f8344f: test %eax,0xb78ec000 ;...850500c0 8eb712 0x03f83455: ret ;...c313 0x03f83456: nopw 0x0(%eax,%eax,1) ;...66660f1f 84000014* 0x03f83460: mov -0x505a72f0(%ebp),%ebx ;...8b9d108d a5af15 0x03f83466: test %edi,0xb78ec000 ;...853d00c0 8eb7 volatile 读操作位于第 3 行和第 14 行。它们都没有配以内存屏障。换句话说，在 x86 上（或者在 SPARC 上）执行 volatile 读操作时，唯一的性能损失就是不能对指令重排优化，指令本身与普通读操作没有什么不同。 另外，单向内存屏障的开销自然要比双向的低。当 JVM 知道单向内存屏障已经足够时，它就不会使用双向内存屏障，本文中的第一个示例证明了这一点。我们看到 Itanium 上两个连续的 volatile 读操作中的第一个使用一个单向内存屏障（ld.acq）进行注释（annotate）。如果使用显式的双向内存屏障对读操作进行注释）进行注释（annotate），程序仍然是正确的，但延迟开销（latency cost）会增大。 动态编译静态编译器在构建时所知道的事情，动态编译器在运行时都会知道，甚至更多。更多的信息意味着更多的优化可能。例如，让我们看看 JVM 在单处理器上运行时如何使用内存屏障。下面的指令流是 Dekker 算法中两个连续的 volatile 写操作的运行时编译结果。环境是 VMWare WorkStation 里的单处理器模式 x86 镜像。 1234567891011121314(x86) 1 0x017b474c: push %ebp ;...55 2 0x017b474d: sub $0x8,%esp ;...81ec0800 0000 3 0x017b4753: mov $0x14c,%edi ;...bf4c0100 00 4 0x017b4758: movb $0x1,-0x507572f0(%edi) ;...c687108d 8aaf01 5 0x017b475f: mov $0x148,%ebp ;...bd480100 00 6 0x017b4764: mov $0x14d,%edx ;...ba4d0100 00 7 0x017b4769: movsbl -0x507572f0(%edx),%ebx ;...0fbe9a10 8d8aaf 8 0x017b4770: test %ebx,%ebx ;...85db 9 0x017b4772: jne 0x017b4790 ;...751c10* 0x017b4774: movl $0x1,-0x507572f0(%ebp) ;...c785108d 8aaf0111* 0x017b477e: movb $0x0,-0x507572f0(%edi) ;...c687108d 8aaf0012 0x017b4785: add $0x8,%esp ;...83c40813 0x017b4788: pop %ebp ;...5d 在单处理器系统中，JVM 为所有内存屏障插入 no op，因为内存操作已经序列化（serialize）了。写操作（第 10 行和第 11 行）后不会有内存屏障。JVM 对 atomic 类进行了类似的优化（第 14 行）。下面是在相同的 VMWare 镜像中， AtomicInteger.incrementAndGet() 的运行时编译结果。 1234567891011121314151617181920212223(x86) 1 0x036880f7: push %ebp ;...55 2 0x036880f8: mov %esp,%ebp ;...8bec 3 0x036880fa: sub $0x38,%esp ;...83ec38 4 0x036880fd: jmp 0x0368810a ;...e9080000 00 5 0x03688102: xchg %ax,%ax ;...6690 6 0x03688104: test %eax,0xb78b8100 ;...85050081 8bb7 7 0x0368810a: mov 0x8(%ecx),%eax ;...8b4108 8 0x0368810d: mov %eax,%esi ;...8bf0 9 0x0368810f: inc %esi ;...4610 0x03688110: mov $0x9a3f03d0,%edi ;...bfd0033f 9a11 0x03688115: mov 0x160(%edi),%edi ;...8bbf6001 000012 0x0368811b: mov %ecx,%edi ;...8bf913 0x0368811d: add $0x8,%edi ;...83c70814* 0x03688120: cmpxchg %esi,(%edi) ;...0fb13715 0x03688123: mov $0x1,%eax ;...b8010000 0016 0x03688128: je 0x03688133 ;...0f840500 000017 0x0368812e: mov $0x0,%eax ;...b8000000 0018 0x03688133: cmp $0x0,%eax ;...83f80019 0x03688136: je 0x03688104 ;...74cc20 0x03688138: mov %esi,%eax ;...8bc621 0x0368813a: mov %ebp,%esp ;...8be522 0x0368813c: pop %ebp ;...5d 注意第 14 行中的 cmpxchg 指令。前面我们看到编译器给这个指令添加了一个 lock 前缀。在没有 SMP（symmetric multiprocessing）的情况下，JVM 避免了这种开销，这是静态编译无法做到的。 收尾内存屏障是多线程编程的必要条件。它可以分为不同类型，有显式、隐式之分，也有单向、双向之分。JVM 利用内存屏障实现跨平台的 Java 内存模型。我希望本文能够帮助有经验的 JVM 开发人员更深入地了解他们的代码的工作原理。 参考 Intel 64 and IA-32 Architectures Software Developer’s Manuals IA-64 Application Instruction Set Architecture Guide Java Concurrency in Practice by Brian Goetz JSR-133 Cookbook by Doug Lea Mutual exclusion with Dekker’s Algorithm Examining generated code with PrintAssembly The Kenai Project - a disassembler plugin hsdis - a disassembler plugin 以上！","link":"/Java/memory-barriers-and-java-concurrency/"}],"tags":[{"name":"BaiduPCS-GO","slug":"BaiduPCS-GO","link":"/tags/BaiduPCS-GO/"},{"name":"manual","slug":"manual","link":"/tags/manual/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"TCP&#x2F;IP","slug":"TCP-IP","link":"/tags/TCP-IP/"},{"name":"loopback","slug":"loopback","link":"/tags/loopback/"},{"name":"route","slug":"route","link":"/tags/route/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Context","slug":"Context","link":"/tags/Context/"},{"name":"Application","slug":"Application","link":"/tags/Application/"},{"name":"Activity","slug":"Activity","link":"/tags/Activity/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Debian","slug":"Debian","link":"/tags/Debian/"},{"name":"apt","slug":"apt","link":"/tags/apt/"},{"name":"insert_disc","slug":"insert-disc","link":"/tags/insert-disc/"},{"name":"user","slug":"user","link":"/tags/user/"},{"name":"sudo","slug":"sudo","link":"/tags/sudo/"},{"name":"google","slug":"google","link":"/tags/google/"},{"name":"recaptcha","slug":"recaptcha","link":"/tags/recaptcha/"},{"name":"proxy","slug":"proxy","link":"/tags/proxy/"},{"name":"vps","slug":"vps","link":"/tags/vps/"},{"name":"digitalocean","slug":"digitalocean","link":"/tags/digitalocean/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"instructions","slug":"instructions","link":"/tags/instructions/"},{"name":"TensorFlow","slug":"TensorFlow","link":"/tags/TensorFlow/"},{"name":"bazel","slug":"bazel","link":"/tags/bazel/"},{"name":"build","slug":"build","link":"/tags/build/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"pyqt5","slug":"pyqt5","link":"/tags/pyqt5/"},{"name":"common methods","slug":"common-methods","link":"/tags/common-methods/"},{"name":"gui","slug":"gui","link":"/tags/gui/"},{"name":"Hexo - counting_function -","slug":"Hexo-counting-function","link":"/tags/Hexo-counting-function/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"conversion","slug":"conversion","link":"/tags/conversion/"},{"name":"char","slug":"char","link":"/tags/char/"},{"name":"string","slug":"string","link":"/tags/string/"},{"name":"data types","slug":"data-types","link":"/tags/data-types/"},{"name":"OS","slug":"OS","link":"/tags/OS/"},{"name":"process","slug":"process","link":"/tags/process/"},{"name":"thread","slug":"thread","link":"/tags/thread/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"win7","slug":"win7","link":"/tags/win7/"},{"name":"setup","slug":"setup","link":"/tags/setup/"},{"name":"CUDA","slug":"CUDA","link":"/tags/CUDA/"},{"name":"cuDNN","slug":"cuDNN","link":"/tags/cuDNN/"},{"name":"multiple-pc","slug":"multiple-pc","link":"/tags/multiple-pc/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"Internet","slug":"Internet","link":"/tags/Internet/"},{"name":"DHCP","slug":"DHCP","link":"/tags/DHCP/"},{"name":"testing","slug":"testing","link":"/tags/testing/"},{"name":"PowerMock","slug":"PowerMock","link":"/tags/PowerMock/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Web Server","slug":"Web-Server","link":"/tags/Web-Server/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"存疑","slug":"存疑","link":"/tags/%E5%AD%98%E7%96%91/"},{"name":"experience","slug":"experience","link":"/tags/experience/"},{"name":"system","slug":"system","link":"/tags/system/"},{"name":"GPT","slug":"GPT","link":"/tags/GPT/"},{"name":"MBR","slug":"MBR","link":"/tags/MBR/"},{"name":"qpushbutton","slug":"qpushbutton","link":"/tags/qpushbutton/"},{"name":"signal","slug":"signal","link":"/tags/signal/"},{"name":"slot","slug":"slot","link":"/tags/slot/"},{"name":"event-driven","slug":"event-driven","link":"/tags/event-driven/"},{"name":"vector","slug":"vector","link":"/tags/vector/"},{"name":"VScode","slug":"VScode","link":"/tags/VScode/"},{"name":"os.getcwd()","slug":"os-getcwd","link":"/tags/os-getcwd/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"polymorphism","slug":"polymorphism","link":"/tags/polymorphism/"},{"name":"advantage","slug":"advantage","link":"/tags/advantage/"},{"name":"disadvange","slug":"disadvange","link":"/tags/disadvange/"},{"name":"concurrency","slug":"concurrency","link":"/tags/concurrency/"},{"name":"memory barrier","slug":"memory-barrier","link":"/tags/memory-barrier/"},{"name":"visibility","slug":"visibility","link":"/tags/visibility/"}],"categories":[{"name":"Manual","slug":"Manual","link":"/categories/Manual/"},{"name":"Network","slug":"Network","link":"/categories/Network/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Experience","slug":"Experience","link":"/categories/Experience/"},{"name":"SQL","slug":"SQL","link":"/categories/SQL/"},{"name":"TensorFlow","slug":"TensorFlow","link":"/categories/TensorFlow/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"OS","slug":"OS","link":"/categories/OS/"},{"name":"Testing","slug":"Testing","link":"/categories/Testing/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"PyQt5","slug":"Python/PyQt5","link":"/categories/Python/PyQt5/"}]}